<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Emit</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.Emit.AssemblyBuilder">
      <summary>定义并表示动态程序集。</summary>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
      <summary>定义具有指定名称和访问权限的动态程序集。</summary>
      <param name="name">程序集的名称。</param>
      <param name="access">程序集的访问权限。</param>
      <returns>表示新程序集的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
      <summary>定义具有指定名称、访问权限和属性的新程序集。</summary>
      <param name="name">程序集的名称。</param>
      <param name="access">程序集的访问权限。</param>
      <param name="assemblyAttributes">包含程序集属性的集合。</param>
      <returns>表示新程序集的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
      <summary>在此程序集中定义命名的暂时动态模块。</summary>
      <param name="name">动态模块的名称。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 以空格开始。  
  
- 或 - 
<paramref name="name" /> 的长度为零。  
  
- 或 - 
<paramref name="name" /> 的长度超过系统定义的最大长度。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <exception cref="T:System.ExecutionEngineException">无法加载默认符号编写器的程序集。  
  
 - 或 -  
  
 找不到实现默认符号编写器接口的类型。</exception>
      <returns>一个表示定义的动态模块的 <see cref="T:System.Reflection.Emit.ModuleBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)">
      <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
      <param name="obj">与此实例进行比较的对象，或为 <see langword="null" />。</param>
      <returns>如果 <see langword="true" /> 等于此实例的类型和值，则为 <paramref name="obj" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回已应用于当前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 的所有自定义属性。</summary>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <returns>一个包含自定义属性的数组；如果没有任何属性，该数组将为空。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回已应用于当前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 且派生自指定特性类型的所有自定义特性。</summary>
      <param name="attributeType">从中派生特性的基类型。</param>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> 不是由运行时提供的 <see cref="T:System.Type" /> 对象。 例如，<paramref name="attributeType" /> 是一个 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象。</exception>
      <returns>包含派生自 <paramref name="attributeType" /> 中任意级别的自定义特性的数组；如果没有此类特性，则数组为空。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData">
      <summary>返回 <see cref="T:System.Reflection.CustomAttributeData" /> 对象，这些对象包含已应用到当前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 的特性的相关信息。</summary>
      <returns>
        <see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，表示已应用到当前模块的特性的相关数据。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
      <summary>返回具有指定名称的动态模块。</summary>
      <param name="name">请求的动态模块的名称。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>表示请求的动态模块的 ModuleBuilder 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
      <summary>获取此程序集中定义的导出类型。</summary>
      <exception cref="T:System.NotSupportedException">未实现此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>一个 <see cref="T:System.Type" /> 数组，其中包含此程序集中定义的导出类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)">
      <summary>获取此程序集清单的文件表中指定文件的 <see cref="T:System.IO.FileStream" />。</summary>
      <param name="name">指定文件的名称。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>为指定文件的 <see cref="T:System.IO.FileStream" />，如果找不到文件，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)">
      <summary>获取程序集清单的文件表中的文件，指定是否包括资源模块。</summary>
      <param name="getResourceModules">
        <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>一个 <see cref="T:System.IO.FileStream" /> 对象数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode">
      <summary>返回此实例的哈希代码。</summary>
      <returns>32 位有符号整数哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)">
      <summary>返回属于此程序集的所有已加载模块，并根据需要包括资源模块。</summary>
      <param name="getResourceModules">
        <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
      <returns>属于此程序集的已加载模块。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)">
      <summary>返回关于给定资源如何保持的信息。</summary>
      <param name="resourceName">资源的名称。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>使用资源的拓扑信息填充的 <see cref="T:System.Reflection.ManifestResourceInfo" />；如果未找到资源，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
      <summary>从此程序集加载指定的清单资源。</summary>
      <exception cref="T:System.NotSupportedException">动态程序集不支持此方法。 若要获取清单资源名称，请使用 <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>包含所有资源的名称的类型 <see langword="String" /> 数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)">
      <summary>从此程序集加载指定的清单资源。</summary>
      <param name="name">正在请求的清单资源的名称。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>表示此清单资源的 <see cref="T:System.IO.Stream" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)">
      <summary>从此程序集加载指定清单资源，清单资源的范围由指定类型的命名空间确定。</summary>
      <param name="type">其命名空间用于确定清单资源名的范围的类型。</param>
      <param name="name">正在请求的清单资源的名称。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>表示此清单资源的 <see cref="T:System.IO.Stream" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)">
      <summary>获取此程序集中的指定模块。</summary>
      <param name="name">所请求模块的名称。</param>
      <returns>所请求的模块，若未找到该模块则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)">
      <summary>获取属于此程序集的所有模块，并根据需要包括资源模块。</summary>
      <param name="getResourceModules">
        <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
      <returns>属于此程序集的模块。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)">
      <summary>获取在创建当前动态程序集时指定的 <see cref="T:System.Reflection.AssemblyName" />，并将基本代码设置为指定代码。</summary>
      <param name="copiedName">若要将基本代码设置为其被卷影复制后的程序集位置，则为 <see langword="true" />；若要将基本代码设置为原位置，则为 <see langword="false" />。</param>
      <returns>动态程序集的名称。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies">
      <summary>获取由此 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 引用的程序集的 <see cref="T:System.Reflection.AssemblyName" /> 对象的不完整列表。</summary>
      <returns>引用的程序集的程序集名称数组。 此数组不是完整的列表。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)">
      <summary>获取指定区域性的附属程序集。</summary>
      <param name="culture">指定的区域性。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
      <exception cref="T:System.IO.FileLoadException">找到了具有匹配文件名的附属程序集，但 <see langword="CultureInfo" /> 与所指定的不匹配。</exception>
      <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      <returns>指定的附属程序集。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
      <summary>获取指定区域性的附属程序集的指定版本。</summary>
      <param name="culture">指定的区域性。</param>
      <param name="version">附属程序集的版本。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="culture" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.IO.FileLoadException">找到了具有匹配的文件名的附属程序集，但 <see langword="CultureInfo" /> 或版本与所指定的不匹配。</exception>
      <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
      <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      <returns>指定的附属程序集。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>从已在当前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 中定义并创建的类型中获取指定的类型。</summary>
      <param name="name">要搜索的类型的名称。</param>
      <param name="throwOnError">若要在找不到该类型时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <param name="ignoreCase">若要在搜索时忽略类型名称的大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <returns>如果找不到或尚未创建该类型，则为指定的类型或 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>返回一个值，该值指示是否将指定特性类型的一个或多个实例应用于此成员。</summary>
      <param name="attributeType">要测试的特性类型。</param>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <returns>如果一个或多个 <paramref name="attributeType" /> 的实例应用于此动态程序集，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 在此程序集上设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="con" /> 不是 <see langword="RuntimeConstructorInfo" /> 对象。</exception>
    </member>
    <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置此程序集的自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.CodeBase">
      <summary>获取最初指定的程序集的位置（例如，在 <see cref="T:System.Reflection.AssemblyName" /> 对象中）。</summary>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>程序集的位置（按照最初的指定）。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
      <summary>返回此程序集的入口点。</summary>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>此程序集的入口点。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.FullName">
      <summary>获取当前动态程序集的显示名称。</summary>
      <returns>动态程序集的显示名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache">
      <summary>获取一个值，该值指示该程序集是否已从全局程序集缓存中加载。</summary>
      <returns>总是为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.HostContext">
      <summary>获取正在创建动态程序集的宿主上下文。</summary>
      <returns>一个值，它指示正在创建动态程序集的宿主上下文。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion">
      <summary>获取将保存在包含清单的文件中的公共语言运行时的版本。</summary>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>表示公共语言运行时版本的字符串。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic">
      <summary>获取一个值，该值指示当前程序集是动态程序集。</summary>
      <returns>总是为 <see langword="true" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.Location">
      <summary>如果包含清单的已加载文件未进行卷影复制，则以基本代码格式获取其位置。</summary>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>包含清单的已加载文件的位置。 如果已加载文件已进行卷影复制，则 <see langword="Location" /> 是进行卷影复制之前的文件。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule">
      <summary>获取当前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 中包含程序集清单的模块。</summary>
      <returns>清单模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly">
      <summary>获取一个值，该值指示动态程序集是否位于仅反射上下文中。</summary>
      <returns>如果动态程序集位于仅反射上下文中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Emit.AssemblyBuilderAccess">
      <summary>定义动态程序集的访问模式。</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.Run">
      <summary>可以执行但无法保存该动态程序集。</summary>
    </member>
    <member name="F:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect">
      <summary>当动态程序集不再可供访问时，将自动卸载该程序集，并回收其内存。</summary>
    </member>
    <member name="T:System.Reflection.Emit.ConstructorBuilder">
      <summary>定义并表示动态类的构造函数。</summary>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>定义此构造函数的参数。</summary>
      <param name="iSequence">参数在参数列表中的位置。 通过第一个参数以数字 1 开头对参数编制索引。</param>
      <param name="attributes">参数的属性。</param>
      <param name="strParamName">参数的名称。 名称可以是空字符串。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="iSequence" /> 小于 0（零）或大于此构造函数的参数数目。</exception>
      <exception cref="T:System.InvalidOperationException">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <returns>一个对象，它表示此构造函数的新参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回为此构造函数定义的所有自定义属性。</summary>
      <param name="inherit">基类中自定义属性的控件继承。 忽略此参数。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <returns>一个对象数组，它表示由此 <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 实例表示的构造函数的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回由给定类型标识的自定义属性。</summary>
      <param name="attributeType">自定义属性类型。</param>
      <param name="inherit">基类中自定义属性的控件继承。 忽略此参数。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <returns>一个对象数组，它表示此构造函数的新属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator">
      <summary>获取此构造函数的 <see cref="T:System.Reflection.Emit.ILGenerator" />。</summary>
      <exception cref="T:System.InvalidOperationException">该构造函数为无参数构造函数。  
  
- 或 - 
该构造函数具有 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，指示其不能包含方法体。</exception>
      <returns>此构造函数的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)">
      <summary>获取具有指定 MSIL 流大小的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象，它可以用来生成此构造函数的方法体。</summary>
      <param name="streamSize">MSIL 流的大小（以字节为单位）。</param>
      <exception cref="T:System.InvalidOperationException">该构造函数为无参数构造函数。  
  
- 或 - 
该构造函数具有 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，指示其不能包含方法体。</exception>
      <returns>用于此构造函数的 <see cref="T:System.Reflection.Emit.ILGenerator" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags">
      <summary>返回此构造函数的方法实现标志。</summary>
      <returns>此构造函数的方法实现标志。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.GetParameters">
      <summary>返回此构造函数的参数。</summary>
      <exception cref="T:System.InvalidOperationException">在 .NET framework 1.0 和 1.1 版中，尚未在此构造函数的类型上调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
      <exception cref="T:System.NotSupportedException">在 .NET Framework 2.0 版中，尚未在此构造函数的类型上调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
      <returns>一个数组，它表示此构造函数的参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>在指定 <see langword="Binder" /> 的约束下，用指定的参数动态调用此实例反射的构造函数。</summary>
      <param name="obj">需要重新初始化的对象。</param>
      <param name="invokeAttr">指定所需绑定类型的 <see langword="BindingFlags" /> 值之一。</param>
      <param name="binder">一个 <see langword="Binder" />，它定义一组属性并通过反射来启用绑定、自变量类型强制转换和成员调用。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用 Binder.DefaultBinding。</param>
      <param name="parameters">自变量列表。 此自变量数组在数量、顺序和类型方面必须与要调用的构造函数的参数相同。 如果没有参数，则应为一个空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</param>
      <param name="culture">用于控制类型强制转换的 <see cref="T:System.Globalization.CultureInfo" />。 如果这是 NULL，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 你可以使用 <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索构造函数并在返回的 <see cref="T:System.Reflection.ConstructorInfo" /> 上调用 <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />。</exception>
      <returns>与构造函数关联的类的实例。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>动态调用由给定对象上的此实例所表示的构造函数，一并传递指定的参数，并受给定绑定器的约束。</summary>
      <param name="invokeAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 InvokeMethod、NonPublic 等。</param>
      <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果活页夹为 <see langword="null" />，则使用默认活页夹。 请参阅 <see cref="T:System.Reflection.Binder" />。</param>
      <param name="parameters">自变量列表。 此自变量数组在数量、顺序和类型方面必须与要调用的构造函数的参数相同。 如果不存在任何参数，则应为 <see langword="null" />。</param>
      <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 NULL，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 （例如，这对于将表示 1000 的 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 你可以使用 <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索构造函数并在返回的 <see cref="T:System.Reflection.ConstructorInfo" /> 上调用 <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />。</exception>
      <returns>所调用的构造函数返回的值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>检查是否定义了指定的自定义属性类型。</summary>
      <param name="attributeType">自定义属性类型。</param>
      <param name="inherit">基类中自定义属性的控件继承。 忽略此参数。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 你可以使用 <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索构造函数并在返回的 <see cref="T:System.Reflection.ConstructorInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</exception>
      <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>设置此构造函数的方法实现标志。</summary>
      <param name="attributes">方法实现标志。</param>
      <exception cref="T:System.InvalidOperationException">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
    </member>
    <member name="M:System.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>将此 <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 实例作为 <see cref="T:System.String" /> 返回。</summary>
      <returns>一个字符串，它包含此构造函数的名称、属性和异常，后跟当前 Microsoft 中间语言 (MSIL) 流。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Attributes">
      <summary>获取此构造函数的属性。</summary>
      <returns>此构造函数的特性。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention">
      <summary>获取一个 <see cref="T:System.Reflection.CallingConventions" /> 值，该值取决于声明类型是否为泛型。</summary>
      <returns>如果声明类型为泛型，则为 <see cref="F:System.Reflection.CallingConventions.HasThis" />；否则为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType">
      <summary>获取对声明此成员的类型的 <see cref="T:System.Type" /> 对象的引用。</summary>
      <returns>声明此成员的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.InitLocals">
      <summary>获取或设置在此构造函数中的本地变量是否应初始化为零。</summary>
      <returns>读/写。 获取或设置在此构造函数中的本地变量是否应初始化为零。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle">
      <summary>获取此方法的内部句柄。 使用此句柄来访问基础元数据句柄。</summary>
      <exception cref="T:System.NotSupportedException">此类不支持此属性。</exception>
      <returns>方法的内部处理程序。 使用此句柄来访问基础元数据句柄。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Module">
      <summary>获取在其中定义此构造函数的动态模块。</summary>
      <returns>
        <see cref="T:System.Reflection.Module" /> 对象，该对象表示在其中定义此构造函数的动态模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.Name">
      <summary>检索此构造函数的名称。</summary>
      <returns>此构造函数的名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType">
      <summary>保存对从中获取此对象的 <see cref="T:System.Type" /> 对象的引用。</summary>
      <returns>从中 <see langword="Type" /> 获取此对象的对象。</returns>
    </member>
    <member name="T:System.Reflection.Emit.EnumBuilder">
      <summary>描述并表示一个枚举类型。</summary>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.CreateTypeInfo">
      <summary>获取表示此枚举的 <see cref="T:System.Reflection.TypeInfo" /> 对象。</summary>
      <returns>表示此枚举的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.DefineLiteral(System.String,System.Object)">
      <summary>在枚举类型中使用指定的常量值定义命名的静态字段。</summary>
      <param name="literalName">静态字段的名称。</param>
      <param name="literalValue">文字的常量值。</param>
      <returns>已定义的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>按照指定，返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的公共和非公共构造函数。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的指定构造函数。 如果未定义任何构造函数，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回为此构造函数定义的所有自定义属性。</summary>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回对象的数组，表示由此 <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 实例表示的构造函数的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回由给定类型标识的自定义属性。</summary>
      <param name="attributeType">将应用自定义属性的 <see langword="Type" /> 对象。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回一个对象数组，表示此构造函数属于 <see cref="T:System.Type" /><paramref name="attributeType" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetElementType">
      <summary>调用此方法始终引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。</exception>
      <returns>不支持此方法。 不返回任何值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEnumUnderlyingType">
      <summary>返回当前枚举的基础整数类型，该类型是于定义枚举生成器时设置的。</summary>
      <returns>基础类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>返回具有指定名称的事件。</summary>
      <param name="name">要获取的事件的名称。</param>
      <param name="bindingAttr">此调用属性。 这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.EventInfo" /> 对象，该对象表示此类型声明或继承的具有指定名称的事件。 如果没有匹配项，则返回 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents">
      <summary>返回此类型声明或继承的公共事件的事件。</summary>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回表示此类型声明或继承的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象数组。 如果没有任何公共事件，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>返回此类型声明的公共和非公共事件。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.EventInfo" /> 对象数组，表示此类型声明或继承的公共和非公共事件。 按照指定，如果没有事件，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>返回由给定名称指定的字段。</summary>
      <param name="name">要获取的字段的名称。</param>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象，该对象表示由此类型声明或继承的具有指定名称和公共或非公共修饰符的字段。 如果没有匹配项，则返回 null。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>返回此类型声明的公共和非公共字段。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 InvokeMethod、NonPublic 等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共字段。 按照指定，如果没有字段，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterface(System.String,System.Boolean)">
      <summary>使用指定的完全限定名返回此类型（直接或间接）实现的接口。</summary>
      <param name="name">接口的名称。</param>
      <param name="ignoreCase">如果为 <see langword="true" />，则搜索不区分大小写。 如果为 <see langword="false" />，则搜索区分大小写。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Type" /> 对象，该对象表示实现的接口。 如果未找到名称匹配的接口，则返回 null。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaceMap(System.Type)">
      <summary>返回所请求的接口的接口映射。</summary>
      <param name="interfaceType">要为其检索接口映射的接口的类型。</param>
      <exception cref="T:System.ArgumentException">此类型不实现此接口。</exception>
      <returns>所请求的接口映射。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetInterfaces">
      <summary>返回在此类及其基类上实现的所有接口的数组。</summary>
      <returns>返回 <see cref="T:System.Type" /> 对象的数组，表示已实现的接口。 如果未定义任何内容，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>返回具有指定名称、类型并由此类型声明或继承其绑定的所有成员。</summary>
      <param name="name">成员名。</param>
      <param name="type">要返回的成员的类型。</param>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示在此类型上定义的公共和非公共成员；否则，仅返回公共成员。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>返回此类型声明或继承的指定成员。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共成员。 如果没有匹配的成员，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>按照指定，返回此类型声明或继承的所有公共和非公共方法。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MethodInfo" /> 对象数组，表示在该类型上定义的公共和非公共方法；否则，仅返回公共方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>返回此类型声明的指定嵌套的类型。</summary>
      <param name="name">包含要获取的嵌套类型的名称的 <see cref="T:System.String" />。</param>
      <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
- 或 - 
零，表示对公共方法执行区分大小写的搜索。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>表示符合指定要求的嵌套类型的 <see cref="T:System.Type" /> 对象（如果找到）；否则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>返回此类型声明或继承的公共和非公共嵌套类型。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>
        <see cref="T:System.Type" /> 对象数组，表示当前 <see cref="T:System.Type" /> 中嵌套的与指定的绑定约束匹配的所有类型。  
  
如果当前 <see cref="T:System.Type" /> 中未嵌套任何类型，或者如果没有一个嵌套类型与绑定约束匹配，则为类型 <see cref="T:System.Type" /> 的空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>按照指定，返回此类型声明或继承的所有公共和非公共属性。</summary>
      <param name="bindingAttr">此调用属性。 这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.PropertyInfo" /> 对象的数组，表示在此类型上定义的公共和非公共属性；否则，仅返回公共属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>调用指定的成员。 在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</summary>
      <param name="name">要调用的成员的名称。 这可以是构造函数、方法、属性或字段。 必须指定合适的调用属性。 请注意，可以通过将一个空字符串作为成员的名称进行传递来调用一个类的默认成员。</param>
      <param name="invokeAttr">调用属性。 这必须是来自 <see langword="BindingFlags" /> 的位标志。</param>
      <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果活页夹为 <see langword="null" />，则使用默认活页夹。 请参阅 <see cref="T:System.Reflection.Binder" />。</param>
      <param name="target">对其调用指定成员的对象。 如果该成员为静态，则忽略此参数。</param>
      <param name="args">自变量列表。 这是一个对象的数组，该对象包含要调用的成员的参数的数量、顺序和类型。 如果不存在任何参数，则这应为 null。</param>
      <param name="modifiers">与 <paramref name="args" /> 长度相同的数组，其元素表示与要调用的成员的自变量关联的特性。 参数在元数据中具有与之相关联的属性。 它们由不同的互操作性服务使用。 有关更多详细信息，请参阅元数据规范。</param>
      <param name="culture">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。 如果这是 NULL，则使用当前线程的 <see langword="CultureInfo" />。 （注意，这对于某些转换是必要的，例如，将表示 1000 的 String 转换为 Double 值，因为不同区域性的 1000 表示形式不同。）</param>
      <param name="namedParameters">
        <paramref name="namedParameters" /> 数组中的每个参数对应 <paramref name="args" /> 数组中的元素来获取值。 如果 <paramref name="args" /> 的长度大于 <paramref name="namedParameters" /> 的长度，则剩余的自变量值将按顺序传递。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回被调用的成员的返回值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>检查是否定义了指定的自定义属性类型。</summary>
      <param name="attributeType">将应用自定义属性的 <see langword="Type" /> 对象。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>如果在此成员上定义了一个或多个 <paramref name="attributeType" /> 的实例，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType">
      <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</summary>
      <returns>返回一个表示当前类型的一维数组（下限为零）的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeArrayType(System.Int32)">
      <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示一个具有指定维数的当前类型的数组。</summary>
      <param name="rank">数组的维数。 此数字必须小于或等于 32。</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> 小于 1。</exception>
      <returns>表示当前类型的指定维数的数组的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakeByRefType">
      <summary>返回一个 <see cref="T:System.Type" /> 对象，该对象表示作为 ref**** 参数（在 Visual Basic 中为 ByRef**** 参数）传递时的当前类型。</summary>
      <returns>一个 <see cref="T:System.Type" /> 对象，表示作为 ref**** 参数（在 Visual Basic 中为 ByRef**** 参数）传递时的当前类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.MakePointerType">
      <summary>返回表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</summary>
      <returns>表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EnumBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Assembly">
      <summary>检索包含此枚举定义的动态程序集。</summary>
      <returns>只读。 包含此枚举定义的动态程序集。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.AssemblyQualifiedName">
      <summary>返回由父程序集的显示名称限定的此枚举的完整路径。</summary>
      <returns>只读。 由父程序集的显示名称限定的此枚举的完整路径。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.BaseType">
      <summary>返回始终为 <see cref="T:System.Enum" /> 的此类型的父 <see cref="T:System.Type" />。</summary>
      <returns>只读。 此类型的父 <see cref="T:System.Type" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.DeclaringType">
      <summary>返回声明此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 的类型。</summary>
      <returns>只读。 声明此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.FullName">
      <summary>返回此枚举的完整路径。</summary>
      <returns>只读。 此枚举的完整路径。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
      <summary>返回此枚举的 GUID。</summary>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>只读。 此枚举的 GUID。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsConstructedGenericType">
      <summary>获取指示此对象是否表示构造的泛型类型的值。</summary>
      <returns>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.EnumBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.EnumBuilder.Module">
      <summary>检索包含此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 定义的动态模块。</summary>
      <returns>只读。 包含此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 定义的动态模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Name">
      <summary>返回此枚举的名称。</summary>
      <returns>只读。 此枚举的名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.Namespace">
      <summary>返回此枚举的命名空间。</summary>
      <returns>只读。 此枚举的命名空间。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.ReflectedType">
      <summary>返回用于获取此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 的类型。</summary>
      <returns>只读。 用于获取此 <see cref="T:System.Reflection.Emit.EnumBuilder" /> 的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.TypeHandle">
      <summary>检索此枚举的内部句柄。</summary>
      <exception cref="T:System.NotSupportedException">目前不支持此属性。</exception>
      <returns>只读。 此枚举的内部句柄。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingField">
      <summary>返回此枚举的基础字段。</summary>
      <returns>只读。 此枚举的基础字段。</returns>
    </member>
    <member name="P:System.Reflection.Emit.EnumBuilder.UnderlyingSystemType">
      <summary>返回此枚举的基础系统类型。</summary>
      <returns>只读。 返回基础系统类型。</returns>
    </member>
    <member name="T:System.Reflection.Emit.EventBuilder">
      <summary>定义类的事件。</summary>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>添加与该事件关联的“其他”方法之一。 “其他”方法是与该事件关联的、除了“开”(on) 和“引发”(raise) 方法以外的方法。 可以多次调用此函数，以添加一样多的“其他”方法。</summary>
      <param name="mdBuilder">一个表示另一种方法的 <see langword="MethodBuilder" /> 对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetAddOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>设置用于预订该事件的方法。</summary>
      <param name="mdBuilder">
        <see langword="MethodBuilder" /> 对象，表示用于预订该事件的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于描述自定义属性的帮助器类的实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRaiseMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>设置用于引发该事件的方法。</summary>
      <param name="mdBuilder">
        <see langword="MethodBuilder" /> 对象，表示用于引发该事件的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.EventBuilder.SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>设置用于取消预订该事件的方法。</summary>
      <param name="mdBuilder">
        <see langword="MethodBuilder" /> 对象，表示用于取消预订该事件的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="T:System.Reflection.Emit.FieldBuilder">
      <summary>定义并表示字段。 此类不能被继承。</summary>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回为该字段定义的所有自定义属性。</summary>
      <param name="inherit">基类中自定义属性的控件继承。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>类型 <see cref="T:System.Object" /> 的数组，该类型对象表示由此 <see cref="T:System.Reflection.Emit.FieldBuilder" /> 实例表示的构造函数的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回为由给定类型标识的该字段定义的所有自定义属性。</summary>
      <param name="attributeType">自定义属性类型。</param>
      <param name="inherit">基类中自定义属性的控件继承。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>类型 <see cref="T:System.Object" /> 的数组，该类型对象表示由此 <see cref="T:System.Reflection.Emit.FieldBuilder" /> 实例表示的构造函数的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.GetValue(System.Object)">
      <summary>检索给定对象支持的字段值。</summary>
      <param name="obj">在其上访问该字段的对象。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>包含此实例反映的字段值的 <see cref="T:System.Object" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>指示是否在字段上定义了具有指定类型的属性。</summary>
      <param name="attributeType">属性的类型。</param>
      <param name="inherit">基类中自定义属性的控件继承。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> 检索该字段，并对返回的 <see cref="T:System.Reflection.FieldInfo" /> 调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</exception>
      <returns>如果该字段上定义了一个或多个 <paramref name="attributeType" /> 实例，则为 <see langword="true" />否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetConstant(System.Object)">
      <summary>设置该字段的默认值。</summary>
      <param name="defaultValue">该字段的新默认值。</param>
      <exception cref="T:System.InvalidOperationException">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <exception cref="T:System.ArgumentException">该字段不是受支持类型之一。  
  
- 或 - 
<paramref name="defaultValue" /> 类型与该字段类型不匹配。  
  
- 或 - 
该字段的类型为 <see cref="T:System.Object" /> 或其他引用类型，并且 <paramref name="defaultValue" /> 不是 <see langword="null" />无法将该值分配给引用类型。</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此字段的父类型是完整的。</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此字段的父类型是完整的。</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetOffset(System.Int32)">
      <summary>指定字段布局。</summary>
      <param name="iOffset">包含该字段的类型内的字段偏移。</param>
      <exception cref="T:System.InvalidOperationException">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="iOffset" /> 小于零。</exception>
    </member>
    <member name="M:System.Reflection.Emit.FieldBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
      <summary>设置给定对象支持的字段的值。</summary>
      <param name="obj">在其上访问该字段的对象。</param>
      <param name="val">要分配给字段的值。</param>
      <param name="invokeAttr">指定所需绑定类型的 <see langword="IBinder" /> 的成员（例如，IBinder.CreateInstance、IBinder.ExactBinding）。</param>
      <param name="binder">一组使用反射启用绑定、参数类型强制和成员调用的属性。 如果活页夹为 null，则使用 IBinder.DefaultBinding。</param>
      <param name="culture">特定区域性的软件首选项。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Attributes">
      <summary>指示该字段的属性。 此属性为只读。</summary>
      <returns>该字段的属性。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.DeclaringType">
      <summary>指示对声明该字段的类型的 <see cref="T:System.Type" /> 对象的引用。 此属性为只读。</summary>
      <returns>对声明该字段的类型的 <see cref="T:System.Type" /> 对象的引用。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldHandle">
      <summary>指示该字段的内部元数据句柄。 此属性为只读。</summary>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>该字段的内部元数据句柄。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.FieldType">
      <summary>指示表示该字段的类型的 <see cref="T:System.Type" /> 对象。 此属性为只读。</summary>
      <returns>
        <see cref="T:System.Type" /> 对象，表示该字段的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Module">
      <summary>获取在其中定义包含此字段的类型的模块。</summary>
      <returns>
        <see cref="T:System.Reflection.Module" />，表示在其中定义此字段的动态模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.Name">
      <summary>指示该字段的名称。 此属性为只读。</summary>
      <returns>包含该字段的名称的 <see cref="T:System.String" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.FieldBuilder.ReflectedType">
      <summary>指示对从中获取此对象的 <see cref="T:System.Type" /> 对象的引用。 此属性为只读。</summary>
      <returns>对从中获取该实例的 <see cref="T:System.Type" /> 对象的引用。</returns>
    </member>
    <member name="T:System.Reflection.Emit.GenericTypeParameterBuilder">
      <summary>为动态定义的泛型类型和方法定义并创建泛型类型参数。 此类不能被继承。</summary>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.Equals(System.Object)">
      <summary>检测给定对象是否为 <see langword="EventToken" /> 的实例并且是否等于当前实例。</summary>
      <param name="o">要与当前实例进行比较的对象。</param>
      <returns>如果 <paramref name="o" /> 是 <see langword="true" /> 的实例并等于当前实例，则为 <see langword="EventToken" />；否则，为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Boolean)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="attributeType">要搜索的属性的类型。 仅返回可分配给此类型的属性。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetElementType">
      <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>由当前数组类型引用的类型、指针类型，或 <see langword="ByRef" /> 类型；如果当前类型不是数组类型，那么 <see langword="null" /> 不是指针类型，且不能通过引用传递。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">不支持。</param>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents">
      <summary>不支持不完整的泛型类型参数。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">不支持。</param>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericArguments">
      <summary>对泛型类型参数无效。</summary>
      <exception cref="T:System.InvalidOperationException">在所有情况下。</exception>
      <returns>对泛型类型参数无效。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetGenericTypeDefinition">
      <summary>对泛型类型参数无效。</summary>
      <exception cref="T:System.InvalidOperationException">在所有情况下。</exception>
      <returns>对泛型类型参数无效。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetHashCode">
      <summary>返回当前实例的 32 位整数哈希代码。</summary>
      <returns>32 位整数哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterface(System.String,System.Boolean)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">接口的名称。</param>
      <param name="ignoreCase">如果为 <see langword="true" />，则搜索时不考虑大小写；如果为 <see langword="false" />，则搜索时区分大小写。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaceMap(System.Type)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="interfaceType">一个 <see cref="T:System.Type" /> 对象，表示要为其检索映射的接口类型。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetInterfaces">
      <summary>不支持不完整的泛型类型参数。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">不支持。</param>
      <param name="type">不支持。</param>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">不支持。</param>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="bindingAttr">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="name">不支持。</param>
      <param name="invokeAttr">不支持。</param>
      <param name="binder">不支持。</param>
      <param name="target">不支持。</param>
      <param name="args">不支持。</param>
      <param name="modifiers">不支持。</param>
      <param name="culture">不支持。</param>
      <param name="namedParameters">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsAssignableFrom(System.Type)">
      <summary>在所有情况下都会引发 <see cref="T:System.NotSupportedException" /> 异常。</summary>
      <param name="c">要测试的对象。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>在所有情况下都会引发 <see cref="T:System.NotSupportedException" /> 异常。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="attributeType">不支持。</param>
      <param name="inherit">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.IsSubclassOf(System.Type)">
      <summary>不支持不完整的泛型类型参数。</summary>
      <param name="c">不支持。</param>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType">
      <summary>返回元素类型为泛型类型参数的一维数组的类型。</summary>
      <returns>一个 <see cref="T:System.Type" /> 对象，表示元素类型为泛型类型参数的一维数组的类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeArrayType(System.Int32)">
      <summary>返回其元素类型为泛型类型参数，并具有指定维度数的数组类型。</summary>
      <param name="rank">数组的维数。</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> 不是有效的维度数。 例如，其值小于 1。</exception>
      <returns>表示其元素类型为泛型类型参数，并具有指定维度数的数组类型的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeByRefType">
      <summary>返回一个 <see cref="T:System.Type" /> 对象，此对象在作为引用参数传递时表示当前的泛型类型参数。</summary>
      <returns>一个 <see cref="T:System.Type" /> 对象，此对象在作为引用参数传递时表示当前的泛型类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakeGenericType(System.Type[])">
      <summary>对于不完整的泛型类型参数无效。</summary>
      <param name="typeArguments">类型参数数组。</param>
      <exception cref="T:System.InvalidOperationException">在所有情况下。</exception>
      <returns>此方法对不完整的泛型类型参数无效。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.MakePointerType">
      <summary>返回表示指向当前泛型类型参数的指针的 <see cref="T:System.Type" /> 对象。</summary>
      <returns>表示指向当前泛型类型参数的指针的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetBaseTypeConstraint(System.Type)">
      <summary>设置某类型必须继承的基类型，以替换为类型参数。</summary>
      <param name="baseTypeConstraint">任何将替换为类型参数的类型必须继承的 <see cref="T:System.Type" />。</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="binaryAttribute" /> 为空引用。</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">定义自定义属性的帮助器类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)">
      <summary>设置泛型参数的方差特征和特殊约束，例如无参数构造函数约束。</summary>
      <param name="genericParameterAttributes">
        <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于表示泛型类型参数的方差特征和特殊约束。</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.SetInterfaceConstraints(System.Type[])">
      <summary>设置一个类型必须实现的接口，以替换为类型参数。</summary>
      <param name="interfaceConstraints">
        <see cref="T:System.Type" /> 对象的数组，该数组表示一个类型必须实现以替换为类型参数的接口。</param>
    </member>
    <member name="M:System.Reflection.Emit.GenericTypeParameterBuilder.ToString">
      <summary>返回当前泛型类型参数的字符串表示形式。</summary>
      <returns>一个字符串，其中包含泛型类型参数的名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Assembly">
      <summary>获取 <see cref="T:System.Reflection.Assembly" /> 对象，该对象表示包含当前类型参数所属的泛型类型定义的动态程序集。</summary>
      <returns>表示包含当前类型参数所属的泛型类型定义的动态程序集的 <see cref="T:System.Reflection.Assembly" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.AssemblyQualifiedName">
      <summary>在所有情况下均获取 <see langword="null" />。</summary>
      <returns>在所有情况下均为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.BaseType">
      <summary>获取当前泛型类型参数的基类型约束。</summary>
      <returns>表示当前泛型类型参数的基类型约束的 <see cref="T:System.Type" /> 对象，或者如果类型参数没有基类型约束，则为 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ContainsGenericParameters">
      <summary>在所有情况下均获取 <see langword="true" />。</summary>
      <returns>在所有情况下均为 <see langword="true" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringMethod">
      <summary>获取一个表示声明方法的 <see cref="T:System.Reflection.MethodInfo" />（如果当前 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 表示泛型方法的一个类型参数）。</summary>
      <returns>一个表示声明方法的 <see cref="T:System.Reflection.MethodInfo" />（如果当前 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 表示泛型方法的一个类型参数）；否则为 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.DeclaringType">
      <summary>获取泛型类型定义或泛型类型参数所属的泛型方法定义。</summary>
      <returns>如果类型参数属于泛型类型，则为表示该泛型类型的 <see cref="T:System.Type" /> 对象；如果类型参数属于泛型方法，则为表示声明该泛型方法的该类型的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.FullName">
      <summary>在所有情况下均获取 <see langword="null" />。</summary>
      <returns>在所有情况下均为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterAttributes">
      <summary>获取描述当前泛型类型参数的协变和特殊约束的 <see cref="T:System.Reflection.GenericParameterAttributes" /> 标志。</summary>
      <returns>值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GenericParameterPosition">
      <summary>获取声明参数的泛型类型或方法的类型参数列表中的类型参数的位置。</summary>
      <returns>声明参数的泛型类型或方法的类型参数列表中的类型参数的位置。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.GUID">
      <summary>不支持不完整的泛型类型参数。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsConstructedGenericType">
      <summary>获取指示此对象是否表示构造的泛型类型的值。</summary>
      <returns>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericParameter">
      <summary>在所有情况下均获取 <see langword="true" />。</summary>
      <returns>在所有情况下均为 <see langword="true" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericType">
      <summary>在所有情况下均返回 <see langword="false" />。</summary>
      <returns>在所有情况下均为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsGenericTypeDefinition">
      <summary>在所有情况下均获取 <see langword="false" />。</summary>
      <returns>在所有情况下均为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Module">
      <summary>获取包含泛型类型参数的动态模块。</summary>
      <returns>表示包含泛型类型参数的动态模块的 <see cref="T:System.Reflection.Module" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Name">
      <summary>获取泛型类型参数的名称。</summary>
      <returns>泛型类型参数的名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.Namespace">
      <summary>在所有情况下均获取 <see langword="null" />。</summary>
      <returns>在所有情况下均为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.ReflectedType">
      <summary>获取用于获取 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 的 <see cref="T:System.Type" /> 对象。</summary>
      <returns>用于获取 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.TypeHandle">
      <summary>不支持不完整的泛型类型参数。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。</exception>
      <returns>不支持不完整的泛型类型参数。</returns>
    </member>
    <member name="P:System.Reflection.Emit.GenericTypeParameterBuilder.UnderlyingSystemType">
      <summary>获取当前泛型类型参数。</summary>
      <returns>当前的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象。</returns>
    </member>
    <member name="T:System.Reflection.Emit.MethodBuilder">
      <summary>定义并表示动态类上的方法（或构造函数）。</summary>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
      <summary>设置当前方法的泛型类型参数的数目，指定其名称并返回一个可用于定义其约束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的数组。</summary>
      <param name="names">一个字符串数组，表示泛型类型参数的名称。</param>
      <exception cref="T:System.InvalidOperationException">已为此方法定义了泛型类型参数。  
  
- 或 - 
已完成该方法。  
  
- 或 - 
已为当前方法调用了 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 方法。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="names" /> 的元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> 是一个空数组。</exception>
      <returns>一个 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组，表示泛型方法的类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
      <summary>设置参数属性和此方法的参数名称或此方法的返回值的名称。 返回可用于应用自定义属性的 ParameterBuilder。</summary>
      <param name="position">参数在参数列表中的位置。 通过第一个参数以数字 1 开头对参数编制索引；数字 0 表示方法的返回值。</param>
      <param name="attributes">参数的参数属性。</param>
      <param name="strParamName">参数的名称。 名称可以是空字符串。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">此方法没有参数。  
  
- 或 - 
 <paramref name="position" /> 小于零。  
  
- 或 - 
 <paramref name="position" /> 大于此方法的参数数目。</exception>
      <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      <returns>返回 <see langword="ParameterBuilder" /> 对象，该对象表示此方法的参数或此方法的返回值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
      <summary>确定给定对象是否等于此实例。</summary>
      <param name="obj">要与此 <see langword="MethodBuilder" /> 实例进行比较的对象。</param>
      <returns>如果 <paramref name="obj" /> 为 <see langword="MethodBuilder" /> 的实例并且等于此对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
      <summary>返回方法的基实现。</summary>
      <returns>此方法的基实现。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回为此方法定义的所有自定义属性。</summary>
      <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      <returns>返回一个对象数组，其中的对象表示此方法的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回由给定类型标识的自定义属性。</summary>
      <param name="attributeType">自定义属性类型。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      <returns>返回一个对象数组，表示此方法的属性属于类型 <paramref name="attributeType" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
      <summary>返回表示此方法的类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象数组（如果为泛型）。</summary>
      <returns>如果方法是泛型，则为表示此类型参数的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />，或者如果方法不是泛型，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
      <summary>返回此方法。</summary>
      <exception cref="T:System.InvalidOperationException">当前方法不是泛型方法。 也就是说，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 属性将返回 <see langword="false" />。</exception>
      <returns>
        <see cref="T:System.Reflection.Emit.MethodBuilder" /> 的当前实例。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
      <summary>获取此方法的哈希代码。</summary>
      <returns>此方法的哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
      <summary>为此方法返回默认 Microsoft 中间语言 (MSIL) 流大小为 64 字节的 <see langword="ILGenerator" />。</summary>
      <exception cref="T:System.InvalidOperationException">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。  
  
- 或 - 
此方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      <returns>为此方法返回 <see langword="ILGenerator" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
      <summary>为此方法返回具有指定的 Microsoft 中间语言 (MSIL) 流大小的 <see langword="ILGenerator" />。</summary>
      <param name="size">MSIL 流的大小（以字节为单位）。</param>
      <exception cref="T:System.InvalidOperationException">由于其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志，该方法不应具有主体，例如因为它具有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 标志。  
  
- 或 - 
此方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
      <returns>为此方法返回 <see langword="ILGenerator" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
      <summary>为此方法返回实现标志。</summary>
      <returns>为此方法返回实现标志。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.GetParameters">
      <summary>返回此方法的参数。</summary>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see langword="GetParameters" />。</exception>
      <returns>表示此方法的参数的 <see langword="ParameterInfo" /> 对象数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>动态调用方法，此方法由此实例在给定对象上进行反射，传递指定的参数，并受给定绑定器的约束。</summary>
      <param name="obj">在其上调用指定方法的对象。 如果方法是静态的，则忽略此参数。</param>
      <param name="invokeAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <param name="binder">启用绑定、强制参数类型、调用成员并通过反射检索 MemberInfo 对象的对象。 如果活页夹为 <see langword="null" />，则使用默认活页夹。 如需了解详情，请访问 <see cref="T:System.Reflection.Binder" />。</param>
      <param name="parameters">自变量列表。 此自变量数组在数量、顺序和类型方面与要调用的方法的参数相同。 如果不存在任何参数，则应为 <see langword="null" />。</param>
      <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 NULL，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 （请注意，例如，这对于将表示 1000 的 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</exception>
      <returns>返回包含已调用方法的返回值的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>检查是否定义了指定的自定义属性类型。</summary>
      <param name="attributeType">自定义属性类型。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找自定义属性。</param>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</exception>
      <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
      <summary>返回使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</summary>
      <param name="typeArguments">表示泛型方法的类型参数的 <see cref="T:System.Type" /> 对象的数组。</param>
      <returns>一个 <see cref="T:System.Reflection.MethodInfo" />，它表示使用指定泛型类型参数从当前泛型方法定义构造的泛型方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于描述自定义属性的帮助器类的实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
      <summary>为此方法设置实现标志。</summary>
      <param name="attributes">要设置的实现标志。</param>
      <exception cref="T:System.InvalidOperationException">该包含类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
      <summary>为方法设置参数的数量和类型。</summary>
      <param name="parameterTypes">表示参数类型的 <see cref="T:System.Type" /> 对象的数组。</param>
      <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
      <summary>设置方法的返回类型。</summary>
      <param name="returnType">表示方法的返回类型的 <see cref="T:System.Type" /> 对象。</param>
      <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>设置方法签名，包括返回类型、参数类型以及返回类型和参数类型所需和可选的自定义修饰符。</summary>
      <param name="returnType">方法的返回类型。</param>
      <param name="returnTypeRequiredCustomModifiers">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="returnTypeOptionalCustomModifiers">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.InvalidOperationException">当前方法是泛型方法，但不是泛型方法定义。 也就是说，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.MethodBuilder.ToString">
      <summary>将此 <see langword="MethodBuilder" /> 实例作为字符串返回。</summary>
      <returns>返回一个字符串，此字符串包含名称、 属性、 方法签名、 异常和此方法的本地签名，并且末尾处为当前的 Microsoft 中间语言 (MSIL) 流。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Attributes">
      <summary>检索此方法的属性。</summary>
      <returns>只读。 检索此方法的 <see langword="MethodAttributes" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
      <summary>返回此方法的调用约定。</summary>
      <returns>只读。 方法的调用约定。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
      <summary>不支持此类型。</summary>
      <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
      <returns>不支持。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
      <summary>返回声明此方法的类型。</summary>
      <returns>只读。 声明此方法的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.InitLocals">
      <summary>获取或设置一个布尔值，该值指定此方法中的局部变量是否初始化为零。 此属性的默认值为 <see langword="true" />。</summary>
      <exception cref="T:System.InvalidOperationException">对于当前的方法，属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 为 <see langword="false" />。 （获取或设置。）</exception>
      <returns>如果应将此方法中的局部变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
      <summary>获取一个值，该值指示方法是否为泛型方法。</summary>
      <returns>如果该方法是泛型方法，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
      <summary>获取一个值，该值指示当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象是否表示泛型方法的定义。</summary>
      <returns>如果当前 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象表示泛型方法的定义，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
      <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      <returns>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
      <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      <returns>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
      <summary>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">在所有情况下。 动态程序集中不支持此属性。</exception>
      <returns>在所有情况下均引发 <see cref="T:System.NotSupportedException" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
      <summary>检索此方法的内部句柄。 使用此句柄来访问基础元数据句柄。</summary>
      <exception cref="T:System.NotSupportedException">目前尚不支持此方法。 使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 检索此方法，并在返回的 <see cref="T:System.Reflection.MethodInfo" /> 上调用 <see cref="P:System.Reflection.MethodBase.MethodHandle" />。</exception>
      <returns>只读。 方法的内部处理程序。 使用此句柄来访问基础元数据句柄。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Module">
      <summary>获取在其中定义了当前方法的模块。</summary>
      <returns>正在定义其中成员由当前 <see cref="T:System.Reflection.MemberInfo" /> 表示的 <see cref="T:System.Reflection.Module" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.Name">
      <summary>检索此方法的名称。</summary>
      <returns>只读。 检索包含此方法简单名称的字符串。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
      <summary>检索在反射中用于获取此对象的类。</summary>
      <returns>只读。 用于获取此方法的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
      <summary>获取一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，该对象包含有关方法的返回类型的信息（例如返回类型是否具有自定义修饰符）。</summary>
      <exception cref="T:System.InvalidOperationException">尚未创建声明类型。</exception>
      <returns>一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，包含有关返回类型的信息。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnType">
      <summary>获取此 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 所表示的方法的返回类型。</summary>
      <returns>方法的返回类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
      <summary>返回此方法的返回类型的自定义属性。</summary>
      <returns>只读。 此方法的返回类型的自定义属性。</returns>
    </member>
    <member name="T:System.Reflection.Emit.ModuleBuilder">
      <summary>定义和表示动态程序集中的模块。</summary>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
      <summary>完成此动态模块的全局函数定义和全局数据定义。</summary>
      <exception cref="T:System.InvalidOperationException">以前调用过此方法。</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>用指定类型的单个非静态字段（称为 <paramref name="value__" />）定义属于值类型的枚举类型。</summary>
      <param name="name">枚举类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="visibility">枚举的类型特性。 这些特性是由 <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> 定义的任何位。</param>
      <param name="underlyingType">枚举的基础类型。 此类型必须是一种内置的整数类型。</param>
      <exception cref="T:System.ArgumentException">提供的属性不是可见性属性。  
  
- 或 - 
具有给定名称的枚举存在于此模块的父程序集中。  
  
- 或 - 
可见性属性与该枚举的范围不匹配。 例如，将 <paramref name="visibility" /> 指定为 <see cref="F:System.Reflection.TypeAttributes.NestedPublic" />，但是枚举不是嵌套类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的枚举。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>定义一个具有指定名称、属性、调用约定、返回类型和参数类型的全局方法。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。 <paramref name="attributes" /> 必须包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。 也就是说，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
- 或 - 
<see cref="T:System.Type" /> 数组中的一个元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 以前被调用过。</exception>
      <returns>已定义的全局方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>使用指定的名称、属性、调用约定、返回类型、返回类型的自定义修饰符、参数类型以及参数类型的自定义修饰符定义一个全局方法。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null 字符。</param>
      <param name="attributes">方法的属性。 <paramref name="attributes" /> 必须包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="requiredReturnTypeCustomModifiers">一个表示返回类型必需的自定义修饰符的类型数组，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" /> 或 <see cref="T:System.Runtime.CompilerServices.IsBoxed" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="optionalReturnTypeCustomModifiers">一个表示返回类型的可选自定义修饰符的类型数组，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" /> 或 <see cref="T:System.Runtime.CompilerServices.IsBoxed" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="requiredParameterTypeCustomModifiers">由类型数组组成的数组。 每个类型数组均表示全局方法的相应参数所必需的自定义修饰符。 如果某个特定参数没有必需的自定义修饰符，请指定 <see langword="null" />，而不要指定类型数组。 如果全局方法没有参数，或者所有参数都没有必需的自定义修饰符，请指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="optionalParameterTypeCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符。 如果某个特定参数没有可选的自定义修饰符，请指定 <see langword="null" />，而不要指定类型数组。 如果全局方法没有参数，或者所有参数都没有可选的自定义修饰符，请指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。 也就是说，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
- 或 - 
<see cref="T:System.Type" /> 数组中的一个元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此前已调用 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 方法。</exception>
      <returns>已定义的全局方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>使用指定的名称、属性、返回类型和参数类型定义一个全局方法。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。 <paramref name="attributes" /> 必须包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。 也就是说，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
- 或 - 
<paramref name="name" /> 的长度为零。 
- 或 - 
<see cref="T:System.Type" /> 数组中的一个元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 以前被调用过。</exception>
      <returns>已定义的全局方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>在可移植可执行 (PE) 文件的 .sdata 部分定义已初始化的数据字段。</summary>
      <param name="name">用于引用数据的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="data">数据的二进制大对象 (BLOB)。</param>
      <param name="attributes">字段的属性。 默认值为 <see langword="Static" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
<paramref name="data" /> 的大小小于等于零，或者大于等于 0x3f0000。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 或 <paramref name="data" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 以前被调用过。</exception>
      <returns>用于引用数据的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>使用指定的名称、定义方法的 DLL 的名称、方法的属性、方法的调用约定、方法的返回类型、方法的参数类型以及 <see langword="PInvoke" /> 标志定义一个 <see langword="PInvoke" /> 方法。</summary>
      <param name="name">
        <see langword="PInvoke" /> 方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="dllName">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="nativeCallConv">本地调用约定。</param>
      <param name="nativeCharSet">方法的本地字符集。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的，或者如果包含类型是接口。  
  
 - 或 -  
  
 这种方法是抽象的方法。  
  
 - 或 -  
  
 此方法之前已定义。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 或 <paramref name="dllName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">以前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建了该包含类型。</exception>
      <returns>已定义的 <see langword="PInvoke" /> 方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>使用指定的名称、定义方法的 DLL 的名称、方法的属性、方法的调用约定、方法的返回类型、方法的参数类型以及 <see langword="PInvoke" /> 标志定义一个 <see langword="PInvoke" /> 方法。</summary>
      <param name="name">
        <see langword="PInvoke" /> 方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="dllName">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</param>
      <param name="entryName">DLL 中入口点的名称。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="nativeCallConv">本地调用约定。</param>
      <param name="nativeCharSet">方法的本地字符集。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的，或者如果包含类型是接口，或者如果此方法是抽象的，或者如果此方法以前定义过。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 或 <paramref name="dllName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">以前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建了该包含类型。</exception>
      <returns>已定义的 <see langword="PInvoke" /> 方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
      <summary>在此模块中用指定的名称为私有类型构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径，其中包括命名空间。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>具有指定名称的私有类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
      <summary>在给定类型名称和类型特性的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">已定义类型的属性。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>用所有请求的特性创建的 <see langword="TypeBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>在给定类型名称、类型特性和已定义类型扩展的类型的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">与类型关联的属性。</param>
      <param name="parent">已定义类型扩展的类型。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>用所有请求的特性创建的 <see langword="TypeBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>在给定类型名称、特性、已定义类型扩展的类型和类型的总大小的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">已定义类型的属性。</param>
      <param name="parent">已定义类型扩展的类型。</param>
      <param name="typesize">此类型的总大小。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>
        <see langword="TypeBuilder" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>在给定类型名称、特性、已定义类型扩展的类型和类型的封装大小的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">已定义类型的属性。</param>
      <param name="parent">已定义类型扩展的类型。</param>
      <param name="packsize">此类型的封装大小。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>
        <see langword="TypeBuilder" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>在给定类型名称、特性、已定义类型扩展的类型，已定义类型的封装大小和已定义类型的总大小的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">已定义类型的属性。</param>
      <param name="parent">已定义类型扩展的类型。</param>
      <param name="packingSize">此类型的封装大小。</param>
      <param name="typesize">此类型的总大小。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>用所有请求的特性创建的 <see langword="TypeBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>在给定类型名称、特性、已定义类型扩展的类型和已定义类型实现的接口的情况下，构造 <see langword="TypeBuilder" />。</summary>
      <param name="name">类型的完整路径。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">与类型关联的特性。</param>
      <param name="parent">已定义类型扩展的类型。</param>
      <param name="interfaces">类型实现的接口列表。</param>
      <exception cref="T:System.ArgumentException">具有给定名称的类型存在于此模块的父程序集中。  
  
 - 或 -  
  
 在未嵌套的类型上设置嵌套类型属性。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>用所有请求的特性创建的 <see langword="TypeBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>在可移植可执行 (PE) 文件的 .sdata 部分定义未初始化的数据字段。</summary>
      <param name="name">用于引用数据的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="size">数据字段的大小。</param>
      <param name="attributes">字段的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
 <paramref name="size" /> 小于或等于零，或者大于或等于 0x003f0000。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 以前被调用过。</exception>
      <returns>用于引用数据的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
      <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
      <param name="obj">与此实例进行比较的对象，或为 <see langword="null" />。</param>
      <returns>如果 <see langword="true" /> 等于此实例的类型和值，则为 <paramref name="obj" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>返回数组类上的命名方法。</summary>
      <param name="arrayClass">数组类。</param>
      <param name="methodName">数组类上的方法的名称。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayClass" /> 不是数组。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayClass" /> 或 <paramref name="methodName" /> 为 <see langword="null" />。</exception>
      <returns>数组类上的命名方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回已应用于当前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 的所有自定义属性。</summary>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <returns>一个包含自定义属性的数组；如果没有任何属性，该数组将为空。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回已应用于当前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 且派生自指定特性类型的所有自定义特性。</summary>
      <param name="attributeType">从中派生特性的基类型。</param>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> 不是由运行时提供的 <see cref="T:System.Type" /> 对象。 例如，<paramref name="attributeType" /> 是一个 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象。</exception>
      <returns>一个数组，其中包含从 <paramref name="attributeType" /> 以任何级别派生的自定义特性；如果没有这样的特性，则该数组为空。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
      <summary>返回有关已应用于当前 <see cref="T:System.Reflection.Emit.ModuleBuilder" />（表示为 <see cref="T:System.Reflection.CustomAttributeData" /> 对象）的特性的信息。</summary>
      <returns>
        <see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，表示已应用到当前模块的特性的相关数据。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>返回在可移植可执行 (PE) 文件的 .sdata 区域中定义的、具有指定名称和绑定特性的模块级字段。</summary>
      <param name="name">字段名。</param>
      <param name="bindingAttr">用于控制搜索的 <see langword="BindingFlags" /> 位标志的组合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 参数为 <see langword="null" />。</exception>
      <returns>一个具有指定名称及绑定特性的字段；或者如果该字段不存在，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>返回在可移植可执行 (PE) 文件的 .sdata 区域中定义的、与指定绑定标志匹配的所有字段。</summary>
      <param name="bindingFlags">用于控制搜索的 <see langword="BindingFlags" /> 位标志的组合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 参数为 <see langword="null" />。</exception>
      <returns>与指定标志匹配的字段的数组；如果不存在这样的字段，则数组为空。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
      <summary>返回此实例的哈希代码。</summary>
      <returns>32 位有符号整数哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>返回已在模块级别上为当前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 定义并与指定的绑定标志匹配的所有方法。</summary>
      <param name="bindingFlags">用于控制搜索的 <see langword="BindingFlags" /> 位标志的组合。</param>
      <returns>一个数组，包含与 <paramref name="bindingFlags" /> 匹配的所有模块级方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
      <summary>获取一对值，这一对值指示某个模块中代码的性质和该模块的目标平台。</summary>
      <param name="peKind">当此方法返回时，为 <see cref="T:System.Reflection.PortableExecutableKinds" /> 值的组合，用于指示模块中代码的性质。</param>
      <param name="machine">当此方法返回时，为 <see cref="T:System.Reflection.ImageFileMachine" /> 值中的一个，用于指示模块的目标平台。</param>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
      <summary>获取模块中定义的命名类型。</summary>
      <param name="className">要获取的 <see cref="T:System.Type" /> 的名称。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="className" /> 的长度为零或大于 1023。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">请求的 <see cref="T:System.Type" /> 是非公共的，且调用方没有将非公共对象反射到当前程序集外部的 <see cref="T:System.Security.Permissions.ReflectionPermission" />。</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
      <exception cref="T:System.TypeLoadException">加载 <see cref="T:System.Type" /> 时遇到错误。</exception>
      <returns>如果已在此模块中定义了请求的类型，则为此类型；否则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
      <summary>获取模块中定义的命名类型，可以忽略类型名称的大小写。</summary>
      <param name="className">要获取的 <see cref="T:System.Type" /> 的名称。</param>
      <param name="ignoreCase">如果为 <see langword="true" />，则搜索不区分大小写。 如果为 <see langword="false" />，则搜索区分大小写。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="className" /> 的长度为零或大于 1023。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">请求的 <see cref="T:System.Type" /> 是非公共的，且调用方没有将非公共对象反射到当前程序集外部的 <see cref="T:System.Security.Permissions.ReflectionPermission" />。</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
      <returns>如果已在此模块中定义了请求的类型，则为此类型；否则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>获取模块中定义的命名类型，可以忽略类型名称的大小写。 如果未找到该类型，则可选择引发异常。</summary>
      <param name="className">要获取的 <see cref="T:System.Type" /> 的名称。</param>
      <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。</param>
      <param name="ignoreCase">如果为 <see langword="true" />，则搜索不区分大小写。 如果为 <see langword="false" />，则搜索区分大小写。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="className" /> 的长度为零或大于 1023。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="className" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Security.SecurityException">请求的 <see cref="T:System.Type" /> 是非公共的，且调用方没有将非公共对象反射到当前程序集外部的 <see cref="T:System.Security.Permissions.ReflectionPermission" />。</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
      <exception cref="T:System.TypeLoadException">
        <paramref name="throwOnError" /> 为 <see langword="true" />，未找到指定的类型。</exception>
      <returns>如果指定类型已在此模块中声明，则为该类型；否则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
      <summary>返回在此模块内定义的所有类。</summary>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">无法加载模块中的一个或多个类。</exception>
      <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      <returns>一个数组，包含在此实例反射的模块内定义的类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>返回一个值，该值指示是否已将指定的特性类型应用于此模块。</summary>
      <param name="attributeType">要测试的自定义属性的类型。</param>
      <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributeType" /> 不是由运行时提供的 <see cref="T:System.Type" /> 对象。 例如，<paramref name="attributeType" /> 是一个 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象。</exception>
      <returns>如果一个或多个 <paramref name="attributeType" /> 实例已应用于此模块，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.IsResource">
      <summary>获取一个值，该值指示此对象是否是资源。</summary>
      <returns>如果此对象是资源，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
      <summary>在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的字段。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块中的一个字段。</param>
      <param name="genericTypeArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</param>
      <param name="genericMethodArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的字段的令牌。  
  
- 或 - 
 <paramref name="metadataToken" /> 标识一个字段，该字段的父级 <see langword="TypeSpec" /> 具有一个包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数）的签名，并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个 <see cref="T:System.Reflection.FieldInfo" /> 对象，表示由指定元数据令牌标识的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
      <summary>在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的类型或成员。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块中的类型或成员。</param>
      <param name="genericTypeArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</param>
      <param name="genericMethodArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的类型或成员的令牌。  
  
- 或 - 
 <paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。  
  
- 或 - 
 <paramref name="metadataToken" /> 标识一个属性或事件。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个 <see cref="T:System.Reflection.MemberInfo" /> 对象，表示由指定的元数据令牌标识的类型或成员。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
      <summary>在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的方法或构造函数。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块中的方法或构造函数。</param>
      <param name="genericTypeArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</param>
      <param name="genericMethodArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的方法或构造函数的令牌。  
  
- 或 - 
 <paramref name="metadataToken" /> 是一个 <see langword="MethodSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个 <see cref="T:System.Reflection.MethodBase" /> 对象，表示由指定的元数据令牌标识的方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
      <summary>返回由元数据令牌标识的签名 Blob。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块中的一个签名。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效 <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、签名或 <see langword="FieldDef" /> 令牌。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个字节数组，表示签名 Blob。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
      <summary>返回由指定元数据令牌标识的字符串。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块的字符串堆中的一个字符串。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的字符串的令牌。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个 <see cref="T:System.String" />，包含来自元数据字符串堆的一个字符串值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
      <summary>在由指定的泛型类型参数定义的上下文中，返回由指定的元数据令牌标识的类型。</summary>
      <param name="metadataToken">一个元数据令牌，用于标识模块中的一个类型。</param>
      <param name="genericTypeArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下类型的泛型类型参数，在该类型中，令牌在范围内；如果该类型不是泛型类型，则为 <see langword="null" />。</param>
      <param name="genericMethodArguments">一个 <see cref="T:System.Type" /> 对象的数组，表示以下方法的泛型类型参数，在该方法中，令牌在范围内；如果该方法不是泛型方法，则为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataToken" /> 不是当前模块范围内的类型的令牌。  
  
- 或 - 
 <paramref name="metadataToken" /> 是一个 <see langword="TypeSpec" />，其签名包含元素类型 <see langword="var" />（泛型类型的类型参数）或 <see langword="mvar" />（泛型方法的类型参数），并且没有为 <paramref name="genericTypeArguments" /> 和（或）<paramref name="genericMethodArguments" /> 提供必要的泛型类型参数。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="metadataToken" /> 不是当前模块范围内的有效令牌。</exception>
      <returns>一个 <see cref="T:System.Type" /> 对象，表示由指定的元数据令牌标识的类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用表示自定义属性的指定二进制大对象 (BLOB) 向此模块应用该属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 BLOB。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器向此模块应用自定义属性。</summary>
      <param name="customBuilder">帮助器类的实例，指定要应用的自定义属性。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Assembly">
      <summary>获取定义此 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 实例的动态程序集。</summary>
      <returns>定义了当前动态模块的动态程序集。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
      <summary>获取表示此模块的完全限定名和路径的 <see langword="String" />。</summary>
      <returns>完全限定的模块名。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
      <summary>获取元数据流版本。</summary>
      <returns>表示元数据流版本的 32 位整数。 高序位的两个字节表示主版本号，低序位的两个字节表示次版本号。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
      <summary>获取一个标记，该标记用于标识元数据中的当前动态模块。</summary>
      <returns>一个整数标记，用于标识元数据中的当前模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
      <summary>获取可用于区分模块的两个版本的全局唯一标识符 (UUID)。</summary>
      <returns>可用于区分模块的两个版本的 <see cref="T:System.Guid" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.Name">
      <summary>一个字符串，指示这是内存中的模块。</summary>
      <returns>指示这是内存中的模块的文本。</returns>
    </member>
    <member name="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
      <summary>获取表示动态模块的名称的字符串。</summary>
      <returns>动态模块的名称。</returns>
    </member>
    <member name="T:System.Reflection.Emit.PropertyBuilder">
      <summary>定义类型的属性。</summary>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.AddOtherMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>添加与此属性关联的其他方法之一。</summary>
      <param name="mdBuilder">一个表示另一种方法的 <see langword="MethodBuilder" /> 对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetAccessors(System.Boolean)">
      <summary>返回此属性上的公共和非公共 <see langword="get" /> 和 <see langword="set" /> 访问器的数组。</summary>
      <param name="nonPublic">指示非公共方法是否应在 <see langword="MethodInfo" /> 数组中返回。 如果要包括非公共方法，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>
        <see langword="MethodInfo" /> 类型的数组，它包含匹配的公共或非公共访问器，或者如果在此属性上不存在匹配访问器，则为空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回此属性的所有自定义属性的数组。</summary>
      <param name="inherit">如果为 <see langword="true" />，则遍历此属性的继承链以查找自定义属性</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>一个包含所有自定义属性的数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回由 <see cref="T:System.Type" /> 标识的自定义属性数组。</summary>
      <param name="attributeType">由类型标识的自定义属性数组。</param>
      <param name="inherit">如果为 <see langword="true" />，则遍历此属性的继承链以查找自定义属性。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>在该反映成员上定义的自定义属性的数组，如果未在该成员上定义任何属性，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetGetMethod(System.Boolean)">
      <summary>返回该属性的公共和非公共 get 访问器。</summary>
      <param name="nonPublic">指示是否应返回非公共 get 访问器。 如果要包括非公共方法，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <returns>如果 <paramref name="nonPublic" /> 为 <see langword="true" />，则返回表示该属性的 get 访问器的 <see langword="MethodInfo" /> 对象。 如果 <paramref name="nonPublic" /> 为 <see langword="false" /> 且 get 访问器是非公共的，或者如果 <paramref name="nonPublic" /> 为 <see langword="true" /> 但不存在 get 访问器，则返回 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetIndexParameters">
      <summary>返回此属性的所有索引参数的数组。</summary>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>
        <see langword="ParameterInfo" /> 类型的数组，它包含索引的参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetSetMethod(System.Boolean)">
      <summary>返回此属性的 set 访问器。</summary>
      <param name="nonPublic">指示如果访问器为非公共，是否应将其返回。 如果要包括非公共方法，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <returns>此属性的 <see langword="Set" /> 方法或 <see langword="null" />，如下表所示。  
  
 <list type="table"><listheader><term> “值”</term><description> 条件</description></listheader><item><term> 表示此属性的 Set 方法的 <see cref="T:System.Reflection.MethodInfo" /> 对象。</term><description> set 访问器是公共的。  
  
 <paramref name="nonPublic" /> 为 true 且可返回非公共方法。</description></item><item><term> null</term><description><paramref name="nonPublic" /> 为 true，但属性为只读。  
  
 <paramref name="nonPublic" /> 为 false，且 set 访问器是非公共的。</description></item></list></returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Object[])">
      <summary>通过调用索引化属性的 getter 方法来获取该属性的值。</summary>
      <param name="obj">将返回其属性值的对象。</param>
      <param name="index">索引化属性的可选索引值。 对于非索引化属性，该值应为 <see langword="null" />。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>指定的索引化属性的值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.GetValue(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>获取属性的值，该属性具有指定的绑定、索引和 <see langword="CultureInfo" />。</summary>
      <param name="obj">将返回其属性值的对象。</param>
      <param name="invokeAttr">调用属性。 这必须是来自 <see langword="BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="Static" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。 必须指定合适的调用属性。 如果要调用静态成员，则必须设置 <see langword="BindingFlags" /> 的 <see langword="Static" /> 标志。</param>
      <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</param>
      <param name="index">索引化属性的可选索引值。 对于非索引化属性，该值应为 <see langword="null" />。</param>
      <param name="culture">表示要为其本地化资源的区域性的 <see langword="CultureInfo" /> 对象。 请注意，如果没有为此区域性本地化该资源，则在搜索匹配项的过程中将继续调用 <see langword="CultureInfo.Parent" /> 方法。 如果此值为 <see langword="null" />，则从 <see langword="CultureInfo.CurrentUICulture" /> 属性获得 <see langword="CultureInfo" />。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>
        <paramref name="obj" /> 的属性值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>指示是否在此属性上定义一个或多个 <paramref name="attributeType" /> 的实例。</summary>
      <param name="attributeType">将应用自定义属性的 <see langword="Type" /> 对象。</param>
      <param name="inherit">指定是否遍历属性的继承链以查找自定义属性。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>如果在此属性上定义一个或多个 <paramref name="attributeType" /> 实例，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
      <summary>设置该属性的默认值。</summary>
      <param name="defaultValue">此属性的默认值。</param>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
      <exception cref="T:System.ArgumentException">该属性不是受支持类型之一。  
  
- 或 - 
<paramref name="defaultValue" /> 类型与该属性类型不匹配。  
  
- 或 - 
该属性的类型为 <see cref="T:System.Object" /> 或其他引用类型，并且 <paramref name="defaultValue" /> 不是 <see langword="null" />，该值无法赋给引用类型。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">如果已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetGetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>设置获取属性值的方法。</summary>
      <param name="mdBuilder">
        <see langword="MethodBuilder" /> 对象，表示获取属性值的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetSetMethod(System.Reflection.Emit.MethodBuilder)">
      <summary>设置用于设置属性值的方法。</summary>
      <param name="mdBuilder">
        <see langword="MethodBuilder" /> 对象，表示设置属性值的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="mdBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">已对封闭类型调用了 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Object[])">
      <summary>用索引属性的可选索引值设置该属性的值。</summary>
      <param name="obj">将设置其属性值的对象。</param>
      <param name="value">此属性的新值。</param>
      <param name="index">索引化属性的可选索引值。 对于非索引化属性，该值应为 <see langword="null" />。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
    </member>
    <member name="M:System.Reflection.Emit.PropertyBuilder.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
      <summary>将给定对象的属性值设置为给定值。</summary>
      <param name="obj">将返回其属性值的对象。</param>
      <param name="value">此属性的新值。</param>
      <param name="invokeAttr">调用属性。 这必须是来自 <see langword="BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="Static" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。 必须指定合适的调用属性。 如果要调用静态成员，则必须设置 <see langword="BindingFlags" /> 的 <see langword="Static" /> 标志。</param>
      <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</param>
      <param name="index">索引化属性的可选索引值。 对于非索引化属性，该值应为 <see langword="null" />。</param>
      <param name="culture">表示要为其本地化资源的区域性的 <see langword="CultureInfo" /> 对象。 请注意，如果没有为此区域性本地化该资源，则在搜索匹配项的过程中将继续调用 <see langword="CultureInfo.Parent" /> 方法。 如果此值为 <see langword="null" />，则从 <see langword="CultureInfo.CurrentUICulture" /> 属性获得 <see langword="CultureInfo" />。</param>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>获取此属性 (Property) 的属性 (Attribute)。</summary>
      <returns>此属性 (Property) 的属性 (Attribute)。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanRead">
      <summary>获取一个值，该值指示此属性是否可读。</summary>
      <returns>如果此属性可读，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.CanWrite">
      <summary>获取一个值，该值指示此属性是否可写。</summary>
      <returns>如果此属性可写，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.DeclaringType">
      <summary>获取声明该成员的类。</summary>
      <returns>声明该成员的类的 <see langword="Type" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Module">
      <summary>获取在其中定义了特定类型的模块，该类型即为声明当前属性的类型。</summary>
      <returns>
        <see cref="T:System.Reflection.Module" />，在该模块中定义了声明当前属性的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.Name">
      <summary>获取此成员的名称。</summary>
      <returns>包含此成员名称的 <see cref="T:System.String" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.PropertyType">
      <summary>获取此属性的字段类型。</summary>
      <returns>此属性的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.PropertyBuilder.ReflectedType">
      <summary>获取用于获取 <see langword="MemberInfo" /> 的此实例的类对象。</summary>
      <returns>
        <see langword="Type" /> 对象，通过它获取了此 <see langword="MemberInfo" /> 对象。</returns>
    </member>
    <member name="T:System.Reflection.Emit.TypeBuilder">
      <summary>在运行时定义并创建类的新实例。</summary>
    </member>
    <member name="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
      <summary>表示未指定类型的总大小。</summary>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
      <summary>添加一个此类型实现的接口。</summary>
      <param name="interfaceType">此类型实现的接口。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="interfaceType" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateType">
      <summary>创建类的 <see cref="T:System.Type" /> 对象。 定义了类的字段和方法后，调用 <see langword="CreateType" /> 以加载其 <see langword="Type" /> 对象。</summary>
      <exception cref="T:System.InvalidOperationException">尚未创建封闭类型。  
  
 - 或 -  
  
 此类型是非抽象类型，且包含一个抽象方法。  
  
 - 或 -  
  
 此类型不是抽象类或接口，并且具有一个没有方法体的方法。</exception>
      <exception cref="T:System.ArgumentException">
        <see cref="T:System.Reflection.Emit.ILGenerator" /> 中的错误标签内容：你定义了一个不调用 <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" /> 的标签。</exception>
      <exception cref="T:System.NotSupportedException">此类型包含无效的 Microsoft 中间语言 (MSIL) 代码。  
  
 - 或 -  
  
 分支目标使用 1 个字节的偏移量指定，但目标离分支的距离大于 127 个字节。</exception>
      <exception cref="T:System.TypeLoadException">无法加载此类型。 例如，它包含具有调用约定 <see cref="F:System.Reflection.CallingConventions.HasThis" /> 的 <see langword="static" /> 方法。</exception>
      <returns>为此类返回新的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
      <summary>获取一个表示此类型的 <see cref="T:System.Reflection.TypeInfo" /> 对象。</summary>
      <returns>一个表示此类型的对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
      <summary>用给定的属性和签名，向类型中添加新的构造函数。</summary>
      <param name="attributes">构造函数的属性。</param>
      <param name="callingConvention">构造函数的调用约定。</param>
      <param name="parameterTypes">构造函数的参数类型。</param>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>定义构造函数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
      <summary>将新构造函数添加到该类型，其属性、签名和自定义修饰符已给定。</summary>
      <param name="attributes">构造函数的属性。</param>
      <param name="callingConvention">构造函数的调用约定。</param>
      <param name="parameterTypes">构造函数的参数类型。</param>
      <param name="requiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="optionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="requiredCustomModifiers" /> 或 <paramref name="optionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>定义构造函数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>定义无参数构造函数。 在此处定义的构造函数将只调用父类的无参数构造函数。</summary>
      <param name="attributes">
        <see langword="MethodAttributes" /> 对象，表示要应用到此构造函数的属性 。</param>
      <exception cref="T:System.NotSupportedException">此父类型（基类型）没有无参数构造函数。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>返回构造函数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
      <summary>将新事件添加到该类型，使用给定的名称、属性和事件类型。</summary>
      <param name="name">事件的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">事件的属性。</param>
      <param name="eventtype">事件的类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="eventtype" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>已定义的事件。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>将新字段添加到该类型，其名称、属性和字段类型已给定。</summary>
      <param name="fieldName">字段的名称。 <paramref name="fieldName" /> 不能包含嵌入的 null。</param>
      <param name="type">字段的类型</param>
      <param name="attributes">字段的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="fieldName" /> 的长度为零。  
  
- 或 - 
 <paramref name="type" /> 是 System.Void。  
  
- 或 - 
为此字段的父类指定了总大小。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>已定义的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
      <summary>将新字段添加到该类型，其名称、属性、字段类型和自定义修饰符已给定。</summary>
      <param name="fieldName">字段的名称。 <paramref name="fieldName" /> 不能包含嵌入的 null。</param>
      <param name="type">字段的类型</param>
      <param name="requiredCustomModifiers">一个类型数组，表示字段所必需的自定义修饰符，如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</param>
      <param name="optionalCustomModifiers">一个类型数组，表示字段可选的自定义修饰符，如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</param>
      <param name="attributes">字段的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="fieldName" /> 的长度为零。  
  
- 或 - 
 <paramref name="type" /> 是 System.Void。  
  
- 或 - 
为此字段的父类指定了总大小。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fieldName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>已定义的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
      <summary>定义当前类型的泛型类型，指定其数量和名称并返回一个可用于设置其约束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的数组。</summary>
      <param name="names">泛型类型参数的名称的数组。</param>
      <exception cref="T:System.InvalidOperationException">已为此类型定义了泛型类型参数。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="names" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="names" /> 的元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="names" /> 是一个空数组。</exception>
      <returns>
        <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 对象的一个数组，可用于定义当前类型的泛型类型参数的约束。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
      <summary>在可移植可执行 (PE) 文件的 .sdata 部分定义已初始化的数据字段。</summary>
      <param name="name">用于引用数据的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="data">数据 blob。</param>
      <param name="attributes">字段的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
数据的大小小于或等于零，或者大于或等于 0x3f0000。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 或 <paramref name="data" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 以前被调用过。</exception>
      <returns>用于引用数据的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
      <summary>向此类型添加新方法，使用指定的名称和方法属性。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
      <summary>将具有指定的名称、 方法属性和调用约定的新方法添加到此类型。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>使用指定的名称、方法属性、调用约定和方法签名向类型中添加新方法。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>表示新定义的方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>使用指定名称、方法属性、调用约定、方法签名和自定义修饰符向类型中添加新方法。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="returnTypeRequiredCustomModifiers">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="returnTypeOptionalCustomModifiers">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。  
  
- 或 - 
<paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>一个表示新添加方法的 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
      <summary>向此类型添加新方法，并指定方法的名称、 属性和签名。</summary>
      <param name="name">方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">方法的属性。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
此方法的父类型是一个接口，并且此方法不是虚方法（Visual Basic 中为 <see langword="Overridable" />）。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>已定义的方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>指定实现给定方法声明的给定方法体（可能使用其他名称）。</summary>
      <param name="methodInfoBody">要使用的方法体。 应当为 <see langword="MethodBuilder" /> 对象。</param>
      <param name="methodInfoDeclaration">要使用其声明的方法。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodInfoBody" /> 不属于此类。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="methodInfoBody" /> 或 <paramref name="methodInfoDeclaration" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
<paramref name="methodInfoBody" /> 的声明类型不是此 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 表示的类型。</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
      <summary>定义嵌套的类型，并给定其名称。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
      <summary>已知名称和属性，定义嵌套类型。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">此类型的属性。</param>
      <exception cref="T:System.ArgumentException">未指定嵌套属性。  
  
- 或 - 
此类型已密封。  
  
- 或 - 
此类型是一个数组。  
  
- 或 - 
此类型是一个接口，但嵌套类型不是一个接口。  
  
- 或 - 
<paramref name="name" /> 的长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
      <summary>定义嵌套类型，其名称、属性以及它所扩展的类型已给定。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">此类型的属性。</param>
      <param name="parent">此嵌套类型扩展的类型。</param>
      <exception cref="T:System.ArgumentException">未指定嵌套属性。  
  
- 或 - 
此类型已密封。  
  
- 或 - 
此类型是一个数组。  
  
- 或 - 
此类型是一个接口，但嵌套类型不是一个接口。  
  
- 或 - 
<paramref name="name" /> 的长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
      <summary>定义嵌套类型，其名称、属性、该类型的总大小以及它所扩展的类型已给定。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">此类型的属性。</param>
      <param name="parent">此嵌套类型扩展的类型。</param>
      <param name="typeSize">此类型的总大小。</param>
      <exception cref="T:System.ArgumentException">未指定嵌套属性。  
  
- 或 - 
此类型已密封。  
  
- 或 - 
此类型是一个数组。  
  
- 或 - 
此类型是一个接口，但嵌套类型不是一个接口。  
  
- 或 - 
<paramref name="name" /> 的长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
      <summary>定义嵌套类型，其名称、属性、它所扩展的类型以及封装大小已给定。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">此类型的属性。</param>
      <param name="parent">此嵌套类型扩展的类型。</param>
      <param name="packSize">此类型的封装大小。</param>
      <exception cref="T:System.ArgumentException">未指定嵌套属性。  
  
- 或 - 
此类型已密封。  
  
- 或 - 
此类型是一个数组。  
  
- 或 - 
此类型是一个接口，但嵌套类型不是一个接口。  
  
- 或 - 
<paramref name="name" /> 的长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
      <summary>定义嵌套类型，指定其名称、 属性、 大小和它所扩展的类型。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null 值。</param>
      <param name="attr">此类型的属性。</param>
      <param name="parent">此嵌套类型扩展的类型。</param>
      <param name="packSize">此类型的封装大小。</param>
      <param name="typeSize">此类型的总大小。</param>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
      <summary>定义嵌套类型，其名称、属性、它所扩展的类型以及它所实现的接口已给定。</summary>
      <param name="name">类型的短名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attr">此类型的属性。</param>
      <param name="parent">此嵌套类型扩展的类型。</param>
      <param name="interfaces">此嵌套类型实现的接口。</param>
      <exception cref="T:System.ArgumentException">未指定嵌套属性。  
  
- 或 - 
此类型已密封。  
  
- 或 - 
此类型是一个数组。  
  
- 或 - 
此类型是一个接口，但嵌套类型不是一个接口。  
  
- 或 - 
<paramref name="name" /> 的长度为零或大于 1023。  
  
- 或 - 
此操作将在当前程序集中创建一个具有重复 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 的类型。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="interfaces" /> 数组的一个元素是 <see langword="null" />。</exception>
      <returns>已定义的嵌套类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、方法的属性、方法的调用约定、 方法的返回类型、 方法的参数类型，以及 <see langword="PInvoke" /> 标志。</summary>
      <param name="name">
        <see langword="PInvoke" /> 方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="dllName">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="nativeCallConv">本地调用约定。</param>
      <param name="nativeCharSet">方法的本地字符集。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。  
  
- 或 - 
此父类型为一个接口。  
  
- 或 - 
这种方法是抽象的方法。  
  
- 或 - 
此方法之前已定义。  
  
- 或 - 
<paramref name="name" /> 或 <paramref name="dllName" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 或 <paramref name="dllName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <returns>已定义的 <see langword="PInvoke" /> 方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、入口点名称、 方法的属性、方法的调用约定、 方法的返回类型、 方法的参数类型，以及 <see langword="PInvoke" /> 标志。</summary>
      <param name="name">
        <see langword="PInvoke" /> 方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="dllName">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</param>
      <param name="entryName">DLL 中入口点的名称。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="nativeCallConv">本地调用约定。</param>
      <param name="nativeCharSet">方法的本地字符集。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。  
  
- 或 - 
此父类型为一个接口。  
  
- 或 - 
这种方法是抽象的方法。  
  
- 或 - 
此方法之前已定义。  
  
- 或 - 
<paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <returns>已定义的 <see langword="PInvoke" /> 方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
      <summary>定义 <see langword="PInvoke" /> 方法，指定方法的名称、定义方法所使用的 DLL 的名称、入口点名称、方法的属性、方法的调用约定、方法的返回类型、方法的参数类型、<see langword="PInvoke" /> 标志，以及参数和返回类型的自定义修饰符。</summary>
      <param name="name">
        <see langword="PInvoke" /> 方法的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="dllName">定义 <see langword="PInvoke" /> 方法所使用的 DLL 的名称。</param>
      <param name="entryName">DLL 中入口点的名称。</param>
      <param name="attributes">方法的属性。</param>
      <param name="callingConvention">方法的调用约定。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="returnTypeRequiredCustomModifiers">一个类型数组，表示该方法的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="returnTypeOptionalCustomModifiers">一个类型数组，表示该方法的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">方法参数的类型。</param>
      <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="nativeCallConv">本地调用约定。</param>
      <param name="nativeCharSet">方法的本地字符集。</param>
      <exception cref="T:System.ArgumentException">此方法不是静态的。  
  
- 或 - 
此父类型为一个接口。  
  
- 或 - 
这种方法是抽象的方法。  
  
- 或 - 
此方法之前已定义。  
  
- 或 - 
<paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的长度为零。  
  
- 或 - 
<paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小与 <paramref name="parameterTypes" /> 的大小不相等。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <returns>一个 <see cref="T:System.Reflection.Emit.MethodBuilder" />，表示所定义的 <see langword="PInvoke" /> 方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
      <summary>将新属性添加到具有给定名称、属性、调用约定和属性签名的类型。</summary>
      <param name="name">属性的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">属性的特性。</param>
      <param name="callingConvention">属性访问器的调用约定。</param>
      <param name="returnType">属性的返回类型。</param>
      <param name="parameterTypes">属性的参数类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>定义的属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>将新属性添加到具有给定名称、调用约定、属性签名和自定义修饰符的类型。</summary>
      <param name="name">属性的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">属性的特性。</param>
      <param name="callingConvention">属性访问器的调用约定。</param>
      <param name="returnType">属性的返回类型。</param>
      <param name="returnTypeRequiredCustomModifiers">一个类型数组，它表示属性的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="returnTypeOptionalCustomModifiers">一个类型数组，它表示属性的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">属性的参数类型。</param>
      <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>定义的属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
      <summary>将新属性添加到具有给定名称和属性签名的类型中。</summary>
      <param name="name">属性的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">属性的特性。</param>
      <param name="returnType">属性的返回类型。</param>
      <param name="parameterTypes">属性的参数类型。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>定义的属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
      <summary>将新属性添加到具有给定名称、属性签名和自定义修饰符的类型。</summary>
      <param name="name">属性的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="attributes">属性的特性。</param>
      <param name="returnType">属性的返回类型。</param>
      <param name="returnTypeRequiredCustomModifiers">一个类型数组，它表示属性的返回类型所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有所需的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="returnTypeOptionalCustomModifiers">一个类型数组，它表示属性的返回类型的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果返回类型没有可选的自定义修饰符，则指定 <see langword="null" />。</param>
      <param name="parameterTypes">属性的参数类型。</param>
      <param name="parameterTypeRequiredCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数所必需的自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有所需的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <param name="parameterTypeOptionalCustomModifiers">由类型数组组成的数组。 每个类型数组均表示相应参数的可选自定义修饰符，如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。 如果某个特定参数没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定类型数组。 如果所有参数都没有可选的自定义修饰符，则指定 <see langword="null" />，而不要指定由数组组成的数组。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />  
  
- 或 - 
<paramref name="parameterTypes" /> 数组的任何元素都是 <see langword="null" /></exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>定义的属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
      <summary>定义此类型的初始值设定项。</summary>
      <exception cref="T:System.InvalidOperationException">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建包含类型。</exception>
      <returns>返回类型初始值设定项。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
      <summary>在可移植可执行 (PE) 文件的 <see langword=".sdata" /> 部分中定义未初始化的数据字段。</summary>
      <param name="name">用于引用数据的名称。 <paramref name="name" /> 不能包含嵌入的 null。</param>
      <param name="size">数据字段的大小。</param>
      <param name="attributes">字段的属性。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 的长度为零。  
  
- 或 - 
 <paramref name="size" /> 小于或等于零，或者大于或等于 0x003f0000。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。</exception>
      <returns>用于引用数据的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
      <summary>返回与指定泛型类型定义的构造函数相对应的指定构造泛型类型的构造函数。</summary>
      <param name="type">已返回其构造函数的构造泛型类型。</param>
      <param name="constructor">基于 <paramref name="type" /> 的泛型类型定义的构造函数，该函数指定要返回 <paramref name="type" /> 的哪个构造函数</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> 不表示泛型类型。  
  
- 或 - 
 <paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
- 或 - 
<paramref name="constructor" /> 的声明类型不是一个泛型类型定义。  
  
- 或 - 
<paramref name="constructor" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</exception>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> 对象，它表示与 <paramref name="constructor" /> 对应的 <paramref name="type" /> 的构造函数，它指定属于 <paramref name="type" /> 的泛型类型定义的构造函数 。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
      <summary>按照指定，返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的公共和非公共构造函数。</summary>
      <param name="bindingAttr">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示为此类定义的指定构造函数。 如果未定义任何构造函数，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
      <summary>返回为此类型定义的所有自定义属性。</summary>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。 使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      <returns>返回一个对象数组，其中的对象表示此类型的所有自定义属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>返回当前类型的所有自定义属性，该属性可分配给指定类型。</summary>
      <param name="attributeType">要搜索的属性的类型。 仅返回可分配给此类型的属性。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。 使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">该类型必须是由基础运行时系统提供的类型。</exception>
      <returns>在当前类型上定义的自定义属性数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetElementType">
      <summary>调用此方法始终引发 <see cref="T:System.NotSupportedException" />。</summary>
      <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
      <returns>不支持此方法。 不返回任何值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
      <summary>返回具有指定名称的事件。</summary>
      <param name="name">要搜索的事件的名称。</param>
      <param name="bindingAttr">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>一个 <see cref="T:System.Reflection.EventInfo" /> 对象，表示这个指定名称的类型声明或继承的事件；如果没有匹配项，则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents">
      <summary>返回此类型声明或继承的公共事件。</summary>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回表示此类型声明或继承的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象数组。 如果没有任何公共事件，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
      <summary>返回此类型声明的公共和非公共事件。</summary>
      <param name="bindingAttr">用于限制搜索的 <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示此类型声明或继承的与指定的绑定标志匹配的事件。 如果没有匹配的事件，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>返回由给定名称指定的字段。</summary>
      <param name="name">要获取的字段的名称。</param>
      <param name="bindingAttr">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象，该对象表示由此类型声明或继承的具有指定名称和公共或非公共修饰符的字段。 如果没有匹配项，则返回 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
      <summary>返回指定的构造泛型类型的字段，该字段对应于泛型类型定义的指定字段。</summary>
      <param name="type">返回其字段的构造泛型类型。</param>
      <param name="field">
        <paramref name="type" /> 的泛型类型定义中的一个字段，用于指定要返回 <paramref name="type" /> 的哪一个字段。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> 不表示泛型类型。  
  
- 或 - 
 <paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
- 或 - 
<paramref name="field" /> 的声明类型不是一个泛型类型定义。  
  
- 或 - 
<paramref name="field" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</exception>
      <returns>
        <see cref="T:System.Reflection.FieldInfo" /> 对象，它表示与 <paramref name="field" /> 对应的 <paramref name="type" /> 的字段，用于指定属于 <paramref name="type" /> 的泛型类型定义的字段。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
      <summary>返回此类型声明的公共和非公共字段。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共字段。 按照指定，如果没有字段，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
      <summary>返回一个 <see cref="T:System.Type" /> 对象的数组，表示泛型类型的类型变量或泛型类型定义的类型参数。</summary>
      <returns>一个 <see cref="T:System.Type" /> 对象数组。 此数组的元素表示泛型类型的类型参数或泛型类型定义的类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
      <summary>返回一个 <see cref="T:System.Type" /> 对象，该对象表示可从中获取当前类型的泛型类型定义。</summary>
      <exception cref="T:System.InvalidOperationException">当前类型不为泛型。 也就是说，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 返回 <see langword="false" />。</exception>
      <returns>一个 <see cref="T:System.Type" /> 对象，该对象表示可从中获取当前类型的泛型类型定义。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
      <summary>返回由此类直接或间接实现的接口，该接口具有与给定接口名匹配的完全限定名。</summary>
      <param name="name">接口的名称。</param>
      <param name="ignoreCase">如果为 <see langword="true" />，则搜索不区分大小写。 如果为 <see langword="false" />，则搜索区分大小写。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Type" /> 对象，该对象表示实现的接口。 如果未找到名称匹配的接口，则返回 null。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
      <summary>返回请求的接口的接口映射。</summary>
      <param name="interfaceType">要为其检索映射的接口的 <see cref="T:System.Type" />。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回请求的接口映射。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
      <summary>返回在此类型及其基类上实现的所有接口的数组。</summary>
      <returns>返回 <see cref="T:System.Type" /> 对象的数组，表示已实现的接口。 如果未定义任何内容，则返回一个空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <summary>按照指定，返回此类型声明或继承的所有公共和非公共成员。</summary>
      <param name="name">成员名。</param>
      <param name="type">要返回的成员的类型。</param>
      <param name="bindingAttr">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示在此类型上定义的公共和非公共成员；否则，仅返回公共成员。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
      <summary>返回此类型声明或继承的公共和非公共成员。</summary>
      <param name="bindingAttr">这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>返回 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组，表示此类型声明或继承的公共和非公共成员。 如果没有匹配的成员，则返回空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>返回与指定泛型类型定义的方法相对应的指定构造泛型类型的方法。</summary>
      <param name="type">已返回其方法的构造泛型类型。</param>
      <param name="method">
        <paramref name="type" /> 的泛型类型定义的方法，该方法指定要返回 <paramref name="type" /> 的方法。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> 是一个非泛型方法定义的泛型方法。  
  
- 或 - 
 <paramref name="type" /> 不表示泛型类型。  
  
- 或 - 
 <paramref name="type" /> 的类型不是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
- 或 - 
<paramref name="method" /> 的声明类型不是一个泛型类型定义。  
  
- 或 - 
<paramref name="method" /> 的声明类型不是 <paramref name="type" /> 的泛型类型定义。</exception>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> 对象，它表示与 <paramref name="method" /> 对应的 <paramref name="type" /> 的方法，它指定属于 <paramref name="type" /> 的泛型类型定义的方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
      <summary>按照指定，返回此类型声明或继承的所有公共和非公共方法。</summary>
      <param name="bindingAttr">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志，类似于 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see cref="T:System.Reflection.MethodInfo" /> 对象数组，表示在该类型上定义的公共和非公共方法；否则，仅返回公共方法。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <summary>返回此类型声明的公共和非公共嵌套类型。</summary>
      <param name="name">包含要获取的嵌套类型的名称的 <see cref="T:System.String" />。</param>
      <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
- 或 - 
零，表示对公共方法执行区分大小写的搜索。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>表示符合指定要求的嵌套类型的 <see cref="T:System.Type" /> 对象（如果找到）；否则为 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
      <summary>返回此类型声明或继承的公共和非公共嵌套类型。</summary>
      <param name="bindingAttr">这必须是 <see cref="T:System.Reflection.BindingFlags" /> 的位标志，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等中的位标志。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>
        <see cref="T:System.Type" /> 对象数组，表示当前 <see cref="T:System.Type" /> 中嵌套的与指定的绑定约束匹配的所有类型。  
  
如果当前 <see cref="T:System.Type" /> 中未嵌套任何类型，或者如果没有一个嵌套类型与绑定约束匹配，则为类型 <see cref="T:System.Type" /> 的空数组。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
      <summary>按照指定，返回此类型声明或继承的所有公共和非公共属性。</summary>
      <param name="bindingAttr">此调用属性。 这必须是来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</param>
      <exception cref="T:System.NotSupportedException">不会为不完整类型实现此方法。</exception>
      <returns>如果使用 <paramref name="nonPublic" />，则返回 <see langword="PropertyInfo" /> 对象的数组，表示在此类型上定义的公共和非公共属性；否则，仅返回公共属性。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
      <summary>调用指定的成员。 在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</summary>
      <param name="name">要调用的成员的名称。 这可以是构造函数、方法、属性或字段。 必须指定合适的调用属性。 请注意，可以通过将一个空字符串作为成员的名称进行传递来调用一个类的默认成员。</param>
      <param name="invokeAttr">调用属性。 这必须是来自 <see langword="BindingFlags" /> 的位标志。</param>
      <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果活页夹为 <see langword="null" />，则使用默认活页夹。 请参阅 <see cref="T:System.Reflection.Binder" />。</param>
      <param name="target">对其调用指定成员的对象。 如果该成员为静态，则忽略此参数。</param>
      <param name="args">自变量列表。 这是一个对象的数组，该对象包含要调用的成员的参数的数量、顺序和类型。 如果不存在任何参数，则这应为 null。</param>
      <param name="modifiers">与 <paramref name="args" /> 长度相同的数组，其元素表示与要调用的成员的自变量关联的特性。 参数在元数据中具有与之相关联的属性。 它们由不同的互操作性服务使用。 有关更多详细信息，请参阅元数据规范。</param>
      <param name="culture">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。 如果这是 NULL，则使用当前线程的 <see langword="CultureInfo" />。 （注意，这对于某些转换是必要的，例如，将表示 1000 的 String 转换为 Double 值，因为不同区域性的 1000 表示形式不同。）</param>
      <param name="namedParameters">
        <paramref name="namedParameters" /> 数组中的每个参数对应 <paramref name="args" /> 数组中的元素来获取值。 如果 <paramref name="args" /> 的长度大于 <paramref name="namedParameters" /> 的长度，则剩余的自变量值将按顺序传递。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>返回被调用的成员的返回值。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
      <summary>获取一个值，该值指示是否可将指定的 <see cref="T:System.Type" /> 分配给此对象。</summary>
      <param name="c">要测试的对象。</param>
      <returns>如果 <paramref name="c" /> 参数和当前类型表示相同的类型，或当前类型位于 <paramref name="c" /> 的继承层次结构中，或当前类型是 <paramref name="c" /> 支持的接口，则为 <see langword="true" />。 如果上述条件均无效或 <paramref name="c" /> 为 <see langword="null" />；则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsCreated">
      <summary>返回一个值，该值指示是否已创建当前的动态类型。</summary>
      <returns>如果已调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
      <summary>确定是否将自定义属性应用于当前类型。</summary>
      <param name="attributeType">要搜索的属性的类型。 仅返回可分配给此类型的属性。</param>
      <param name="inherit">指定是否搜索此成员的继承链以查找属性。</param>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。 使用 <see cref="M:System.Type.GetType" /> 检索此类型，并对返回的 <see cref="T:System.Type" /> 调用 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</exception>
      <exception cref="T:System.ArgumentException">未定义<paramref name="attributeType" /> 。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
      <returns>如果针对此类型定义了 <paramref name="attributeType" /> 的一个或多个实例，或定义了从 <paramref name="attributeType" /> 派生的属性，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
      <summary>确定此类型是否派生自指定类型。</summary>
      <param name="c">要检查的 <see cref="T:System.Type" />。</param>
      <returns>只读。 如果此类型与类型 <paramref name="c" /> 相同或为类型 <paramref name="c" /> 的子类型，则返回 <see langword="true" />；否则返回 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
      <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</summary>
      <returns>
        <see cref="T:System.Type" /> 对象，该对象表示一维数组类型，其元素类型为当前类型（下限为零）。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
      <summary>返回 <see cref="T:System.Type" /> 对象，此对象表示当前类型的具有指定维数的数组。</summary>
      <param name="rank">数组的维数。</param>
      <exception cref="T:System.IndexOutOfRangeException">
        <paramref name="rank" /> 不是有效的数组维数。</exception>
      <returns>表示当前类型的一维数组的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
      <summary>返回一个 <see cref="T:System.Type" /> 对象，它在作为 <see langword="ref" /> 参数（Visual Basic 中的<see langword="ByRef" /> ）传递时表示当前类型。</summary>
      <returns>
        <see cref="T:System.Type" /> 对象，它在作为 <see langword="ref" /> 参数（Visual Basic 中的 <see langword="ByRef" />）传递时表示当前类型。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
      <summary>将类型数组中的元素替换为当前泛型类型定义的类型参数，并返回生成的构造类型。</summary>
      <param name="typeArguments">当前泛型类型定义的类型参数将要替代的类型数组。</param>
      <exception cref="T:System.InvalidOperationException">此当前类型不表示泛型类型的定义。 也就是说，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArguments" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArguments" /> 的任意元素的属性 <see cref="P:System.Type.Module" /> 的值为 <see langword="null" />。  
  
- 或 - 
<paramref name="typeArguments" /> 的任意元素的模块的属性 <see cref="P:System.Reflection.Module.Assembly" /> 的值为 <see langword="null" />。</exception>
      <returns>
        <see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
      <summary>返回表示指向当前类型的非托管指针的类型的 <see cref="T:System.Type" /> 对象。</summary>
      <returns>表示指向当前类型的非托管指针的类型的 <see cref="T:System.Type" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
      <summary>使用指定的自定义属性 blob 设置自定义属性。</summary>
      <param name="con">自定义属性的构造函数。</param>
      <param name="binaryAttribute">表示属性的字节 blob。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
      <summary>使用自定义属性生成器设置自定义属性。</summary>
      <param name="customBuilder">用于定义自定义属性的帮助程序类的一个实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="customBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
      <summary>设置当前正在构造的类型的基类型。</summary>
      <param name="parent">新的基类型。</param>
      <exception cref="T:System.InvalidOperationException">该类型是以前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 创建的。  
  
- 或 - 
 <paramref name="parent" /> 为 <see langword="null" />，并且当前实例表示其属性不包括 <see cref="F:System.Reflection.TypeAttributes.Abstract" /> 的接口。  
  
- 或 - 
对于当前的动态类型，属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 的值为 <see langword="true" />，但属性 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 的值为 <see langword="false" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 是一个接口。 此异常条件是 .NET Framework 2.0 版中新增的。</exception>
    </member>
    <member name="M:System.Reflection.Emit.TypeBuilder.ToString">
      <summary>返回不包括命名空间的类型的名称。</summary>
      <returns>只读。 不包括命名空间的类型的名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Assembly">
      <summary>检索包含此类型定义的动态程序集。</summary>
      <returns>只读。 检索包含此类型定义的动态程序集。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
      <summary>返回由程序集的显示名称限定的此类型的全名。</summary>
      <returns>只读。 由程序集的显示名称限定的此类型的全名。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.BaseType">
      <summary>检索此类型的基类型。</summary>
      <returns>只读。 检索此类型的基类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
      <summary>获取声明了当前泛型类型参数的方法。</summary>
      <returns>如果当前的类型是一个泛型类型参数，则为表示声明了当前类型的方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
      <summary>返回声明此类型的类型。</summary>
      <returns>只读。 声明此类型的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.FullName">
      <summary>检索此类型的完整路径。</summary>
      <returns>只读。 检索此类型的完整路径。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
      <summary>获取一个值，该值指示当前泛型类型参数的协变和特殊约束。</summary>
      <returns>
        <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
      <summary>获取声明参数的泛型类型的类型参数列表中的类型参数位置。</summary>
      <returns>如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示一个泛型类型参数，则为类型参数在声明它的泛型类型的类型参数列表中的位置；否则为未定义。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.GUID">
      <summary>检索此类型的 GUID。</summary>
      <exception cref="T:System.NotSupportedException">不完整类型目前不支持此方法。</exception>
      <returns>只读。 检索此类型的 GUID</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
      <summary>获取指示此对象是否表示构造的泛型类型的值。</summary>
      <returns>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
      <summary>获取一个值，该值指示当前类型是否是泛型类型参数。</summary>
      <returns>如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示泛型类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
      <summary>获取一个值，该值指示当前类型是否是泛型类型。</summary>
      <returns>如果当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示的类型是泛型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
      <summary>获取一个值，该值指示当前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</summary>
      <returns>如果此 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 对象表示泛型类型定义，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
      <summary>获取一个值，该值指示当前类型是安全-关键的还是安全-可靠-关键的，且因此是否可执行关键操作。</summary>
      <exception cref="T:System.NotSupportedException">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</exception>
      <returns>如果当前类型是安全-关键的或安全-可靠-关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
      <summary>获取一个值，该值指示当前类型是否为安全-可靠-关键，即它是否可执行关键操作且可由透明代码访问。</summary>
      <exception cref="T:System.NotSupportedException">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</exception>
      <returns>如果当前类型为安全-可靠-关键，则为 <see langword="true" />；如果它为安全-关键或透明，则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
      <summary>获取一个值，该值指示当前类型是否透明，且因此是否无法指定关键操作。</summary>
      <exception cref="T:System.NotSupportedException">当前动态类型不是通过调用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建的。</exception>
      <returns>如果此类型是安全-透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
    <member name="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
    <member name="P:System.Reflection.Emit.TypeBuilder.Module">
      <summary>检索包含此类型定义的动态模块。</summary>
      <returns>只读。 检索包含此类型定义的动态模块。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Name">
      <summary>检索此类型的名称。</summary>
      <returns>只读。 检索此类型的 <see cref="T:System.String" /> 名称。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Namespace">
      <summary>检索定义了此 <see langword="TypeBuilder" /> 的命名空间。</summary>
      <returns>只读。 检索定义了此 <see langword="TypeBuilder" /> 的命名空间。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.PackingSize">
      <summary>检索此类型的包装大小。</summary>
      <returns>只读。 检索此类型的包装大小。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
      <summary>返回用于获取此类型的类型。</summary>
      <returns>只读。 用于获取此类型的类型。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.Size">
      <summary>检索类型的总大小。</summary>
      <returns>只读。 检索此类型的总大小。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
      <summary>不支持动态模块。</summary>
      <exception cref="T:System.NotSupportedException">不支持动态模块。</exception>
      <returns>只读。</returns>
    </member>
    <member name="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
      <summary>返回此 <see langword="TypeBuilder" /> 的基础系统类型。</summary>
      <exception cref="T:System.InvalidOperationException">此类型是一个枚举，但没有任何基础系统类型。</exception>
      <returns>只读。 返回基础系统类型。</returns>
    </member>
  </members>
</doc>