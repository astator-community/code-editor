<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Reflection.Metadata</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AssemblyFlags" />
    <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
      <summary>与 <see cref="T:System.Reflection.AssemblyContentType" /> 的值相对应的内容类型掩码位。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
      <summary>已为程序集禁用实时 (JIT) 编译器优化。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
      <summary>已为程序集启用实时 (JIT) 编译器跟踪。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.PublicKey">
      <summary>程序集引用包含完整（未经过哈希处理）的公钥。 不适用于程序集定义。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.Retargetable">
      <summary>在运行时使用的引用程序集的实现不应与编译时所显示的版本匹配。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
      <summary>程序集包含 Windows 运行时代码。</summary>
    </member>
    <member name="T:System.Reflection.AssemblyHashAlgorithm">
      <summary>指定用于哈希程序集文件和用于生成强名称的哈希算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
      <summary>检索 MD5 消息摘要算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
      <summary>一个掩码，它指示无哈希算法。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
      <summary>检索安全哈希算法的修订，该修订更正了 SHA 中的一个未发布的错误。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
      <summary>检索安全哈希算法的版本，其哈希值大小为 256 位。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
      <summary>检索安全哈希算法的版本，其哈希值大小为 384 位。</summary>
    </member>
    <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
      <summary>检索安全哈希算法的版本，其哈希值大小为 512 位。</summary>
    </member>
    <member name="T:System.Reflection.DeclarativeSecurityAction">
      <summary>指定可以使用声明性安全执行的安全操作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
      <summary>即使堆栈中的高级调用方未被授限访问当前权限对象所标识的资源，调用代码仍能访问该资源。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
      <summary>检查调用链中的所有调用方是否已被授予指定的权限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
      <summary>如果不进行进一步检查，则拒绝对指定权限的需求。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
      <summary>要求继承此类或重写方法的派生的类已具有指定的权限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
      <summary>检查直接调用方是否已被授予指定的权限。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.None">
      <summary>无声明性安全操作。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
      <summary>如果不进行进一步检查，则拒绝对除指定权限之外的所有其他权限的需求。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
      <summary>请求代码运行所需的最低权限。 此操作仅可以在程序集的作用域内使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
      <summary>请求可选的其他权限（不要求运行）。 此请求隐式拒绝所有未明确请求的其他权限。 此操作仅可以在程序集的作用域内使用。</summary>
    </member>
    <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
      <summary>可能被误用的权限将不授予给调用代码的请求。 此操作仅可以在程序集的作用域内使用。</summary>
    </member>
    <member name="T:System.Reflection.ManifestResourceAttributes" />
    <member name="F:System.Reflection.ManifestResourceAttributes.Private">
      <summary>资源不是从程序集导出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.Public">
      <summary>资源从程序集导出。</summary>
    </member>
    <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
      <summary>仅屏蔽与可见性相关的属性。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ArrayShape">
      <summary>表示数组类型的形状。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ArrayShape.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.ArrayShape" /> 结构的新实例。</summary>
      <param name="rank">数组的维数。</param>
      <param name="sizes">每个维度的大小。</param>
      <param name="lowerBounds">每个维度的下限。</param>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.LowerBounds">
      <summary>获取所有维度的下限。 长度可能小于排名，这种情况下，尾部维度具有未指定的下限。</summary>
      <returns>一个较低边界的数组。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Rank">
      <summary>获取数组中的维度数。</summary>
      <returns>维度数。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ArrayShape.Sizes">
      <summary>获取所有维度的大小。</summary>
      <returns>大小的数组。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinition.GetDeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.PublicKey" />
    <member name="P:System.Reflection.Metadata.AssemblyDefinition.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.Equals(System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Equality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Implicit(System.Reflection.Metadata.AssemblyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyDefinitionHandle.op_Inequality(System.Reflection.Metadata.AssemblyDefinitionHandle,System.Reflection.Metadata.AssemblyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFile" />
    <member name="M:System.Reflection.Metadata.AssemblyFile.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
      <summary>获取用于指示该文件是否包含元数据的值。</summary>
      <returns>
        <see langword="true" /> 如果文件包含元数据，则 <see langword="false" /> 为; 否则为。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
      <summary>获取使用 <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" /> 计算的文件内容的哈希值。</summary>
      <returns>一个 <see cref="T:System.Reflection.Metadata.BlobHandle" /> 实例，表示文件内容的哈希值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
      <summary>获取文件名称，包括其扩展名。</summary>
      <returns>一个 <see cref="T:System.Reflection.Metadata.StringHandle" /> 实例，它表示具有扩展名的文件名。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.Equals(System.Reflection.Metadata.AssemblyFileHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Equality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyFileHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Implicit(System.Reflection.Metadata.AssemblyFileHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandle.op_Inequality(System.Reflection.Metadata.AssemblyFileHandle,System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> 的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyFileHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyFileHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReference" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetAssemblyName" />
    <member name="M:System.Reflection.Metadata.AssemblyReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Culture" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Flags" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.HashValue" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Name" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.PublicKeyOrToken" />
    <member name="P:System.Reflection.Metadata.AssemblyReference.Version" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandle" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.Equals(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Equality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.AssemblyReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Implicit(System.Reflection.Metadata.AssemblyReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandle.op_Inequality(System.Reflection.Metadata.AssemblyReferenceHandle,System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
      <summary>程序集引用的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#AssemblyReferenceHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.AssemblyReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Blob" />
    <member name="M:System.Reflection.Metadata.Blob.GetBytes" />
    <member name="P:System.Reflection.Metadata.Blob.IsDefault" />
    <member name="P:System.Reflection.Metadata.Blob.Length" />
    <member name="T:System.Reflection.Metadata.BlobBuilder" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.#ctor(System.Int32)">
      <param name="capacity" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Align(System.Int32)">
      <param name="alignment" />
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.AllocateChunk(System.Int32)">
      <param name="minimalSize" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Clear" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.ContentEquals(System.Reflection.Metadata.BlobBuilder)">
      <summary>将此编写器的当前内容与另一个编写器的内容进行比较。</summary>
      <param name="other">要与此实例进行比较的 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 实例。</param>
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
      <returns>如果相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Free" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.FreeChunk" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.GetBlobs">
      <summary>返回表示生成器内容的所有 blob 的序列。</summary>
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
      <returns>一个 blob 序列。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkPrefix(System.Reflection.Metadata.BlobBuilder)">
      <param name="prefix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="prefix" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.LinkSuffix(System.Reflection.Metadata.BlobBuilder)">
      <param name="suffix" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="suffix" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.PadTo(System.Int32)">
      <param name="position" />
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ReserveBytes(System.Int32)">
      <summary>保留连续的字节块。</summary>
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray">
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了缓冲区内容的范围。</exception>
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray">
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了缓冲区内容的范围。</exception>
      <exception cref="T:System.InvalidOperationException">内容不可用；此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.TryWriteBytes(System.IO.Stream,System.Int32)">
      <summary>尝试将一个字节序列写入生成器。 返回值显示已成功写入的字节数。</summary>
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
      <returns>从 <paramref name="source" /> 成功写入的字节数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBoolean(System.Boolean)">
      <summary>向生成器写入 <see cref="T:System.Boolean" /> 值。</summary>
      <param name="value">要写入的值。</param>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteByte(System.Byte)">
      <summary>向生成器写入 <see cref="T:System.Byte" /> 值。</summary>
      <param name="value">要写入的值。</param>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte*,System.Int32)">
      <summary>将指定的字节数从缓冲区写入生成器。</summary>
      <param name="buffer" />
      <param name="byteCount">要写入的字节数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte,System.Int32)">
      <summary>将指定的字节值出现次数写入生成器。</summary>
      <param name="value" />
      <param name="byteCount">要写入的 <paramref name="value" /> 的出现次数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[])">
      <summary>将字节数组的内容写入生成器。</summary>
      <param name="buffer">要写入的字节数组。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>将从字节数组中的指定索引处开始的指定字节数写入生成器。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">要写入的字节数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了 <paramref name="buffer" /> 的界限。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>将不可变字节数组的内容写入生成器。</summary>
      <param name="buffer">要写入的数组。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <summary>将从不可变数组的指定索引处开始的指定字节数写入生成器。</summary>
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount">要写入的字节数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了 <paramref name="buffer" /> 的范围。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedInteger(System.Int32)">
      <summary>实现 ECMA-335 第23.2 章： Blob 和签名定义的压缩无符号整数编码。</summary>
      <param name="value">要写入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示为压缩的无符号整数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteCompressedSignedInteger(System.Int32)">
      <summary>实现 ECMA-335-II 第23.2 章： Blob 和签名定义的压缩有符号整数编码。</summary>
      <param name="value">要写入的值。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示为压缩的带符号整数。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteConstant(System.Object)">
      <summary>在当前位置写入一个常量值（请参阅 ECMA-335 第 II 部分 22.9 小节）。</summary>
      <param name="value">要写入的常量值。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> 不是常量类型。</exception>
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.IO.Stream)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">内容不可用，此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobBuilder)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">内容不可用，此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteContentTo(System.Reflection.Metadata.BlobWriter@)">
      <param name="destination" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="destination" /> 是默认值 (<see cref="T:System.Reflection.Metadata.BlobWriter" />)。</exception>
      <exception cref="T:System.InvalidOperationException">内容不可用，此生成器已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDateTime(System.DateTime)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDecimal(System.Decimal)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteDouble(System.Double)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteGuid(System.Guid)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt16BE(System.Int16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt32BE(System.Int32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteInt64(System.Int64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteReference(System.Int32,System.Boolean)">
      <summary>写入对堆（堆偏移量）或表（行号）的引用。</summary>
      <param name="reference">堆偏移量或表的行号。</param>
      <param name="isSmall">如果为 <see langword="true" />，则将引用编码为 16 位整数；如果为 <see langword="false" />，则将其编码为 32 位整数。</param>
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSByte(System.SByte)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSerializedString(System.String)">
      <summary>以 SerString 格式写入字符串（请参阅 ECMA-335-II 23.3 自定义属性）。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteSingle(System.Single)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt16BE(System.UInt16)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt32BE(System.UInt32)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUInt64(System.UInt64)">
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUserString(System.String)">
      <summary>以用户字符串 (#US) 堆格式写入字符串（请参阅 ECMA-335-II 24.2.4 #US 和 #Blob 堆）。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.Char[])">
      <summary>在当前位置写入 UTF16 (little-endian) 编码的字符数组。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF16(System.String)">
      <summary>在当前位置写入 UTF16 (little-endian) 编码的字符串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.WriteUTF8(System.String,System.Boolean)">
      <summary>在当前位置写入 UTF8 (little-endian) 编码的字符串。</summary>
      <param name="value">常量值。</param>
      <param name="allowUnpairedSurrogates">如果为 <see langword="true" />，则按指定方式对不成对的代理进行编码；如果为 <see langword="false" />，则将它们替换为 U + FFFD 字符。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.ChunkCapacity" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.Count" />
    <member name="P:System.Reflection.Metadata.BlobBuilder.FreeBytes" />
    <member name="T:System.Reflection.Metadata.BlobBuilder.Blobs" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#Blob}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobBuilder.Blobs.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobBuilder.Blobs.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.BlobContentId" />
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Byte[])">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="id" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.#ctor(System.Guid,System.UInt32)">
      <param name="guid" />
      <param name="stamp" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.Equals(System.Reflection.Metadata.BlobContentId)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Byte[])">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.FromHash(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="hashCode" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Equality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobContentId.op_Inequality(System.Reflection.Metadata.BlobContentId,System.Reflection.Metadata.BlobContentId)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobContentId.Guid" />
    <member name="P:System.Reflection.Metadata.BlobContentId.IsDefault" />
    <member name="P:System.Reflection.Metadata.BlobContentId.Stamp" />
    <member name="T:System.Reflection.Metadata.BlobHandle" />
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.Equals(System.Reflection.Metadata.BlobHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Equality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Implicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobHandle.op_Inequality(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.BlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.BlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.BlobReader" />
    <member name="M:System.Reflection.Metadata.BlobReader.#ctor(System.Byte*,System.Int32)">
      <summary>创建指定内存块的读取器。</summary>
      <param name="buffer">指向内存块起始处的指针。</param>
      <param name="length">内存块的长度（以字节为单位）。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于 0。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 为负数。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台不是 little-endian。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Align(System.Byte)">
      <summary>按达到给定对齐状态所需的字节数向前重新定位读取器。</summary>
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.IndexOf(System.Byte)">
      <summary>在当前位置之后的 blob 中搜索指定的字节。</summary>
      <param name="value">要查找的字节值。</param>
      <returns>相对于当前位置的索引；或者，如果在当前位置之后的 blob 中没有找到字节，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBlobHandle">
      <summary>读取编码为压缩整数的 Blob 堆句柄。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBoolean" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
      <summary>读取从当前位置开始的字节。</summary>
      <param name="byteCount">要读取的字节数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 个字节不可用。</exception>
      <returns>字节数组。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32,System.Byte[],System.Int32)">
      <summary>读取从当前位置开始的字节，并将它们写入从指定偏移量开始的指定缓冲区。</summary>
      <param name="byteCount">要读取的字节数。</param>
      <param name="buffer">将向其中写入读取字节的目标缓冲区。</param>
      <param name="bufferOffset">将向其中写入读取字节的目标缓冲区中的偏移量。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 个字节不可用。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadChar" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
      <summary>读取无符号压缩整数值。 请参阅元数据规范第 II 部分。23.2： Blob 和签名。</summary>
      <exception cref="T:System.BadImageFormatException">当前位置的数据不是有效的压缩整数。</exception>
      <returns>读取的压缩整数的值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
      <summary>读取带符号的压缩整数值。 请参阅元数据规范第 II 部分。23.2： Blob 和签名。</summary>
      <exception cref="T:System.BadImageFormatException">当前位置的数据不是有效的压缩整数。</exception>
      <returns>读取的压缩整数的值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadConstant(System.Reflection.Metadata.ConstantTypeCode)">
      <summary>从当前位置读取一个常数值（请参阅 ECMA-335 第 II 部分 22.9 小节）。</summary>
      <param name="typeCode" />
      <exception cref="T:System.BadImageFormatException">从 blob 中读取时出错。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="typeCode" /> 不是有效的 <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />。</exception>
      <returns>装箱的常数值。 为了避免分配对象，直接使用 Read* 方法。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDateTime" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDecimal">
      <summary>读取一个 <see cref="T:System.Decimal" /> 数值。</summary>
      <exception cref="T:System.BadImageFormatException">当前位置的数据不是有效的 <see cref="T:System.Decimal" /> 数值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadDouble" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadGuid" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSByte" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
      <summary>读取以序列化自定义属性值形式编码的类型代码。</summary>
      <returns>如果编码无效，则 <see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
      <summary>读取编码为压缩整数的字符串，其中包含其长度并后跟其内容（UTF8 格式）。 Null 字符串会编码为一个 0xFF 字节。</summary>
      <exception cref="T:System.BadImageFormatException">编码无效。</exception>
      <returns>字符串值，或 <see langword="null" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureHeader" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
      <summary>读取以签名形式编码的类型代码。</summary>
      <returns>如果编码有效，则为以序列化自定义属性值形式编码的类型代码；如果编码无效，则 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadSingle" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
      <summary>读取以签名形式编码为 TypeDefOrRefOrSpecEncoded 的类型句柄（请参阅 ECMA-335 II.23.2.8）。</summary>
      <returns>编码有效时的句柄。 否则，为 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 属性为 <see langword="true" /> 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt16" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt32" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUInt64" />
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
      <summary>读取从当前位置开始的 UTF16 (little-endian) 编码的字符串。</summary>
      <param name="byteCount">要读取的字节数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 个字节不可用。</exception>
      <returns>字符串。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
      <summary>读取从当前位置开始的 UTF8 编码的字符串。</summary>
      <param name="byteCount">要读取的字节数。</param>
      <exception cref="T:System.BadImageFormatException">
        <paramref name="byteCount" /> 个字节不可用。</exception>
      <returns>字符串。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.Reset">
      <summary>将读取器重新定位到基础内存块的起始位置。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
      <summary>读取无符号压缩整数值。 请参阅元数据规范第 II 部分。23.2： Blob 和签名。</summary>
      <param name="value">读取的压缩整数的值。</param>
      <returns>如果成功读取值，则为 <see langword="true" />。 如果当前位置的数据不是有效的压缩整数，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
      <summary>读取带符号的压缩整数值。 请参阅元数据规范第 II 部分。23.2： Blob 和签名。</summary>
      <param name="value">读取的压缩整数的值。</param>
      <returns>如果成功读取值，则为 <see langword="true" />。 如果当前位置的数据不是有效的压缩整数，则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.CurrentPointer">
      <summary>获取指向读取器当前位置的字节的指针。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Length">
      <summary>获取基础内存块的总长度。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.Offset">
      <summary>获取或设置从 blob 的起始处到当前位置的偏移量。</summary>
      <exception cref="T:System.BadImageFormatException">偏移量会设置在基础读取器的边界之外。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.RemainingBytes">
      <summary>获取从当前位置到基础内存块末尾的剩余字节数。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.BlobReader.StartPointer">
      <summary>获取指向基础内存块起始处的字节的指针。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.BlobWriter" />
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[])">
      <param name="buffer" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="count" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Int32)">
      <param name="size" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.#ctor(System.Reflection.Metadata.Blob)">
      <param name="blob" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Align(System.Int32)">
      <param name="alignment" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.Clear" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ContentEquals(System.Reflection.Metadata.BlobWriter)">
      <summary>将此编写器的当前内容与另一个编写器的内容进行比较。</summary>
      <param name="other" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.PadTo(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了缓冲区内容的范围。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray" />
    <member name="M:System.Reflection.Metadata.BlobWriter.ToImmutableArray(System.Int32,System.Int32)">
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了缓冲区内容的范围。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBoolean(System.Boolean)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteByte(System.Byte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte*,System.Int32)">
      <param name="buffer" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte,System.Int32)">
      <param name="value" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[])">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了 <paramref name="buffer" /> 的范围。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="buffer" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32,System.Int32)">
      <param name="buffer" />
      <param name="start" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> 和 <paramref name="byteCount" /> 指定的范围超出了 <paramref name="buffer" /> 的范围。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.IO.Stream,System.Int32)">
      <param name="source" />
      <param name="byteCount" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="byteCount" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteBytes(System.Reflection.Metadata.BlobBuilder)">
      <param name="source" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedInteger(System.Int32)">
      <summary>实现 ECMA-335 第23.2 章： Blob 和签名定义的压缩无符号整数编码。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示为压缩的无符号整数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteCompressedSignedInteger(System.Int32)">
      <summary>实现 ECMA-335-II 第23.2 章： Blob 和签名定义的压缩有符号整数编码。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="value" /> 不能表示为压缩的带符号整数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteConstant(System.Object)">
      <summary>在当前位置写入一个常量值（请参阅 ECMA-335 第 II 部分 22.9 小节）。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> 不是常量类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDateTime(System.DateTime)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDecimal(System.Decimal)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteDouble(System.Double)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteGuid(System.Guid)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt16BE(System.Int16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt32BE(System.Int32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteInt64(System.Int64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteReference(System.Int32,System.Boolean)">
      <summary>写入对堆（堆偏移量）或表（行号）的引用。</summary>
      <param name="reference">堆偏移量或表的行号。</param>
      <param name="isSmall">如果为 <see langword="true" />，则将引用编码为 16 位整数；如果为 <see langword="false" />，则编码为 32 位整数。</param>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSByte(System.SByte)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSerializedString(System.String)">
      <summary>以 SerString 格式写入字符串（请参阅 ECMA-335-II 23.3 自定义属性）。</summary>
      <param name="str" />
      <exception cref="T:System.InvalidOperationException">此生成器不可写入；它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteSingle(System.Single)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt16BE(System.UInt16)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt32BE(System.UInt32)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUInt64(System.UInt64)">
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)">
      <summary>以用户字符串 (#US) 堆格式写入字符串（请参阅 ECMA-335-II 24.2.4 #US 和 #Blob 堆）。</summary>
      <param name="value" />
      <exception cref="T:System.InvalidOperationException">生成器不可写入，它已与另一个生成器链接。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.Char[])">
      <summary>在当前位置写入 UTF16 (little-endian) 编码的字符串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF16(System.String)">
      <summary>在当前位置写入 UTF16 (little-endian) 编码的字符串。</summary>
      <param name="value" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.BlobWriter.WriteUTF8(System.String,System.Boolean)">
      <summary>在当前位置写入 UTF8 (little-endian) 编码的字符串。</summary>
      <param name="value" />
      <param name="allowUnpairedSurrogates" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.BlobWriter.Blob" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Length" />
    <member name="P:System.Reflection.Metadata.BlobWriter.Offset" />
    <member name="P:System.Reflection.Metadata.BlobWriter.RemainingBytes" />
    <member name="T:System.Reflection.Metadata.Constant" />
    <member name="P:System.Reflection.Metadata.Constant.Parent">
      <summary>获取父句柄（<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />）。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.TypeCode">
      <summary>获取标识常数值类型的类型代码。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Constant.Value">
      <summary>获取常量值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ConstantHandle" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.Equals(System.Reflection.Metadata.ConstantHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Equality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Implicit(System.Reflection.Metadata.ConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ConstantHandle.op_Inequality(System.Reflection.Metadata.ConstantHandle,System.Reflection.Metadata.ConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ConstantTypeCode">
      <summary>指定值，用于表示元数据常数的类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Boolean">
      <summary>Boolean 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Byte">
      <summary>1 字节无符号整数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Char">
      <summary>一个字符类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Double">
      <summary>8 字节浮点类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int16">
      <summary>2 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int32">
      <summary>4 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Int64">
      <summary>8 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Invalid">
      <summary>无效类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.NullReference">
      <summary>空引用。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.SByte">
      <summary>1 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.Single">
      <summary>4 字节浮点类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt16">
      <summary>2 字节无符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt32">
      <summary>4 字节无符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.ConstantTypeCode.UInt64">
      <summary>8 字节无符号整数类型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttribute" />
    <member name="M:System.Reflection.Metadata.CustomAttribute.DecodeValue``1(System.Reflection.Metadata.ICustomAttributeTypeProvider{``0})">
      <summary>对以值 blob 形式编码的参数进行解码。</summary>
      <param name="provider" />
      <typeparam name="TType" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
      <summary>获取自定义属性类型的构造函数（<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />）。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
      <summary>获取应用了特性的元数据实体的句柄。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
      <summary>获取属性的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandle" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.Equals(System.Reflection.Metadata.CustomAttributeHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Equality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Implicit(System.Reflection.Metadata.CustomAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandle.op_Inequality(System.Reflection.Metadata.CustomAttributeHandle,System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomAttributeHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1">
      <summary>表示从自定义属性签名中解码的命名参数。</summary>
      <typeparam name="TType">用于表示从自定义特性签名解码的值类型的类型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeNamedArgument`1.#ctor(System.String,System.Reflection.Metadata.CustomAttributeNamedArgumentKind,`0,System.Object)">
      <summary>使用指定的名称、种类、类型和值初始化 <see cref="T:System.Reflection.Metadata.CustomAttributeNamedArgument`1" /> 结构的新实例。</summary>
      <param name="name">参数的名称。</param>
      <param name="kind">参数的种类。</param>
      <param name="type">自变量类型。</param>
      <param name="value">参数的值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Kind">
      <summary>获取参数的种类。</summary>
      <returns>参数类型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Name">
      <summary>获取参数的名称。</summary>
      <returns>自变量名称。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Type">
      <summary>获取参数的类型。</summary>
      <returns>参数类型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeNamedArgument`1.Value">
      <summary>获取参数的值。</summary>
      <returns>一个包含参数值的对象。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeNamedArgumentKind">
      <summary>指定常数，用于定义自定义属性签名中参数的种类。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Field">
      <summary>字段参数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.CustomAttributeNamedArgumentKind.Property">
      <summary>属性参数。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1">
      <summary>表示自定义元数据特性的类型化参数。</summary>
      <typeparam name="TType">自变量类型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeTypedArgument`1.#ctor(`0,System.Object)">
      <summary>使用指定的参数类型和值初始化 <see cref="T:System.Reflection.Metadata.CustomAttributeTypedArgument`1" /> 结构的新实例。</summary>
      <param name="type">自变量类型。</param>
      <param name="value">参数值。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Type">
      <summary>获取参数的类型。</summary>
      <returns>参数类型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeTypedArgument`1.Value">
      <summary>获取参数的值。</summary>
      <returns>参数值。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomAttributeValue`1">
      <summary>表示 <paramref name="TType" /> 指定的类型的自定义属性。</summary>
      <typeparam name="TType">属性类型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.CustomAttributeValue`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeTypedArgument{`0}},System.Collections.Immutable.ImmutableArray{System.Reflection.Metadata.CustomAttributeNamedArgument{`0}})">
      <summary>使用指定的固定参数和命名参数初始化 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> 结构的新实例。</summary>
      <param name="fixedArguments">固定参数。</param>
      <param name="namedArguments">命名参数。</param>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.FixedArguments">
      <summary>获取自定义属性的固定参数。</summary>
      <returns>不变的参数数组。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomAttributeValue`1.NamedArguments">
      <summary>获取自定义属性值的命名参数。</summary>
      <returns>不变的参数数组。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Kind" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Parent" />
    <member name="P:System.Reflection.Metadata.CustomDebugInformation.Value" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.Equals(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Equality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.CustomDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Implicit(System.Reflection.Metadata.CustomDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandle.op_Inequality(System.Reflection.Metadata.CustomDebugInformationHandle,System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#CustomDebugInformationHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.CustomDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DebugMetadataHeader" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.EntryPoint" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.Id" />
    <member name="P:System.Reflection.Metadata.DebugMetadataHeader.IdStartOffset">
      <summary>获取从元数据 blob 开头到 <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> blob 开头的偏移量（以字节为单位）。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttribute" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Action" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.Parent" />
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttribute.PermissionSet" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.Equals(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Equality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DeclarativeSecurityAttributeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Implicit(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.op_Inequality(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle,System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DeclarativeSecurityAttributeHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DeclarativeSecurityAttributeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Document">
      <summary>调试元数据中的源文档。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Hash">
      <summary>获取文档内容哈希。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.HashAlgorithm">
      <summary>获取用于计算 <see cref="P:System.Reflection.Metadata.Document.Hash" />（SHA1、SHA256 等）的哈希算法。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Language">
      <summary>获取源代码语言（C#、VB、F# 等）。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Document.Name">
      <summary>获取文档名称 blob。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandle" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.Equals(System.Reflection.Metadata.DocumentHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Equality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.DocumentHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Implicit(System.Reflection.Metadata.DocumentHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandle.op_Inequality(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.DocumentHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#DocumentHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.DocumentHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.DocumentNameBlobHandle">
      <summary>一个 <see cref="T:System.Reflection.Metadata.BlobHandle" />，表示可移植 PDB 中 #Blob 堆上的 blob，其结构为文档名称。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.Equals(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Equality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Explicit(System.Reflection.Metadata.BlobHandle)~System.Reflection.Metadata.DocumentNameBlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Implicit(System.Reflection.Metadata.DocumentNameBlobHandle)~System.Reflection.Metadata.BlobHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.DocumentNameBlobHandle.op_Inequality(System.Reflection.Metadata.DocumentNameBlobHandle,System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.DocumentNameBlobHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Shape(System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{System.Int32})">
      <summary>对数组形状进行编码。</summary>
      <param name="rank">数组中的维数（应大于等于 1）。</param>
      <param name="sizes">维度大小。 数组可能比 <paramref name="rank" /> 短，但不能比它长。</param>
      <param name="lowerBounds">维度下限；若将所有 <paramref name="rank" /> 下限都设为 0，则为 default(<see cref="T:System.Collections.Immutable.ImmutableArray`1" />)。
数组可能比 <paramref name="rank" /> 短，但不能比它长。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="rank" /> 超出范围 [1, 0xffff]，小于 <see langword="sizes.Length" /> 或小于 <see langword="lowerBounds.Length" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sizes" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ArrayShapeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.BlobEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Action{System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder},System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder})">
      <summary>对自定义特性签名 blob 进行编码。</summary>
      <param name="fixedArguments">已调用第一个，对固定参数进行编码。</param>
      <param name="namedArguments">已调用第二个，对固定参数进行编码。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fixedArguments" /> 或 <paramref name="namedArguments" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.CustomAttributeSignature(System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder@,System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder@)">
      <summary>对自定义特性签名 blob 进行编码。
返回一个编码器对，必须按它们在参数列表中出现的顺序来使用。</summary>
      <param name="fixedArguments">使用第一个，以对固定参数进行编码。</param>
      <param name="namedArguments">使用第二个，以对固定参数进行编码。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature">
      <summary>对字段签名 blob 进行编码。</summary>
      <returns>字段类型的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.LocalVariableSignature(System.Int32)">
      <summary>对局部变量签名进行编码。</summary>
      <param name="variableCount">局部变量的数量。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="variableCount" /> 不在范围 [0, 0x1fffffff] 内。</exception>
      <returns>一系列局部变量的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSignature(System.Reflection.Metadata.SignatureCallingConvention,System.Int32,System.Boolean)">
      <summary>对方法签名 blob 进行编码。</summary>
      <param name="convention">调用约定。</param>
      <param name="genericParameterCount">泛型形参的数量。</param>
      <param name="isInstanceMethod">若要对实例方法签名进行编码，则为 <see langword="true" />；若要对静态方法签名进行编码，则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> 不在范围 [0, 0xffff] 内。</exception>
      <returns>签名的其余部分（包括返回值和参数）的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.MethodSpecificationSignature(System.Int32)">
      <summary>对方法规范签名 blob 进行编码。</summary>
      <param name="genericArgumentCount">泛型实参的数量。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> 不在范围 [0, 0xffff] 内。</exception>
      <returns>泛型参数的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetArguments(System.Int32)">
      <summary>对权限集参数进行编码。</summary>
      <param name="argumentCount">集中的参数数量。</param>
      <returns>集的参数的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PermissionSetBlob(System.Int32)">
      <summary>对权限集 blob 进行编码。</summary>
      <param name="attributeCount">集中的特性数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="attributeCount" /> 不在范围 [0, 0x1fffffff] 内。</exception>
      <returns>权限集编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.PropertySignature(System.Boolean)">
      <summary>对属性签名 blob 进行编码。</summary>
      <param name="isInstanceProperty">若要对实例属性签名进行编码，则为 <see langword="true" />；若要对静态属性签名进行编码，则为 <see langword="false" />。</param>
      <returns>签名的其余部分（包括返回值和参数）的编码器，其结构与方法签名相同。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.BlobEncoder.TypeSpecificationSignature">
      <summary>对方法规范签名进行编码。</summary>
      <returns>类型规范表示的结构化类型的类型编码器（不得对基元类型编码）。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.BlobEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CodedIndex" />
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.CustomAttributeType(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 CustomAttributeType 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasConstant(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasConstant 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomAttribute(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasCustomAttribute 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasCustomDebugInformation 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 或<see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasDeclSecurity(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasDeclSecurity 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasFieldMarshal(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasFieldMarshal 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ParameterHandle" /> 或 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.HasSemantics(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 HasSemantics 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.Implementation(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算实现编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberForwarded(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 MemberForwarded 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.FieldDefinition" />，<see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MemberRefParent(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 MemberRefParent 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.MethodDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 MethodDefOrRef 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.ResolutionScope(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 ResolutionScope 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRef(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 TypeDefOrRef 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 TypeDefOrRefOrSpec 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)">
      <summary>为指定的句柄计算 TypeOrMethodDef 编码索引。</summary>
      <param name="handle">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
      <exception cref="T:System.ArgumentException">句柄类型不是预期类型。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.#ctor" />
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddCatchRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>添加 catch 区域。</summary>
      <param name="tryStart">标记 try 块的第一条指令的标签。</param>
      <param name="tryEnd">标记紧跟在 try 块后面的指令的标签。</param>
      <param name="handlerStart">标记处理程序的第一条指令的标签。</param>
      <param name="handlerEnd">标记紧跟在处理程序后面的指令的标签。</param>
      <param name="catchType">要捕获的异常的类型：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">标签不是由与此生成器关联的指令编码器定义的。

- 或 -

<paramref name="catchType" /> 不是有效的类型句柄。</exception>
      <exception cref="T:System.ArgumentNullException">标签具有默认值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFaultRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>添加 fault 区域。</summary>
      <param name="tryStart">标记 try 块的第一条指令的标签。</param>
      <param name="tryEnd">标记紧跟在 try 块后面的指令的标签。</param>
      <param name="handlerStart">标记处理程序的第一条指令的标签。</param>
      <param name="handlerEnd">标记紧跟在处理程序后面的指令的标签。</param>
      <exception cref="T:System.ArgumentException">标签不是由与此生成器关联的指令编码器定义的。</exception>
      <exception cref="T:System.ArgumentNullException">标签具有默认值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFilterRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>添加 catch 区域。</summary>
      <param name="tryStart">标记 try 块的第一条指令的标签。</param>
      <param name="tryEnd">标记紧跟在 try 块后面的指令的标签。</param>
      <param name="handlerStart">标记处理程序的第一条指令的标签。</param>
      <param name="handlerEnd">标记紧跟在处理程序后面的指令的标签。</param>
      <param name="filterStart">标记筛选器块的第一条指令的标签。</param>
      <exception cref="T:System.ArgumentException">标签不是由与此生成器关联的指令编码器定义的。</exception>
      <exception cref="T:System.ArgumentNullException">标签具有默认值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ControlFlowBuilder.AddFinallyRegion(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>添加 finally 区域。</summary>
      <param name="tryStart">标记 try 块的第一条指令的标签。</param>
      <param name="tryEnd">标记紧跟在 try 块后面的指令的标签。</param>
      <param name="handlerStart">标记处理程序的第一条指令的标签。</param>
      <param name="handlerEnd">标记紧跟在处理程序后面的指令的标签。</param>
      <exception cref="T:System.ArgumentException">标签不是由与此生成器关联的指令编码器定义的。</exception>
      <exception cref="T:System.ArgumentNullException">标签具有默认值。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ElementType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.ObjectArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Enum(System.String)">
      <param name="enumTypeName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveSerializationTypeCode)">
      <param name="type" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.SystemType" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.UInt64" />
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomAttributeNamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.AddModifier(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>对自定义修饰符进行编码。</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="isOptional">是可选修饰符。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> 为 <see langword="null" /> 或异常类型。</exception>
      <returns>后续修饰符的编码器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.CustomModifiersEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry" />
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.#ctor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="handle" />
      <param name="operation" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Equals(System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.GetHashCode" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Handle" />
    <member name="P:System.Reflection.Metadata.Ecma335.EditAndContinueLogEntry.Operation" />
    <member name="T:System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddEvent" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddField" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddParameter" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.AddProperty" />
    <member name="F:System.Reflection.Metadata.Ecma335.EditAndContinueOperation.Default" />
    <member name="T:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Add(System.Reflection.Metadata.ExceptionRegionKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>添加异常子句。</summary>
      <param name="kind">子句类型。</param>
      <param name="tryOffset">Try 块初始偏移量。</param>
      <param name="tryLength">Try 块长度。</param>
      <param name="handlerOffset">处理程序初始偏移量。</param>
      <param name="handlerLength">处理程序长度。</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />；如果 <paramref name="kind" /> 不是 <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />，则为 nil</param>
      <param name="filterOffset">筛选器块的偏移量；如果 <paramref name="kind" /> 不是 <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />，则为 0。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> 无效。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="kind" /> 具有无效值。
          
- 或 -

<paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" /> 或 <paramref name="handlerLength" /> 超出范围。</exception>
      <exception cref="T:System.InvalidOperationException">方法主体未声明为具有异常区域。</exception>
      <returns>下一子句的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddCatch(System.Int32,System.Int32,System.Int32,System.Int32,System.Reflection.Metadata.EntityHandle)">
      <summary>添加 fault 子句。</summary>
      <param name="tryOffset">Try 块初始偏移量。</param>
      <param name="tryLength">Try 块长度。</param>
      <param name="handlerOffset">处理程序初始偏移量。</param>
      <param name="handlerLength">处理程序长度。</param>
      <param name="catchType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="catchType" /> 无效。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" /> 或 <paramref name="handlerLength" /> 超出范围。</exception>
      <exception cref="T:System.InvalidOperationException">方法主体未声明为具有异常区域。</exception>
      <returns>下一子句的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFault(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>添加 fault 子句。</summary>
      <param name="tryOffset">Try 块初始偏移量。</param>
      <param name="tryLength">Try 块长度。</param>
      <param name="handlerOffset">处理程序初始偏移量。</param>
      <param name="handlerLength">处理程序长度。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" /> 或 <paramref name="handlerLength" /> 超出范围。</exception>
      <exception cref="T:System.InvalidOperationException">方法主体未声明为具有异常区域。</exception>
      <returns>下一子句的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFilter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>添加 fault 子句。</summary>
      <param name="tryOffset">Try 块初始偏移量。</param>
      <param name="tryLength">Try 块长度。</param>
      <param name="handlerOffset">处理程序初始偏移量。</param>
      <param name="handlerLength">处理程序长度。</param>
      <param name="filterOffset">筛选器块的偏移量。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" /> 或 <paramref name="handlerLength" /> 超出范围。</exception>
      <exception cref="T:System.InvalidOperationException">方法主体未声明为具有异常区域。</exception>
      <returns>下一子句的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.AddFinally(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>添加 finally 子句。</summary>
      <param name="tryOffset">Try 块初始偏移量。</param>
      <param name="tryLength">Try 块长度。</param>
      <param name="handlerOffset">处理程序初始偏移量。</param>
      <param name="handlerLength">处理程序长度。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tryOffset" />、<paramref name="tryLength" />、<paramref name="handlerOffset" /> 或 <paramref name="handlerLength" /> 超出范围。</exception>
      <exception cref="T:System.InvalidOperationException">方法主体未声明为具有异常区域。</exception>
      <returns>下一子句的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallExceptionRegion(System.Int32,System.Int32)">
      <summary>如果区域适合小格式，则返回 <see langword="true" />。</summary>
      <param name="startOffset">区域的起始偏移量。</param>
      <param name="length">区域的长度。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.IsSmallRegionCount(System.Int32)">
      <summary>如果异常区域的数目是第一小格式，则返回 <see langword="true" />。</summary>
      <param name="exceptionRegionCount">异常区域的数目。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.Builder">
      <summary>基础生成器。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ExceptionRegionEncoder.HasSmallFormat">
      <summary>如果编码器使用小格式，则为 <see langword="true" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
      <summary>提供一个扩展方法，用于访问 ExportedType 表的 TypeDefinitionId 列。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
      <summary>获取关于其模块的 TypeDef 表中目标类型的可能行数的提示。
如果命名空间和名称不匹配，则解析会回退到目标 TypeDef 表的完全搜索。 如果 <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> 为 <see langword="true" />，则被忽略且应为零。</summary>
      <param name="exportedType" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.FixedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasExplicitThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.HasThis" />
    <member name="F:System.Reflection.Metadata.Ecma335.FunctionPointerAttributes.None" />
    <member name="T:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.AddArgument" />
    <member name="P:System.Reflection.Metadata.Ecma335.GenericTypeArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.HeapIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Blob" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.Guid" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.String" />
    <member name="F:System.Reflection.Metadata.Ecma335.HeapIndex.UserString" />
    <member name="T:System.Reflection.Metadata.Ecma335.InstructionEncoder">
      <summary>对指令进行编码。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.Ecma335.ControlFlowBuilder)">
      <summary>创建由代码和控制流生成器支持的编码器。</summary>
      <param name="codeBuilder">要将已编码的指令写入到的生成器。</param>
      <param name="controlFlowBuilder">生成器跟踪标签、分支和异常处理程序。
必须指定才能使用 <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" /> 的一些控制流工厂方法，例如 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />、<see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" /> 和 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /></param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>对分支指令进行编码。</summary>
      <param name="code">要编码的分支指令。</param>
      <param name="label">指令流中目标位置的标签。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="code" /> 不是分支指令。

- 或 - 
此编码器未定义 <paramref name="label" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> 具有默认值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.EntityHandle)">
      <summary>编码 <c>call</c> 指令及其操作数。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>编码 <c>call</c> 指令及其操作数。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>编码 <c>call</c> 指令及其操作数。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Call(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>编码 <c>call</c> 指令及其操作数。</summary>
      <param name="methodHandle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.CallIndirect(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>编码 <c>calli</c> 指令及其操作数。</summary>
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel">
      <summary>定义一个标签，稍后可用它来标记和引用指令流中的位置。</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> 为 <see langword="null" />。</exception>
      <returns>标签句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgument(System.Int32)">
      <summary>对参数加载指令进行编码。</summary>
      <param name="argumentIndex">参数的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadArgumentAddress(System.Int32)">
      <summary>对参数地址加载指令进行编码。</summary>
      <param name="argumentIndex">参数的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI4(System.Int32)">
      <summary>对 <see cref="T:System.Int32" /> 常量加载指令进行编码。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantI8(System.Int64)">
      <summary>对 <see cref="T:System.Int64" /> 常量加载指令进行编码。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR4(System.Single)">
      <summary>对 <see cref="T:System.Single" /> 常量加载指令进行编码。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadConstantR8(System.Double)">
      <summary>对 <see cref="T:System.Double" /> 常量加载指令进行编码。</summary>
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocal(System.Int32)">
      <summary>对局部变量加载指令进行编码。</summary>
      <param name="slotIndex">局部变量槽的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadLocalAddress(System.Int32)">
      <summary>对局部变量地址加载指令进行编码。</summary>
      <param name="slotIndex">局部变量槽的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)">
      <summary>编码 <c>ldstr</c> 指令及其操作数。</summary>
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>将指定的标签与当前 IL 偏移量关联。</summary>
      <param name="label">要标记的标签。</param>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">此编码器未定义 <paramref name="label" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="label" /> 具有默认值。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.OpCode(System.Reflection.Metadata.ILOpCode)">
      <summary>对指定的操作代码进行编码。</summary>
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreArgument(System.Int32)">
      <summary>对参数存储指令进行编码。</summary>
      <param name="argumentIndex">参数的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="argumentIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.StoreLocal(System.Int32)">
      <summary>对局部变量存储指令进行编码。</summary>
      <param name="slotIndex">局部变量槽的索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="slotIndex" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Int32)">
      <summary>将令牌进行编码。</summary>
      <param name="token" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Token(System.Reflection.Metadata.EntityHandle)">
      <summary>将令牌进行编码。</summary>
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.CodeBuilder">
      <summary>已编码的指令写入到的基础生成器。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder">
      <summary>生成器跟踪标签、分支和异常处理程序。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.Offset">
      <summary>下一个已编码的指令的偏移量。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.LabelHandle" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.Equals(System.Reflection.Metadata.Ecma335.LabelHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Equality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LabelHandle.op_Inequality(System.Reflection.Metadata.Ecma335.LabelHandle,System.Reflection.Metadata.Ecma335.LabelHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.Id">
      <summary>从 1 开始的 ID，用于识别 <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" /> 上下文内的标签。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LabelHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralEncoder">
      <summary>提供用于对文本进行编码的方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder">使用指定的 blob 生成器创建 <see cref="T:System.Reflection.Metadata.Ecma335.LiteralEncoder" /> 类的新实例。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Scalar">
      <summary>返回用于对文本值进行编码的编码器。</summary>
      <returns>文本值的编码器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ScalarEncoder})">
      <summary>使用指定的委托对文本的类型和值进行编码。</summary>
      <param name="type">用于对文本类型进行编码的委托。 通过此方法进行第一次调用。</param>
      <param name="scalar">用于对文本值进行编码的委托。 通过此方法进行第二次调用。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> 或 <paramref name="scalar" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedScalar(System.Reflection.Metadata.Ecma335.CustomAttributeElementTypeEncoder@,System.Reflection.Metadata.Ecma335.ScalarEncoder@)">
      <summary>返回一对编码器，必须使用它们按文本在参数列表中出现的顺序来对其类型和值进行编码。</summary>
      <param name="type">此方法返回时，为一个自定义特性元素类型编码器，用于对文本类型进行编码。</param>
      <param name="scalar">此方法返回时，为一个标量编码，用于对文本值进行编码。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Action{System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.VectorEncoder})">
      <summary>使用指定的委托对矢量文本的类型和项进行编码。</summary>
      <param name="arrayType">用于对矢量类型进行编码的委托。 通过此方法进行第一次调用。</param>
      <param name="vector">用于对矢量项进行编码的委托。 通过此方法进行第二次调用。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="arrayType" /> 或 <paramref name="vector" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.TaggedVector(System.Reflection.Metadata.Ecma335.CustomAttributeArrayTypeEncoder@,System.Reflection.Metadata.Ecma335.VectorEncoder@)">
      <summary>返回一对编码器，必须使用它们按矢量文本在参数列表中出现的顺序来对其类型和项进行编码。</summary>
      <param name="arrayType">此方法返回时，为一个自定义特性数组类型编码器，用于对文本类型进行编码。</param>
      <param name="vector">此方法返回时，为一个矢量编码器，用于对矢量项进行编码。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralEncoder.Vector">
      <summary>获取用于对矢量项进行编码的矢量编码器。</summary>
      <returns>用于对矢量项进行编码的矢量编码器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LiteralsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LiteralsEncoder.AddLiteral" />
    <member name="P:System.Reflection.Metadata.Ecma335.LiteralsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.AddVariable" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariablesEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Type(System.Boolean,System.Boolean)">
      <param name="isByRef" />
      <param name="isPinned" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.LocalVariableTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataAggregator" />
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseTableRowCounts" />
      <param name="baseHeapSizes" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.#ctor(System.Reflection.Metadata.MetadataReader,System.Collections.Generic.IReadOnlyList{System.Reflection.Metadata.MetadataReader})">
      <param name="baseReader" />
      <param name="deltaReaders" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)">
      <summary>给定聚合元数据中实体的句柄，计算在其中定义实体的元数据生成中实体的句柄。</summary>
      <param name="handle">聚合元数据中实体的句柄。</param>
      <param name="generation">在其中定义实体的生成。</param>
      <returns>元数据 <paramref name="generation" /> 中实体的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataBuilder">
      <summary>MetadataBuilder 类以高性能的方式读取和写入程序集的元数据。 它专用于编译器和其他程序集生成工具。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>创建元数据表和堆的生成器。</summary>
      <param name="userStringHeapStartOffset">用户字符串堆的起始偏移量。 所有以前的 EnC 生成的用户字符串堆的累计大小应为 0，除非元数据为 EnC 增量元数据。</param>
      <param name="stringHeapStartOffset">字符串堆的起始偏移量。 所有以前的 EnC 生成的字符串堆的累计大小应为 0，除非元数据为 EnC 增量元数据。</param>
      <param name="blobHeapStartOffset">Blob 堆的起始偏移量。 所有以前的 EnC 生成的 Blob 堆的累计大小应为 0，除非元数据为 EnC 增量元数据。</param>
      <param name="guidHeapStartOffset">Guid 堆的起始偏移量。 所有以前的 EnC 生成的 Guid 堆的累计大小应为 0，除非元数据为 EnC 增量元数据。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">偏移量太大。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">偏移量为负。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="guidHeapStartOffset" /> 不是 GUID 大小的倍数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKey" />
      <param name="flags" />
      <param name="hashAlgorithm" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)">
      <param name="name" />
      <param name="hashValue" />
      <param name="containsMetadata" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)">
      <param name="name" />
      <param name="version" />
      <param name="culture" />
      <param name="publicKeyOrToken" />
      <param name="flags" />
      <param name="hashValue" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)">
      <summary>添加参数、字段或属性的默认值。</summary>
      <param name="parent">父级实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="value">常量值。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的常量的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加自定义属性。</summary>
      <param name="parent">一个实体，用于将自定义属性附加到以下项：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />。</param>
      <param name="constructor">自定义属性构造函数：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="value">自定义属性值 blob。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的自定义属性的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加自定义调试信息。</summary>
      <param name="parent">一个实体，用于将调试信息附加到以下项：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ParameterHandle" />、<see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />、<see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />、<see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />、<see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterHandle" />、<see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />、<see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.DocumentHandle" />、<see cref="T:System.Reflection.Metadata.LocalScopeHandle" />、<see cref="T:System.Reflection.Metadata.LocalVariableHandle" />、<see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> 或 <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />。</param>
      <param name="kind">信息种类。 确定 <paramref name="value" /> blob 的结构。</param>
      <param name="value">自定义调试信息 blob。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的自定义调试信息的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)">
      <summary>将声明性安全属性添加到类型、方法或程序集。</summary>
      <param name="parent">父级实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />。</param>
      <param name="action">声明性安全操作。</param>
      <param name="permissionSet">权限集 blob。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的声明性安全属性的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)">
      <summary>添加文档调试信息。</summary>
      <param name="name">文档名称 blob。</param>
      <param name="hashAlgorithm">哈希算法的 GUID，用于计算 <paramref name="hash" /> 的值。</param>
      <param name="hash">文档内容的哈希。</param>
      <param name="language">语言的 GUID。</param>
      <returns>已添加的文档的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)">
      <param name="entity" />
      <param name="code" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)">
      <param name="entity" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>添加事件定义。</summary>
      <param name="attributes">事件属性。</param>
      <param name="name">事件名称。</param>
      <param name="type">事件类型：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的事件定义的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="declaringType" />
      <param name="eventList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)">
      <summary>添加导出类型。</summary>
      <param name="attributes">类型属性。</param>
      <param name="namespace">类型命名空间。</param>
      <param name="name">类型名称。</param>
      <param name="implementation">实现实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> 或 <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />。</param>
      <param name="typeDefinitionId">类型定义 ID。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的导出类型的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加字段定义。</summary>
      <param name="attributes">字段属性。</param>
      <param name="name">字段名。</param>
      <param name="signature">字段签名。 使用 <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> 构造 blob。</param>
      <returns>已添加的字段定义的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>定义字段定义的字段布局。</summary>
      <param name="field">字段定义句柄。</param>
      <param name="offset">声明类型实例中的字段的字节偏移量。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)">
      <summary>将字段中的映射添加到存储在 PE 映像中的初始值。</summary>
      <param name="field">字段定义句柄。</param>
      <param name="offset">PE 映像的块中的偏移量，用于存储映射字段的初始值（通常位于 .text 部分中）。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>添加泛型参数定义。</summary>
      <param name="parent">父级实体句柄，可以是 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />。</param>
      <param name="attributes">泛型参数属性。</param>
      <param name="name">参数名称。</param>
      <param name="index">从零开始的参数索引。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 大于 <see cref="F:System.UInt16.MaxValue" />。</exception>
      <returns>已添加的泛型参数的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>向泛型参数添加类型约束。</summary>
      <param name="genericParameter">要约束的泛型参数。</param>
      <param name="constraint">类型约束，可以是以下项之一：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericParameter" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的泛型参数约束的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加局部作用域调试信息。</summary>
      <param name="parentScope">父级作用域句柄。</param>
      <param name="imports">导入作用域句柄。</param>
      <returns>已添加的导入作用域的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>将接口实现添加到类型。</summary>
      <param name="type">实现接口的类型。</param>
      <param name="implementedInterface">要实现的接口，可以是以下项之一：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementedInterface" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的接口实现的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加局部常量调试信息。</summary>
      <param name="name">变量名。</param>
      <param name="signature">LocalConstantSig blob。</param>
      <returns>已添加的局部常量的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)">
      <summary>添加局部作用域调试信息。</summary>
      <param name="method">包含的方法。</param>
      <param name="importScope">关联的导入作用域的句柄。</param>
      <param name="variableList">如果作用域声明变量，请将其设置为第一个变量的句柄。 否则，请将其设置为下一个作用域定义所声明的第一个变量的句柄。 如果任何作用域都未定义任何变量，则设置为 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />。</param>
      <param name="constantList">如果作用域声明常量，则将其设置为第一个常量的句柄。 否则，请将其设置为下一个作用域定义所声明的第一个常量的句柄。 如果任何作用域都未定义任何常量，则设置为 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />。</param>
      <param name="startOffset">作用域所涵盖的第一个指令的偏移量。</param>
      <param name="length">作用域的长度（以字节为单位）。</param>
      <returns>已添加的局部作用域的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)">
      <summary>添加局部变量调试信息。</summary>
      <param name="attributes">局部变量属性。</param>
      <param name="index">本地签名中局部变量的从零开始的索引。</param>
      <param name="name">变量名。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 大于 <see cref="F:System.UInt16.MaxValue" />。</exception>
      <returns>已添加的局部变量的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)">
      <summary>添加清单资源。</summary>
      <param name="attributes">清单资源属性。</param>
      <param name="name">清单资源的名称。</param>
      <param name="implementation">实现实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="offset">指定此资源记录开始处的引用文件内的字节偏移量。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="implementation" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的清单资源的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>向字段或参数添加封送信息。</summary>
      <param name="parent">父级实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.ParameterHandle" /> 或 <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />。</param>
      <param name="descriptor">描述符 blob。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加 MemberRef 表行。</summary>
      <param name="parent">包含的实体，可以是以下项之一：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />。</param>
      <param name="name">成员名称。</param>
      <param name="signature">成员签名。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="parent" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的成员引用的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加方法调试信息。</summary>
      <param name="document">如果方法具有序列点或跨越多个文档，则为单个文档的句柄，其中包含方法的所有序列点；否则为 <see langword="null" />。</param>
      <param name="sequencePoints">如果方法具有序列点，则为序列点 blob；否则为 <see langword="null" />。</param>
      <returns>已添加的方法调试信息的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)">
      <summary>添加方法定义。</summary>
      <param name="attributes">方法属性。</param>
      <param name="implAttributes">方法实现属性。</param>
      <param name="name">方法名。</param>
      <param name="signature">方法签名。</param>
      <param name="bodyOffset">如果该方法具有主体，则为 PE 映像中存储方法主体（IL 流）的块内的偏移量；否则为 -1。</param>
      <param name="parameterList">如果方法在 Params 表中声明参数，请将其设置为第一个参数的句柄。 否则，请将其设置为下一个方法定义所声明的第一个参数的句柄。 如果未在模块中声明任何参数，则为 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bodyOffset" /> 小于 -1。</exception>
      <returns>已添加的方法定义的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>定义类型中方法声明的实现。</summary>
      <param name="type">类型定义。</param>
      <param name="methodBody">方法主体实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="methodDeclaration">方法声明实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="methodBody" /> 或 <paramref name="methodDeclaration" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的方法实现的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>将导入信息添加到方法定义。</summary>
      <param name="method">方法定义句柄。</param>
      <param name="attributes">方法导入属性。</param>
      <param name="name">非托管的方法名称。</param>
      <param name="module">包含非托管方法的模块。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>将方法（getter、setter、adder 等）与属性或事件关联。</summary>
      <param name="association">关联实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />。</param>
      <param name="semantics">方法语义特性。</param>
      <param name="methodDefinition">方法定义。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="association" /> 不具有预期的句柄类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加方法规范（实例化）。</summary>
      <param name="method">泛型方法实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />。</param>
      <param name="instantiation">实例化 blob 对方法的泛型参数进行编码。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的方法规范的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="generation" />
      <param name="moduleName" />
      <param name="mvid" />
      <param name="encId" />
      <param name="encBaseId" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)">
      <param name="moduleName" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>定义与指定的类型定义的嵌套关系。</summary>
      <param name="type">嵌套类型定义句柄。</param>
      <param name="enclosingType">封闭类型定义句柄。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)">
      <summary>添加参数定义。</summary>
      <param name="attributes">参数特性。</param>
      <param name="name">可选。 参数名称。</param>
      <param name="sequenceNumber">参数的序列号。 值为 0 表示所有者方法的返回类型；然后从 1 开始对其参数进行编号。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sequenceNumber" /> 大于 <see cref="F:System.UInt16.MaxValue" />。</exception>
      <returns>已添加的参数的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)">
      <summary>添加属性定义。</summary>
      <param name="attributes">属性特性。</param>
      <param name="name">属性名称。</param>
      <param name="signature">属性的签名。</param>
      <returns>已添加的属性定义的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="declaringType" />
      <param name="propertyList" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>添加状态机方法调试信息。</summary>
      <param name="moveNextMethod">状态机的 <see langword="MoveNext" /> 方法（由编译器生成的方法）的句柄。</param>
      <param name="kickoffMethod">启动方法（用户定义的迭代器/异步方法）的句柄。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>添加类型定义。</summary>
      <param name="attributes">类型属性。</param>
      <param name="namespace">类型命名空间。</param>
      <param name="name">类型名称。</param>
      <param name="baseType">基类型实体句柄，可以是以下项之一：<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 或 <see langword="null" />。</param>
      <param name="fieldList">如果类型声明字段，请将其设置为第一个字段的句柄。 否则，请将其设置为下一个类型定义所声明的第一个字段的句柄。 如果任何类型都未在模块中定义任何字段，则为 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />。</param>
      <param name="methodList">如果类型声明方法，则为第一个方法的句柄。 否则，为下一个类型定义所声明的第一个方法的句柄。 如果任何类型都未在模块中定义任何方法，则为 <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="baseType" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的类型定义的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)">
      <summary>定义类型定义的类型布局。</summary>
      <param name="type">类型定义。</param>
      <param name="packingSize">指定应将字段放在类型实例中为 <paramref name="packingSize" /> 的倍数的字节地址，或者按该字段类型的自然对齐方式放置，以字节地址较小者为准。 其值应为以下值之一：0、1、2、4、8、16、32、64 或 128。 如果值为零，则表示所使用的包大小应与当前平台的默认值匹配。</param>
      <param name="size">指示类型实例的最小大小，并旨在允许填充。 分配的内存量是根据布局和 <paramref name="size" /> 计算得到的最大大小。 请注意，如果此指令适用于值类型，则大小将小于 1 MB。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <summary>添加类型引用。</summary>
      <param name="resolutionScope">声明目标类型的实体，可以是以下项之一：<see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />、<see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see langword="null" />。</param>
      <param name="namespace">类型引用命名空间。</param>
      <param name="name">类型引用名称。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="resolutionScope" /> 不具有预期的句柄类型。</exception>
      <returns>已添加的类型引用的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)">
      <param name="signature" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])">
      <summary>将指定的 blob 添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">包含 blob 的数组。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>将指定的 blob 从字节数组添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">包含 blob 的数组。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)">
      <summary>将指定的 blob 从不可变字节数组添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">包含 blob 的 blob 生成器实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)">
      <summary>使用 UTF16 编码向 blob 编码字符串，并将其添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">要添加的字符串。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)">
      <summary>使用 UTF8 编码向 blob 编码字符串，并将其添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">要相加的值。</param>
      <param name="allowUnpairedSurrogates">如果为 <see langword="true" />，则按指定方式对不成对的代理进行编码；如果为 <see langword="false" />，则将它们替换为 U + FFFD 字符。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)">
      <summary>向 blob 编码常量值，并将其添加到 Blob 堆（如果尚不存在）。 使用 UTF16 对字符串常量进行编码。</summary>
      <param name="value">要添加的常量值。</param>
      <returns>已添加的或现有的 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)">
      <summary>对调试文档名称进行编码，并将其添加到 Blob 堆（如果尚不存在）。</summary>
      <param name="value">要添加的文档名称。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的文档名称 blob 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)">
      <summary>将指定的 Guid 添加到 Guid 堆（如果尚不存在）。</summary>
      <param name="guid">要添加的 Guid。</param>
      <returns>已添加的或现有的 Guid 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)">
      <summary>将指定的字符串添加到字符串堆（如果尚不存在）。</summary>
      <param name="value">要添加的字符串。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的字符串的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)">
      <summary>将指定的字符串添加到用户字符串堆（如果尚不存在）。</summary>
      <param name="value">要添加的字符串。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">堆上的剩余空间太小，无法容纳该字符串。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="value" /> 为 <see langword="null" />。</exception>
      <returns>已添加的或现有的字符串的句柄。 此值可用于 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>返回指定表中的当前项数。</summary>
      <param name="table">表索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> 不是有效的表索引。</exception>
      <returns>表中的项数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts">
      <summary>返回每个表中的当前项数。</summary>
      <returns>大小为 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> 的数组，其中每一项都由相应表的当前行计数填充。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid">
      <summary>在 Guid 堆上为 GUID 保留空间。</summary>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">堆上的剩余空间太小，无法容纳该字符串。</exception>
      <returns>保留的 Guid 和表示存储在堆上的 GUID blob 的 <see cref="T:System.Reflection.Metadata.Blob" /> 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)">
      <summary>在用户字符串堆上为指定长度的字符串保留空间。</summary>
      <param name="length">要保留的字符数。</param>
      <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">堆上的剩余空间太小，无法容纳该字符串。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 为负数。</exception>
      <returns>保留的用户字符串和表示整个用户字符串 blob （包括其长度和终端字符）的 <see cref="T:System.Reflection.Metadata.Blob" /> 的句柄。 该句柄可用于 <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />。
使用 <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> 填充 blob 内容。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)">
      <summary>设置指定堆的容量。</summary>
      <param name="heap">堆索引。</param>
      <param name="byteCount">字节数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heap" /> 不是有效的堆索引。

- 或 -

<paramref name="byteCount" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>设置指定表的容量。</summary>
      <param name="table">表索引。</param>
      <param name="rowCount">表中的行数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="table" /> 不是有效的表索引。

- 或 -

<paramref name="rowCount" /> 为负数。</exception>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
      <summary>提供用于处理 ECMA-335 元数据表和堆的某些原始元素的扩展方法。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>枚举 EnC 日志的条目。</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
      <summary>枚举 EnC 映射的条目。</summary>
      <param name="reader" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>返回从元数据开始处到指定堆的偏移量。</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> 不是有效的堆索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>返回指定堆的大小。</summary>
      <param name="reader" />
      <param name="heapIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="heapIndex" /> 不是有效的堆索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
      <summary>返回 <see cref="T:System.Reflection.Metadata.Blob" /> 堆中给定句柄之后的 <see cref="T:System.Reflection.Metadata.Blob" /> 句柄，或返回零句柄（如果它是最后一个句柄）。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
      <summary>返回字符串堆中给定句柄之后的字符串句柄，或返回零句柄（如果它是最后一个句柄）。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
      <summary>返回 UserString 堆中给定句柄之后的 UserString 句柄，或返回零句柄（如果它是最后一个句柄）。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>返回从元数据开始处到指定表的偏移量。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> 不是有效的表索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>返回指定表中的行数。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> 不是有效的表索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
      <summary>返回指定表中行的大小。</summary>
      <param name="reader" />
      <param name="tableIndex" />
      <exception cref="T:System.ArgumentNullException">
        <paramref name="reader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="tableIndex" /> 不是有效的表索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
      <summary>枚举定义一个或多个事件的类型。</summary>
      <param name="reader" />
      <returns>生成的序列完全对应于 EventMap 表中的条目，即，返回的第 n 个 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 存储在 EventMap 的第 n 行。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
      <summary>枚举定义一个或多个属性的类型。</summary>
      <param name="reader" />
      <returns>生成的序列完全对应于属性映射表中的条目，即，返回的第 n 个 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 存储在属性映射的第 n 行。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)">
      <summary>给定的类型句柄和签名 blob 中的原始类型种类决定目标类型是值类型还是引用类型。</summary>
      <param name="reader" />
      <param name="typeHandle" />
      <param name="rawTypeKind" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataRootBuilder">
      <summary>要嵌入到可移植可执行映像中的元数据根的生成器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.String,System.Boolean)">
      <summary>创建元数据根的生成器。</summary>
      <param name="tablesAndHeaps">用存储在表中的元数据实体和存储在堆中的值填充的生成器。 序列化元数据根时，会枚举实体和值。</param>
      <param name="metadataVersion">写入元数据头的版本字符串。 默认值是“v4.0.30319”。</param>
      <param name="suppressValidation">
        <see langword="true" /> 表示在序列化过程中取消元数据表的基本验证；否则为 <paramref name="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="metadataVersion" /> 过长（UTF8 编码时的字符数必须小于 255）。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Int32,System.Int32)">
      <summary>将元数据根内容序列化为给定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder">要写入的目标生成器。</param>
      <param name="methodBodyStreamRva">方法主体流开头的相对虚拟地址。 用于计算 MethodDef 表的 RVA 字段的最终值。</param>
      <param name="mappedFieldDataStreamRva">字段 init 数据流开头的相对虚拟地址。 用于计算 FieldRVA 表的 RVA 字段的最终值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="methodBodyStreamRva" /> 或 <paramref name="mappedFieldDataStreamRva" /> 为负数。</exception>
      <exception cref="T:System.InvalidOperationException">元数据表没有按规范要求排序，且 <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> 是 <see langword="false" />。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.MetadataVersion">
      <summary>元数据版本。</summary>
      <returns>表示元数据版本的字符串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.Sizes">
      <summary>返回各种元数据结构的大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation">
      <summary>确定是否应取消元数据表的基本验证。 验证将验证是否按照 ECMA 规范要求的顺序添加表中的条目。 它不强制对元数据表执行所有规范要求。</summary>
      <returns>
        <see langword="true" /> 禁止显示元数据表的基本验证;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataSizes">
      <summary>提供有关各种元数据结构大小的信息。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)">
      <summary>返回指定堆的对齐大小。</summary>
      <param name="index" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.ExternalRowCounts">
      <summary>外部表行计数。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.HeapSizes">
      <summary>精确（未对齐）的堆大小。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MetadataSizes.RowCounts">
      <summary>表行计数。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MetadataTokens" />
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
      <summary>可以存在于 Ecma335 元数据中的表的最大数目。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
      <summary>可以存在于 Ecma335 元数据中的表的最大数目。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyFileHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.AssemblyReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.BlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.CustomDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DeclarativeSecurityAttributeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.DocumentNameBlobHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
      <summary>从标记值创建实体句柄。</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> 不是有效的元数据实体标记。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>从标记值创建 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> 不是有效的表索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EventDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ExportedTypeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterConstraintHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GenericParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.BlobHandle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="handle" />
      <returns>从零开始的偏移量，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的上下文中解释 <paramref name="handle" />，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.GuidHandle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="handle" />
      <returns>#Guid 堆中的从 1 开始的索引。 与其他堆（本质上是字节数组）不同，#Guid 堆是 16 字节 GUID 的数组。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="handle" />
      <returns>相应堆中的偏移量，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的上下文中解释 <paramref name="handle" />，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>获取与 <paramref name="reader" /> 上下文中的指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">指定的 <paramref name="handle" /> 不支持该操作。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> 无效。</exception>
      <returns>从零开始的偏移量，如果 <paramref name="handle" /> 不是元数据堆句柄，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.StringHandle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="handle" />
      <returns>从零开始的偏移量，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 或 <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" /> 的上下文中解释 <paramref name="handle" />，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.UserStringHandle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据堆数据的偏移量。</summary>
      <param name="handle" />
      <returns>从零开始的偏移量。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
      <summary>获取与指定 <paramref name="handle" /> 相对应的元数据表项的行号。</summary>
      <param name="handle" />
      <returns>从 1 开始的行号，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的上下文中解释 <paramref name="handle" />，则为 -1。
请参阅 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>获取与 <paramref name="reader" /> 上下文中的指定 <paramref name="handle" /> 相对应的元数据表项的行号。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">
        <paramref name="handle" /> 不是有效的元数据表句柄。</exception>
      <returns>从 1 开始的行号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.EntityHandle)">
      <summary>获取指定 <paramref name="handle" /> 的元数据标记。</summary>
      <param name="handle" />
      <returns>元数据标记，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的上下文中解释 <paramref name="handle" />，则为 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
      <summary>获取指定 <paramref name="handle" /> 的元数据标记。</summary>
      <param name="handle" />
      <exception cref="T:System.ArgumentException">句柄表示没有标记的元数据实体。
只能为元数据表句柄或 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 类型的堆句柄检索标记。</exception>
      <returns>元数据标记，如果只能在特定 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 的上下文中解释 <paramref name="handle" />，则为 0。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
      <summary>获取 <paramref name="reader" /> 上下文中的指定 <paramref name="handle" /> 的元数据标记。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.NotSupportedException">指定的 <paramref name="handle" /> 不支持该操作。</exception>
      <returns>元数据标记。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
      <summary>获取 <paramref name="reader" /> 上下文中的指定 <paramref name="handle" /> 的元数据标记。</summary>
      <param name="reader" />
      <param name="handle" />
      <exception cref="T:System.ArgumentException">句柄表示没有标记的元数据实体。
只能为元数据表句柄或 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 类型的堆句柄检索标记。</exception>
      <exception cref="T:System.NotSupportedException">指定的 <paramref name="handle" /> 不支持该操作。</exception>
      <returns>元数据标记。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GuidHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
      <summary>从标记值创建句柄。</summary>
      <param name="token" />
      <exception cref="T:System.ArgumentException">
        <paramref name="token" /> 不是有效的元数据标记。
它必须对元数据表实体或 <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> 堆中的偏移量进行编码。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
      <summary>从标记值创建 <see cref="T:System.Reflection.Metadata.EntityHandle" />。</summary>
      <param name="tableIndex" />
      <param name="rowNumber" />
      <exception cref="T:System.ArgumentException">
        <paramref name="tableIndex" /> 不是有效的表索引。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ImportScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.InterfaceImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalScopeHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ManifestResourceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MemberReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDebugInformationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodImplementationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ModuleReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.PropertyDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StandaloneSignatureHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.StringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
      <summary>获取与指定 <see cref="T:System.Reflection.Metadata.HandleKind" /> 相对应的堆的 <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" />。</summary>
      <param name="type">句柄类型。</param>
      <param name="index">堆索引。</param>
      <returns>如果句柄类型对应于 Ecma335 堆，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
      <summary>获取与指定 <see cref="T:System.Reflection.Metadata.HandleKind" /> 相对应的表的 <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />。</summary>
      <param name="type">句柄类型。</param>
      <param name="index">表索引。</param>
      <returns>如果句柄类型对应于 Ecma335 或可移植的 PDB 表，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeDefinitionHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeReferenceHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TypeSpecificationHandle(System.Int32)">
      <param name="rowNumber" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.UserStringHandle(System.Int32)">
      <param name="offset" />
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyAttributes">
      <summary>定义方法主体属性。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.InitLocals">
      <summary>将该方法定义的任何局部变量初始化为零，并动态分配本地内存。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Ecma335.MethodBodyAttributes.None">
      <summary>不执行任何本地内存初始化。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder">
      <summary>为方法主体流提供编码器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>通过使用提供的代码大小、最大堆栈大小、异常区域的数目、局部变量的签名句柄、方法主体属性并允许指示是否应以小格式编码异常区域，对方法主体进行编码，并将其添加到方法主体流。</summary>
      <param name="codeSize">要为指令保留的字节数。</param>
      <param name="maxStack">最大堆栈大小。</param>
      <param name="exceptionRegionCount">异常区域的数目。</param>
      <param name="hasSmallExceptionRegions">如果应以小格式编码异常区域，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <param name="localVariablesSignature">局部变量的签名句柄。</param>
      <param name="attributes">方法主体属性。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />、 <paramref name="exceptionRegionCount" /> 或 <paramref name="maxStack" /> 超出了允许的范围。</exception>
      <returns>已编码主体在方法主体流中的偏移量。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Int32,System.Int32,System.Int32,System.Boolean,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>通过使用提供的代码大小、最大堆栈大小、异常区域的数目、局部变量的签名句柄、方法主体属性，允许指示是否应以小格式编码异常区域，并允许指示方法是否应从动态本地内存池分配，对方法主体进行编码，并将其添加到方法主体流。</summary>
      <param name="codeSize">要为指令保留的字节数。</param>
      <param name="maxStack">最大堆栈大小。</param>
      <param name="exceptionRegionCount">异常区域的数目。</param>
      <param name="hasSmallExceptionRegions">如果应以小格式编码异常区域，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <param name="localVariablesSignature">局部变量的签名句柄。</param>
      <param name="attributes">方法主体属性。</param>
      <param name="hasDynamicStackAllocation">如果方法从动态本地内存池分配（<see langword="localloc" /> 指令），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="codeSize" />、 <paramref name="exceptionRegionCount" /> 或 <paramref name="maxStack" /> 超出了允许的范围。</exception>
      <returns>已编码主体在方法主体流中的偏移量。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes)">
      <summary>对方法主体进行编码，并将其添加到方法主体流中。</summary>
      <param name="instructionEncoder">指令编码器。</param>
      <param name="maxStack">最大堆栈大小。</param>
      <param name="localVariablesSignature">局部变量的签名句柄。</param>
      <param name="attributes">方法主体属性。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> 具有默认值。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> 超出范围 [0, <see cref="F:System.UInt16.MaxValue" />]。</exception>
      <exception cref="T:System.InvalidOperationException">指令流中分支的目标标签尚未标记，或者分支指令与目标标签之间的距离不符合指令操作数的大小。</exception>
      <returns>已编码主体在方法主体流中的偏移量。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.AddMethodBody(System.Reflection.Metadata.Ecma335.InstructionEncoder,System.Int32,System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.Ecma335.MethodBodyAttributes,System.Boolean)">
      <summary>通过使用提供的指令编码器、最大堆栈大小、局部变量的签名句柄、方法主体属性并允许指示该方法是否应从动态本地内存池分配，对方法主体进行编码，并将其添加到方法主体流。</summary>
      <param name="instructionEncoder">指令编码器。</param>
      <param name="maxStack">最大堆栈大小。</param>
      <param name="localVariablesSignature">局部变量的签名句柄。</param>
      <param name="attributes">方法主体属性。</param>
      <param name="hasDynamicStackAllocation">如果方法从动态本地内存池分配（IL 包含 <see langword="localloc" /> 指令），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instructionEncoder" /> 具有默认值。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxStack" /> 超出范围 [0, <see cref="F:System.UInt16.MaxValue" />]。</exception>
      <exception cref="T:System.InvalidOperationException">指令流中分支的目标标签尚未标记，或者分支指令与目标标签之间的距离不符合指令操作数的大小。</exception>
      <returns>已编码主体在方法主体流中的偏移量。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody">
      <summary>描述方法主体。 此类应与 <see cref="T:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder" /> 类一起使用。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.ExceptionRegions">
      <summary>获取一个编码器对象，该对象可用于将异常区域编码为方法主体。</summary>
      <returns>异常区域编码器实例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Instructions">
      <summary>获取为指令保留的 Blob。</summary>
      <returns>保留的用于说明的 blob。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodBodyStreamEncoder.MethodBody.Offset">
      <summary>获取已编码方法主体在方法主体流中的偏移量。</summary>
      <returns>已编码的方法体在方法正文流中的偏移量。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder">
      <summary>为方法签名提供编码器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Action{System.Reflection.Metadata.Ecma335.ReturnTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ParametersEncoder})">
      <summary>对所提供的返回类型和参数进行编码。</summary>
      <param name="parameterCount">参数的数量。</param>
      <param name="returnType">第一个调用以对返回类型进行编码的方法。</param>
      <param name="parameters">第二个调用以对参数进行编码的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="returnType" /> 或 <paramref name="parameters" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Parameters(System.Int32,System.Reflection.Metadata.Ecma335.ReturnTypeEncoder@,System.Reflection.Metadata.Ecma335.ParametersEncoder@)">
      <summary>对所提供的返回类型和参数进行编码，必须按它们在参数列表中出现的顺序使用它们。</summary>
      <param name="parameterCount">参数的数量。</param>
      <param name="returnType">第一个调用以对返回类型进行编码的方法。</param>
      <param name="parameters">第二个调用以对参数进行编码的方法。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.MethodSignatureEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder" /> 结构的新实例。</summary>
      <param name="builder">用于编码命名参数的生成器。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Action{System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.NameEncoder},System.Action{System.Reflection.Metadata.Ecma335.LiteralEncoder})">
      <summary>对命名参数（字段或属性）进行编码。</summary>
      <param name="isField">如果对字段进行编码，则为 <see langword="true" />，如果对属性进行编码，则为 <see langword="false" />。</param>
      <param name="type">第一个调用以对参数类型进行编码的方法。</param>
      <param name="name">第二个调用以对字段或属性的名称进行编码的方法。</param>
      <param name="literal">第三个调用以对参数的文本值进行编码的方法。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" />、<paramref name="name" /> 或 <paramref name="literal" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.AddArgument(System.Boolean,System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder@,System.Reflection.Metadata.Ecma335.NameEncoder@,System.Reflection.Metadata.Ecma335.LiteralEncoder@)">
      <summary>对命名参数（字段或属性）进行编码，并返回三个编码器，必须按它们在参数列表中出现的顺序使用它们。</summary>
      <param name="isField">如果对字段进行编码，则为 <see langword="true" />，如果对属性进行编码，则为 <see langword="false" />。</param>
      <param name="type">第一个调用以对参数类型进行编码的方法。</param>
      <param name="name">第二个调用以对字段或属性的名称进行编码的方法。</param>
      <param name="literal">第三个调用以对参数的文本值进行编码的方法。</param>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentsEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.ScalarType" />
    <member name="M:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.SZArray" />
    <member name="P:System.Reflection.Metadata.Ecma335.NamedArgumentTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.NameEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.NameEncoder.Name(System.String)">
      <param name="name" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.NameEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParametersEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.#ctor(System.Reflection.Metadata.BlobBuilder,System.Boolean)">
      <param name="builder" />
      <param name="hasVarArgs" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.AddParameter" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParametersEncoder.StartVarArgs" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.Builder" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParametersEncoder.HasVarArgs" />
    <member name="T:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.TypedReference" />
    <member name="P:System.Reflection.Metadata.Ecma335.ParameterTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PermissionSetEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.AddPermission(System.String,System.Reflection.Metadata.BlobBuilder)">
      <param name="typeName" />
      <param name="encodedArguments" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PermissionSetEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.PortablePdbBuilder">
      <summary>表示可移植 PDB 映像的生成器。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.#ctor(System.Reflection.Metadata.Ecma335.MetadataBuilder,System.Collections.Immutable.ImmutableArray{System.Int32},System.Reflection.Metadata.MethodDefinitionHandle,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <summary>创建可移植 PDB 映像的生成器。</summary>
      <param name="tablesAndHeaps">用存储在表中的调试元数据实体和存储在堆中的值填充的生成器。 序列化可移植 PDB 映像时，会枚举实体和值。</param>
      <param name="typeSystemRowCounts">关联的类型系统元数据所包含的所有表的行计数。 数组中的每个槽对应于一个表 (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />)。 数组的长度必须等于 <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />。</param>
      <param name="entryPoint">入口点方法定义句柄。</param>
      <param name="idProvider">计算以 Blob 序列表示的内容 ID 的函数。 如果未指定，则使用默认函数，该函数将忽略内容并基于当前时间返回内容 ID (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />)。 必须指定一个确定性函数以生成确定性可移植 PDB 映像。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="tablesAndHeaps" /> 或 <paramref name="typeSystemRowCounts" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <summary>将可移植 PDB 内容序列化为给定的 <see cref="T:System.Reflection.Metadata.BlobBuilder" />。</summary>
      <param name="builder">要写入的目标生成器。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="builder" /> 为 <see langword="null" />。</exception>
      <returns>序列化内容的 ID。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.FormatVersion" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.IdProvider" />
    <member name="P:System.Reflection.Metadata.Ecma335.PortablePdbBuilder.MetadataVersion" />
    <member name="T:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.CustomModifiers" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Type(System.Boolean)">
      <param name="isByRef" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.TypedReference" />
    <member name="M:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Void" />
    <member name="P:System.Reflection.Metadata.Ecma335.ReturnTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.ScalarEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.Constant(System.Object)">
      <summary>对常量文本进行编码。</summary>
      <param name="value">类型为 <see cref="T:System.Boolean" />、<see cref="T:System.Byte" />、<see cref="T:System.SByte" />、<see cref="T:System.Int16" />、<see cref="T:System.UInt16" />、<see cref="T:System.Int32" />、<see cref="T:System.UInt32" />、<see cref="T:System.Int64" />、<see cref="T:System.UInt64" />、<see cref="T:System.Single" />、<see cref="T:System.Double" />、<see cref="T:System.Char" />（编码为双字节 Unicode 字符）、<see cref="T:System.String" />（编码为 SerString）或 <see cref="T:System.Enum" />（编码为基础整数值）的常量。</param>
      <exception cref="T:System.ArgumentException">意外的常量类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.NullArray">
      <summary>对类型为 <see cref="T:System.Array" /> 的 <see langword="null" /> 文本进行编码。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.ScalarEncoder.SystemType(System.String)">
      <summary>对类型为 <see cref="T:System.Type" /> 的文本（可能为 <see langword="null" />）进行编码。</summary>
      <param name="serializedTypeName">类型的名称，或 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="serializedTypeName" /> 为空。</exception>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.ScalarEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2">
      <summary>对签名 Blob 进行解码。</summary>
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.#ctor(System.Reflection.Metadata.ISignatureTypeProvider{`0,`1},System.Reflection.Metadata.MetadataReader,`1)">
      <summary>创建一个新的 <see cref="T:System.Reflection.Metadata.Ecma335.SignatureDecoder`2" />。</summary>
      <param name="provider">用于在解码签名时获取类型符号的提供程序。</param>
      <param name="metadataReader">从中获取签名的元数据读取器。 如果给定的提供程序允许，可以为 <see langword="null" />。</param>
      <param name="genericContext">解析泛型参数所需的其他上下文。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeFieldSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>对字段签名 Blob 进行解码，并将读取器移到签名之前。</summary>
      <param name="blobReader">位于字段签名中的 Blob 读取器。</param>
      <returns>已解码的字段类型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeLocalSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>对局部变量签名 Blob 进行解码，并将读取器移到签名之前。</summary>
      <param name="blobReader">位于局部变量签名中的 Blob 读取器。</param>
      <exception cref="T:System.BadImageFormatException">局部变量签名无效。</exception>
      <returns>局部变量类型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>对方法（定义、引用或独立）或属性签名 Blob 进行解码。</summary>
      <param name="blobReader">位于方法签名中的 Blob 读取器。</param>
      <exception cref="T:System.BadImageFormatException">方法签名无效。</exception>
      <returns>已解码的方法签名。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeMethodSpecificationSignature(System.Reflection.Metadata.BlobReader@)">
      <summary>对方法规范签名 Blob 进行解码，并将读取器移到签名之前。</summary>
      <param name="blobReader">位于有效方法规范签名中的 Blob 读取器。</param>
      <returns>用于通过方法规范实例化泛型方法的类型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureDecoder`2.DecodeType(System.Reflection.Metadata.BlobReader@,System.Boolean)">
      <summary>对签名中嵌入的类型进行解码，并将读取器移到类型之前。</summary>
      <param name="blobReader">位于前导 <see cref="T:System.Reflection.Metadata.SignatureTypeCode" /> 中的 Blob 读取器。</param>
      <param name="allowTypeSpecifications">如果允许 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> 在签名中跟随 (CLASS | VALUETYPE)，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException">读取器未定位于有效的签名类型。</exception>
      <returns>已解码的类型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Action{System.Reflection.Metadata.Ecma335.SignatureTypeEncoder},System.Action{System.Reflection.Metadata.Ecma335.ArrayShapeEncoder})">
      <summary>对数组类型进行编码。</summary>
      <param name="elementType">第一个调用以对元素的类型进行编码。</param>
      <param name="arrayShape">第二个调用以对数组的形状进行编码。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="elementType" /> 或 <paramref name="arrayShape" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Array(System.Reflection.Metadata.Ecma335.SignatureTypeEncoder@,System.Reflection.Metadata.Ecma335.ArrayShapeEncoder@)">
      <summary>对数组类型进行编码。 返回一个编码器对，必须按它们在参数列表中出现的顺序来使用。</summary>
      <param name="elementType">第一个使用以对元素的类型进行编码。</param>
      <param name="arrayShape">第二个使用以对数组的形状进行编码。</param>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Boolean" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Byte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Char" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.CustomModifiers">
      <summary>启动具有自定义修饰符的类型的签名。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Double" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.FunctionPointer(System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.Ecma335.FunctionPointerAttributes,System.Int32)">
      <summary>启动函数指针签名。</summary>
      <param name="convention">调用约定。</param>
      <param name="attributes">函数指针属性。</param>
      <param name="genericParameterCount">泛型形参计数。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="attributes" /> 无效。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericParameterCount" /> 不在范围 [0, 0xffff] 内。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericInstantiation(System.Reflection.Metadata.EntityHandle,System.Int32,System.Boolean)">
      <summary>启动泛型实例化签名。</summary>
      <param name="genericType">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="genericArgumentCount">泛型实参计数。</param>
      <param name="isValueType">如果将类型标记为值类型，则为 <see langword="true" />，如果将其标记为签名中的引用类型，则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="genericType" /> 不具有预期的句柄类型。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="genericArgumentCount" /> 不在范围 [1, 0xffff] 内。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericMethodTypeParameter(System.Int32)">
      <summary>对包含泛型方法的类型参数的引用进行编码。</summary>
      <param name="parameterIndex">参数索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> 不在范围 [0, 0xffff] 内。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.GenericTypeParameter(System.Int32)">
      <summary>对包含泛型类型的类型参数的引用进行编码。</summary>
      <param name="parameterIndex">参数索引。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="parameterIndex" /> 不在范围 [0, 0xffff] 内。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Int64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.IntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Object" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Pointer">
      <summary>启动指针签名。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.PrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>写入基元类型代码。</summary>
      <param name="type">除 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> 和 <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" /> 以外的任何基元类型代码。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="type" /> 在此上下文中无效。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SByte" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Single" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.String" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.SZArray">
      <summary>启动 SZ 数组（向量）签名。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Type(System.Reflection.Metadata.EntityHandle,System.Boolean)">
      <summary>对类型的引用进行编码。</summary>
      <param name="type">
        <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />。</param>
      <param name="isValueType">如果将类型标记为值类型，则为 <see langword="true" />，如果将其标记为签名中的引用类型，则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="type" /> 不具有预期的句柄类型。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt16" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt32" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UInt64" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.UIntPtr" />
    <member name="M:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.VoidPointer">
      <summary>对 void 指针进行编码 (<c>void*</c>)。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.SignatureTypeEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.Ecma335.TableIndex" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Assembly" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefOS" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.AssemblyRefProcessor" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ClassLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Constant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.DeclSecurity" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Document" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncLog" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EncMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Event" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.EventPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ExportedType" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Field" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldLayout" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldMarshal" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.FieldRva" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.File" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParam" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.GenericParamConstraint" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImplMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ImportScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.InterfaceImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalConstant" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalScope" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.LocalVariable" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ManifestResource" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MemberRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodImpl" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSemantics" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.MethodSpec" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Module" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ModuleRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.NestedClass" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Param" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.ParamPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.Property" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyMap" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.PropertyPtr" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StandAloneSig" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.StateMachineMethod" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef" />
    <member name="F:System.Reflection.Metadata.Ecma335.TableIndex.TypeSpec" />
    <member name="T:System.Reflection.Metadata.Ecma335.VectorEncoder" />
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.#ctor(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.Metadata.Ecma335.VectorEncoder.Count(System.Int32)">
      <param name="count" />
    </member>
    <member name="P:System.Reflection.Metadata.Ecma335.VectorEncoder.Builder" />
    <member name="T:System.Reflection.Metadata.EntityHandle">
      <summary>表示元数据实体（如类型引用、类型定义、类型规范、方法定义或自定义特性）。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.EntityHandle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Object)">
      <summary>返回一个值，该值指示当前实例与指定的对象是否相等。</summary>
      <param name="obj">要与当前实例进行比较的对象。</param>
      <returns>如果 <paramref name="obj" /> 是 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 并且等于当前实例，则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.Equals(System.Reflection.Metadata.EntityHandle)">
      <summary>返回一个值，该值指示当前实例与指定的 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 是否相等。</summary>
      <param name="other">与当前实例进行比较的值。</param>
      <returns>如果当前实例与 <paramref name="other" /> 相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.GetHashCode">
      <summary>返回此实例的哈希代码。</summary>
      <returns>此实例的哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Equality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Implicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EntityHandle.op_Inequality(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EntityHandle.IsNil" />
    <member name="P:System.Reflection.Metadata.EntityHandle.Kind" />
    <member name="T:System.Reflection.Metadata.EventAccessors" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Adder" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Others" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Raiser" />
    <member name="P:System.Reflection.Metadata.EventAccessors.Remover" />
    <member name="T:System.Reflection.Metadata.EventDefinition" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.EventDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Name" />
    <member name="P:System.Reflection.Metadata.EventDefinition.Type" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.Equals(System.Reflection.Metadata.EventDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Equality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.EventDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Implicit(System.Reflection.Metadata.EventDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandle.op_Inequality(System.Reflection.Metadata.EventDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#EventDefinitionHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.EventDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegion" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
      <summary>如果该区域表示 catch，则获取 TypeRef、TypeDef 或 TypeSpec 句柄；否则获取 nil 令牌(<see langword="default" />(<see cref="T:System.Reflection.Metadata.EntityHandle" />))。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
      <summary>获取筛选器块起始处的 IL 偏移量，如果该区域不是筛选器，则获取 -1。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
      <summary>获取异常处理程序的长度（以字节为单位）。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
      <summary>获取异常处理程序的初始 IL 偏移量。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.Kind" />
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
      <summary>获取 try 块的长度（以字节为单位）。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
      <summary>获取 try 块的初始 IL 偏移量。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExceptionRegionKind" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Fault" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />
    <member name="F:System.Reflection.Metadata.ExceptionRegionKind.Finally" />
    <member name="T:System.Reflection.Metadata.ExportedType" />
    <member name="M:System.Reflection.Metadata.ExportedType.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Attributes" />
    <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
      <summary>获取用于解析目标类型的实现的句柄。</summary>
      <returns>
        <list type="bullet">
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> 表示程序集中的另一个模块。</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> 如果为，则表示另一个程序集 <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /><see langword="true" /> 。</description>
          </item>
          <item>
            <description>
              <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> ，表示在其中嵌套此的声明导出类型。</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.IsForwarder" />
    <member name="P:System.Reflection.Metadata.ExportedType.Name">
      <summary>获取目标类型的名称；或者，如果该类型是嵌套的或在根命名空间中定义，则为 <see langword="default" />。</summary>
      <returns>一个 <see cref="T:System.Reflection.Metadata.StringHandle" /> 结构实例。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
      <summary>获取包含目标类型的命名空间的全名；或者，如果该类型是嵌套的或在根名称空间中定义，则为 <see langword="default" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
      <summary>获取定义目标类型的命名空间的定义句柄；或者，如果该类型是嵌套的或在根名称空间中定义，则为 <see langword="default" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandle" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.Equals(System.Reflection.Metadata.ExportedTypeHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Equality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ExportedTypeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Implicit(System.Reflection.Metadata.ExportedTypeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandle.op_Inequality(System.Reflection.Metadata.ExportedTypeHandle,System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 实例的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ExportedTypeHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ExportedTypeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinition" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetMarshallingDescriptor" />
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
      <summary>返回字段布局偏移量；如果不可用，则返回 -1。</summary>
      <returns>字段定义偏移量；如果不可用，则为 -1。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinition.GetRelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Name" />
    <member name="P:System.Reflection.Metadata.FieldDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.Equals(System.Reflection.Metadata.FieldDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Equality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.FieldDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Implicit(System.Reflection.Metadata.FieldDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandle.op_Inequality(System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#FieldDefinitionHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.FieldDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameter" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetConstraints" />
    <member name="M:System.Reflection.Metadata.GenericParameter.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
      <summary>获取指定差异和约束的属性。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Index">
      <summary>获取声明通用类型或方法声明中从零开始的参数索引。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Name">
      <summary>获取泛型参数的名称。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
      <summary>获取表示此泛型参数的父级的 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 或 <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraint" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraint.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
      <summary>获取受约束的 <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
      <summary>获取句柄（<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />），该句柄指定此泛型参数被约束为从哪个类型派生，或者此泛型参数被约束为实现哪个接口。</summary>
      <returns>一个 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 实例。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.Equals(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Equality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterConstraintHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Implicit(System.Reflection.Metadata.GenericParameterConstraintHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandle.op_Inequality(System.Reflection.Metadata.GenericParameterConstraintHandle,System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
      <summary>表示泛型类型参数的约束集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterConstraintHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Item(System.Int32)">
      <summary>获取位于只读列表中指定索引处的元素。</summary>
      <param name="index">要获取的元素的索引(索引从零开始)。</param>
      <returns>在只读列表中指定索引处的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterConstraintHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandle" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.Equals(System.Reflection.Metadata.GenericParameterHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Equality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GenericParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Implicit(System.Reflection.Metadata.GenericParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandle.op_Inequality(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.GenericParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
      <summary>表示方法或类型的泛型类型参数的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#GenericParameterHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Item(System.Int32)">
      <summary>获取位于只读列表中指定索引处的元素。</summary>
      <param name="index">要获取的元素的索引(索引从零开始)。</param>
      <returns>在只读列表中指定索引处的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.GenericParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.GuidHandle" />
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.Equals(System.Reflection.Metadata.GuidHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Equality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.GuidHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Implicit(System.Reflection.Metadata.GuidHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.GuidHandle.op_Inequality(System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.GuidHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Handle">
      <summary>表示任何元数据实体（如类型引用、类型定义、类型规范、方法定义或自定义特性）或值（字符串、blob、GUID 或用户字符串）。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.Handle.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.Handle.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.Equals(System.Reflection.Metadata.Handle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.Handle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.Handle.op_Equality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.Handle.op_Inequality(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.Handle.IsNil" />
    <member name="P:System.Reflection.Metadata.Handle.Kind" />
    <member name="T:System.Reflection.Metadata.HandleComparer" />
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>比较两个实体句柄。</summary>
      <param name="x">要比较的第一个实体句柄。</param>
      <param name="y">要比较的第二个实体句柄。</param>
      <returns>如果两个实体句柄相等，则为零；如果不相等，则为非零值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>比较两个句柄。</summary>
      <param name="x">要比较的第一个句柄。</param>
      <param name="y">要比较的第二个句柄。</param>
      <returns>如果两个句柄相等，则为零；如果不相等，则为非零值。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
      <summary>确定指定的对象是否相等。</summary>
      <param name="x">要比较的第一个类型为 <paramref name="T" /> 的对象。</param>
      <param name="y">要比较的第二个类型为 <paramref name="T" /> 的对象。</param>
      <returns>如果指定的对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
      <summary>确定指定的对象是否相等。</summary>
      <param name="x">要比较的第一个类型为 <paramref name="T" /> 的对象。</param>
      <param name="y">要比较的第二个类型为 <paramref name="T" /> 的对象。</param>
      <returns>如果指定的对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.EntityHandle)">
      <summary>返回指定对象的哈希代码。</summary>
      <param name="obj">
        <see cref="T:System.Object" />，将为其返回哈希代码。</param>
      <returns>指定对象的哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.HandleComparer.GetHashCode(System.Reflection.Metadata.Handle)">
      <summary>返回指定对象的哈希代码。</summary>
      <param name="obj">
        <see cref="T:System.Object" />，将为其返回哈希代码。</param>
      <returns>指定对象的哈希代码。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.HandleComparer.Default" />
    <member name="T:System.Reflection.Metadata.HandleKind" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyFile" />
    <member name="F:System.Reflection.Metadata.HandleKind.AssemblyReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.Blob" />
    <member name="F:System.Reflection.Metadata.HandleKind.Constant" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.CustomDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.DeclarativeSecurityAttribute" />
    <member name="F:System.Reflection.Metadata.HandleKind.Document" />
    <member name="F:System.Reflection.Metadata.HandleKind.EventDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ExportedType" />
    <member name="F:System.Reflection.Metadata.HandleKind.FieldDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.GenericParameterConstraint" />
    <member name="F:System.Reflection.Metadata.HandleKind.Guid" />
    <member name="F:System.Reflection.Metadata.HandleKind.ImportScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.InterfaceImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalConstant" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalScope" />
    <member name="F:System.Reflection.Metadata.HandleKind.LocalVariable" />
    <member name="F:System.Reflection.Metadata.HandleKind.ManifestResource" />
    <member name="F:System.Reflection.Metadata.HandleKind.MemberReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDebugInformation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodImplementation" />
    <member name="F:System.Reflection.Metadata.HandleKind.MethodSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.ModuleReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.NamespaceDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.Parameter" />
    <member name="F:System.Reflection.Metadata.HandleKind.PropertyDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.StandaloneSignature" />
    <member name="F:System.Reflection.Metadata.HandleKind.String" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeDefinition" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeReference" />
    <member name="F:System.Reflection.Metadata.HandleKind.TypeSpecification" />
    <member name="F:System.Reflection.Metadata.HandleKind.UserString" />
    <member name="T:System.Reflection.Metadata.IConstructedTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetArrayType(`0,System.Reflection.Metadata.ArrayShape)">
      <summary>获取给定元素类型和形状的通用数组的类型符号。</summary>
      <param name="elementType">数组中元素的类型。</param>
      <param name="shape">数组的形状（级别、大小和下限）。</param>
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetByReferenceType(`0)">
      <summary>获取给定元素类型的托管指针的类型符号。</summary>
      <param name="elementType" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetGenericInstantiation(`0,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>获取泛型实例化的类型符号，其中该实例化是具有给定类型参数的给定泛型类型。</summary>
      <param name="genericType" />
      <param name="typeArguments" />
    </member>
    <member name="M:System.Reflection.Metadata.IConstructedTypeProvider`1.GetPointerType(`0)">
      <summary>获取给定元素类型的非托管指针的类型符号。</summary>
      <param name="elementType" />
    </member>
    <member name="T:System.Reflection.Metadata.ICustomAttributeTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetSystemType">
      <summary>获取 <see cref="T:System.Type" /> 的 <typeparamref name="TType" /> 表达形式。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetTypeFromSerializedName(System.String)">
      <summary>获取给定的序列化类型名称的类型符号。</summary>
      <param name="name">采用所谓的“反射表示法”格式的序列化类型名称（由 <see cref="M:System.Type.GetType(System.String)" /> 方法识别）。</param>
      <exception cref="T:System.BadImageFormatException">名称格式不正确。</exception>
      <returns>一个 <typeparamref name="TType" /> 实例。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.GetUnderlyingEnumType(`0)">
      <summary>获取给定的枚举类型符号的基础类型。</summary>
      <param name="type">枚举类型。</param>
      <exception cref="T:System.BadImageFormatException">给定的类型符号不表示枚举。</exception>
      <returns>一个类型代码，它表示枚举的基础类型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ICustomAttributeTypeProvider`1.IsSystemType(`0)">
      <summary>验证给定的类型是否表示 <see cref="T:System.Type" />。</summary>
      <param name="type">要验证的类型。</param>
      <returns>如果给定的类型为 <see cref="T:System.Type" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ILOpCode" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Add_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.And" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Arglist" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Beq_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bge_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bgt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ble_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Blt_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Bne_un_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Box" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Br_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Break" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brfalse_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Brtrue_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Call" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Calli" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Callvirt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Castclass" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ceq" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cgt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ckfinite" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Clt_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Constrained" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_i8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u1_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u2_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u4_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_ovf_u8_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Conv_u8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Cpobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Div_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Dup" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfilter" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Endfinally" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initblk" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Initobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Isinst" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Jmp" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldarga_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_5" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_6" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_7" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_m1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i4_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldc_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelem_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldelema" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldind_u4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldlen" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldloca_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldnull" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldsflda" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldstr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldtoken" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ldvirtftn" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Leave_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Localloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mkrefany" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Mul_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Neg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newarr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Newobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Nop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Not" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Or" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Pop" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Readonly" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanytype" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Refanyval" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rem_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Ret" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Rethrow" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shl" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Shr_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sizeof" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Starg_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stelem_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_i8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r4" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_r8" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stind_ref" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_0" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_1" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_2" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_3" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stloc_s" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stobj" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Stsfld" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Sub_ovf_un" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Switch" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Tail" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Throw" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unaligned" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Unbox_any" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Volatile" />
    <member name="F:System.Reflection.Metadata.ILOpCode.Xor" />
    <member name="T:System.Reflection.Metadata.ILOpCodeExtensions" />
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetBranchOperandSize(System.Reflection.Metadata.ILOpCode)">
      <summary>计算指定的分支指令操作数的大小。</summary>
      <param name="opCode">分支操作代码。</param>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支操作代码。</exception>
      <returns>如果 <paramref name="opCode" /> 分支较短，则为 1；如果分支较长，则为 4。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetLongBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>获取指定的分支操作代码的长格式。</summary>
      <param name="opCode">分支操作代码。</param>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支操作代码。</exception>
      <returns>长格式的分支操作代码。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.GetShortBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>获取指定的分支操作代码的短格式。</summary>
      <param name="opCode">分支操作代码。</param>
      <exception cref="T:System.ArgumentException">指定的 <paramref name="opCode" /> 不是分支操作代码。</exception>
      <returns>短格式的分支操作代码。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ILOpCodeExtensions.IsBranch(System.Reflection.Metadata.ILOpCode)">
      <summary>验证指定的操作代码是否是标签的分支。</summary>
      <param name="opCode" />
      <returns>如果指定的操作代码是标签的分支，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImageFormatLimitationException">
      <summary>写入元数据的尝试超过格式规范提供的限制时引发的异常。 例如，超过堆大小限制时。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 类的新实例。</summary>
      <param name="info">承载序列化对象数据的对象。</param>
      <param name="context">关于来源和目标的上下文信息</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String)">
      <summary>用指定的错误消息初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 类的新实例。</summary>
      <param name="message">说明发生此异常的原因的错误消息。</param>
    </member>
    <member name="M:System.Reflection.Metadata.ImageFormatLimitationException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和引发此异常的异常初始化 <see cref="T:System.Reflection.Metadata.ImageFormatLimitationException" /> 类的新实例。</summary>
      <param name="message">说明发生此异常的原因的错误消息。</param>
      <param name="innerException">作为当前异常原因的异常，如果没有指定内部异常，则为 <see langword="null" />。</param>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinition" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Alias" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.Kind" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetAssembly" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetNamespace" />
    <member name="P:System.Reflection.Metadata.ImportDefinition.TargetType" />
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportDefinition}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <exception cref="T:System.BadImageFormatException">blob 格式无效。</exception>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportDefinitionCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportDefinitionKind" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasAssemblyReference" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.AliasType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportAssemblyReferenceAlias" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportNamespace" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportType" />
    <member name="F:System.Reflection.Metadata.ImportDefinitionKind.ImportXmlNamespace" />
    <member name="T:System.Reflection.Metadata.ImportScope">
      <summary>介绍可在其中使用一组导入内容的词法范围。 这些信息存储在调试元数据中。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScope.GetImports" />
    <member name="P:System.Reflection.Metadata.ImportScope.ImportsBlob" />
    <member name="P:System.Reflection.Metadata.ImportScope.Parent" />
    <member name="T:System.Reflection.Metadata.ImportScopeCollection" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ImportScopeHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ImportScopeHandle" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.Equals(System.Reflection.Metadata.ImportScopeHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Equality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ImportScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Implicit(System.Reflection.Metadata.ImportScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ImportScopeHandle.op_Inequality(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.ImportScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ImportScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementation" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
      <summary>获取已实现的接口（<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />）。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandle" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.Equals(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Equality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.InterfaceImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Implicit(System.Reflection.Metadata.InterfaceImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandle.op_Inequality(System.Reflection.Metadata.InterfaceImplementationHandle,System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#InterfaceImplementationHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.InterfaceImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISignatureTypeProvider`2">
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetFunctionPointerType(System.Reflection.Metadata.MethodSignature{`0})">
      <summary>获取给定方法 <paramref name="signature" /> 的函数指针类型的类型符号。</summary>
      <param name="signature" />
      <returns>函数指针类型的类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericMethodParameter(`1,System.Int32)">
      <summary>获取从零开始的给定 <paramref name="index" /> 处的泛型方法参数的类型符号。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>
        <paramref name="index" /> 处的泛型方法参数的类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetGenericTypeParameter(`1,System.Int32)">
      <summary>获取从零开始的给定 <paramref name="index" /> 处的泛型类型参数的类型符号。</summary>
      <param name="genericContext" />
      <param name="index" />
      <returns>从零开始的给定 <paramref name="index" /> 处的泛型类型参数的类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetModifiedType(`0,`0,System.Boolean)">
      <summary>获取已应用自定义修饰符的类型的类型符号。</summary>
      <param name="modifier">已应用的修饰符类型。</param>
      <param name="unmodifiedType">未应用修饰符的基础类型的类型符号。</param>
      <param name="isRequired">如果需要修饰符，则为 <see langword="true" />；如果可选，则为 <see langword="false" />。</param>
      <returns>类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetPinnedType(`0)">
      <summary>获取标记为“已固定”的本地变量类型的类型符号。</summary>
      <param name="elementType" />
      <returns>本地变量类型的类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISignatureTypeProvider`2.GetTypeFromSpecification(System.Reflection.Metadata.MetadataReader,`1,System.Reflection.Metadata.TypeSpecificationHandle,System.Byte)">
      <summary>获取类型规范的类型符号。</summary>
      <param name="reader">传递给签名解码器的元数据读取器。 它可能是 <see langword="null" />。</param>
      <param name="genericContext">传递给签名解码器的上下文。</param>
      <param name="handle">类型规范句柄。</param>
      <param name="rawTypeKind">在签名中指定的类型的种类。 可使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> 来解释此值。</param>
      <returns>类型规范的类型符号。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISimpleTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetPrimitiveType(System.Reflection.Metadata.PrimitiveTypeCode)">
      <summary>获取基元类型的类型符号。</summary>
      <param name="typeCode" />
      <returns>类型符号 <param name="typeCode" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromDefinition(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeDefinitionHandle,System.Byte)">
      <summary>获取类型定义的类型符号。</summary>
      <param name="reader">传递给签名解码器的元数据读取器。 它可能是 <see langword="null" />。</param>
      <param name="handle">类型定义句柄。</param>
      <param name="rawTypeKind">在签名中指定的类型的种类。 可使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> 来解释此值。</param>
      <returns>类型符号。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ISimpleTypeProvider`1.GetTypeFromReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle,System.Byte)">
      <summary>获取类型引用的类型符号。</summary>
      <param name="reader">传递给签名解码器的元数据读取器。 它可能是 <see langword="null" />。</param>
      <param name="handle">类型定义句柄。</param>
      <param name="rawTypeKind">在签名中指定的类型的种类。 可使用 <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" /> 来解释此值。</param>
      <returns>类型符号。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ISZArrayTypeProvider`1">
      <typeparam name="TType" />
    </member>
    <member name="M:System.Reflection.Metadata.ISZArrayTypeProvider`1.GetSZArrayType(`0)">
      <summary>获取一维数组的类型符号，其中该数组是下限为零的给定元素类型。</summary>
      <param name="elementType" />
      <returns>一个 <typeparamref name="TType" /> 实例。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstant">
      <summary>提供有关局部常数的信息。 这些信息存储在调试元数据中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstant.Name" />
    <member name="P:System.Reflection.Metadata.LocalConstant.Signature">
      <summary>获取常数签名。</summary>
      <returns>常量签名。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandle" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.Equals(System.Reflection.Metadata.LocalConstantHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Equality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalConstantHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Implicit(System.Reflection.Metadata.LocalConstantHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandle.op_Inequality(System.Reflection.Metadata.LocalConstantHandle,System.Reflection.Metadata.LocalConstantHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalConstantHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalConstantHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScope">
      <summary>提供有关局部变量和常数范围的信息。 这些信息存储在调试元数据中。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScope.GetChildren" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalConstants" />
    <member name="M:System.Reflection.Metadata.LocalScope.GetLocalVariables" />
    <member name="P:System.Reflection.Metadata.LocalScope.EndOffset" />
    <member name="P:System.Reflection.Metadata.LocalScope.ImportScope" />
    <member name="P:System.Reflection.Metadata.LocalScope.Length" />
    <member name="P:System.Reflection.Metadata.LocalScope.Method" />
    <member name="P:System.Reflection.Metadata.LocalScope.StartOffset" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandle" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.Equals(System.Reflection.Metadata.LocalScopeHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Equality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalScopeHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Implicit(System.Reflection.Metadata.LocalScopeHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandle.op_Inequality(System.Reflection.Metadata.LocalScopeHandle,System.Reflection.Metadata.LocalScopeHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalScopeHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.ChildrenEnumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalScopeHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariable">
      <summary>提供有关局部变量的信息。 这些信息存储在调试元数据中。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariable.Attributes" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Index" />
    <member name="P:System.Reflection.Metadata.LocalVariable.Name" />
    <member name="T:System.Reflection.Metadata.LocalVariableAttributes" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.DebuggerHidden" />
    <member name="F:System.Reflection.Metadata.LocalVariableAttributes.None" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandle" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.Equals(System.Reflection.Metadata.LocalVariableHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Equality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.LocalVariableHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Implicit(System.Reflection.Metadata.LocalVariableHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandle.op_Inequality(System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalVariableHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#LocalVariableHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.LocalVariableHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResource" />
    <member name="M:System.Reflection.Metadata.ManifestResource.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
      <summary>获取清单资源属性。</summary>
      <returns>枚举值的按位组合，这些枚举值指定清单资源特性。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
      <summary>获取实现实体句柄。</summary>
      <returns>EntityHandle 实例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 属性为 <see langword="true" /> ，则返回的句柄将具有默认值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Name">
      <summary>获取资源名称。</summary>
      <returns>资源名称。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
      <summary>获取此资源记录开始处的引用文件内的字节偏移量。</summary>
      <returns>此资源记录所引用的文件中的字节偏移量。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandle" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.Equals(System.Reflection.Metadata.ManifestResourceHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Equality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ManifestResourceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Implicit(System.Reflection.Metadata.ManifestResourceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandle.op_Inequality(System.Reflection.Metadata.ManifestResourceHandle,System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" /> 实例的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ManifestResourceHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ManifestResourceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReference" />
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeFieldSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReference.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
      <summary>确定是方法还是字段的成员引用。</summary>
      <exception cref="T:System.BadImageFormatException">成员引用签名无效。</exception>
      <returns>指示成员引用类型的枚举值之一。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Name" />
    <member name="P:System.Reflection.Metadata.MemberReference.Parent">
      <summary>获取父实体句柄。</summary>
      <returns>实体句柄实例。 如果 <see cref="P:System.Reflection.Metadata.EntityHandle.IsNil" /> 属性为 <see langword="true" /> ，则返回的句柄将具有默认值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReference.Signature">
      <summary>获取签名 blob 的句柄。</summary>
      <returns>签名 blob 的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandle" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.Equals(System.Reflection.Metadata.MemberReferenceHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Equality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MemberReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Implicit(System.Reflection.Metadata.MemberReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandle.op_Inequality(System.Reflection.Metadata.MemberReferenceHandle,System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
      <summary>表示 <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> 实例的集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MemberReferenceHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MemberReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MemberReferenceKind">
      <summary>指定常数，用于指示 <see cref="T:System.Reflection.Metadata.MemberReference" /> 引用方法还是字段。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 引用字段。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 引用方法。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataKind" />
    <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
      <summary>CLI 元数据。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
      <summary>由托管编译器生成的 Windows 元数据。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
      <summary>Windows 元数据。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReader">
      <summary>读取 ECMA 335 CLI 规范定义的元数据。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
      <summary>从存储在给定内存位置的元数据初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 类的新实例。</summary>
      <param name="metadata">指向元数据块中的第一个字节的指针。</param>
      <param name="length">块中的字节数。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>从存储在给定内存位置的元数据初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 类的新实例。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>从存储在给定内存位置的元数据初始化 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 类的新实例。</summary>
      <param name="metadata" />
      <param name="length" />
      <param name="options" />
      <param name="utf8Decoder" />
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> 不是正数值。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="metadata" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的编码不是 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台是大端。</exception>
      <exception cref="T:System.BadImageFormatException">错误的元数据头。</exception>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyFile(System.Reflection.Metadata.AssemblyFileHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetAssemblyReference(System.Reflection.Metadata.AssemblyReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobBytes(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobContent(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.BlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetBlobReader(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetConstant(System.Reflection.Metadata.ConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttribute(System.Reflection.Metadata.CustomAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomAttributes(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.CustomDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetCustomDebugInformation(System.Reflection.Metadata.EntityHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDeclarativeSecurityAttribute(System.Reflection.Metadata.DeclarativeSecurityAttributeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetDocument(System.Reflection.Metadata.DocumentHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetEventDefinition(System.Reflection.Metadata.EventDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetExportedType(System.Reflection.Metadata.ExportedTypeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetFieldDefinition(System.Reflection.Metadata.FieldDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameter(System.Reflection.Metadata.GenericParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGenericParameterConstraint(System.Reflection.Metadata.GenericParameterConstraintHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetGuid(System.Reflection.Metadata.GuidHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetImportScope(System.Reflection.Metadata.ImportScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetInterfaceImplementation(System.Reflection.Metadata.InterfaceImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalConstant(System.Reflection.Metadata.LocalConstantHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScope(System.Reflection.Metadata.LocalScopeHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalScopes(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetLocalVariable(System.Reflection.Metadata.LocalVariableHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetManifestResource(System.Reflection.Metadata.ManifestResourceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMemberReference(System.Reflection.Metadata.MemberReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodDefinition(System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodImplementation(System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetMethodSpecification(System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleDefinition" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetModuleReference(System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinition(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetNamespaceDefinitionRoot" />
    <member name="M:System.Reflection.Metadata.MetadataReader.GetParameter(System.Reflection.Metadata.ParameterHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetPropertyDefinition(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetStandaloneSignature(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.DocumentNameBlobHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetString(System.Reflection.Metadata.StringHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeDefinition(System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeReference(System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetTypeSpecification(System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReader.GetUserString(System.Reflection.Metadata.UserStringHandle)">
      <param name="handle" />
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyFiles" />
    <member name="P:System.Reflection.Metadata.MetadataReader.AssemblyReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.CustomDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.DebugMetadataHeader">
      <summary>获取从 #Pdb 流解码的信息；如果流不存在，则为 <see langword="null" />。</summary>
      <returns>从 #Pdb 流解码的信息，如果流不存在，则为 <see langword="null" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.DeclarativeSecurityAttributes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Documents" />
    <member name="P:System.Reflection.Metadata.MetadataReader.EventDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.FieldDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ImportScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.IsAssembly">
      <summary>获取用于指示元数据是否表示程序集的值。</summary>
      <returns>
        <see langword="true" /> 如果元数据表示程序集，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalConstants" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalScopes" />
    <member name="P:System.Reflection.Metadata.MetadataReader.LocalVariables" />
    <member name="P:System.Reflection.Metadata.MetadataReader.ManifestResources" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MemberReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataKind">
      <summary>获取元数据类型。</summary>
      <returns>用于指定元数据类型的枚举值之一。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataLength">
      <summary>获取基础数据的长度。</summary>
      <returns>基础数据的长度。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataPointer">
      <summary>获取指向基础数据的指针。</summary>
      <returns>指向基础数据的指针。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MetadataVersion">
      <summary>获取从元数据头读取的版本字符串。</summary>
      <returns>从 metadata 标头读取的版本字符串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDebugInformation" />
    <member name="P:System.Reflection.Metadata.MetadataReader.MethodDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.Options">
      <summary>获取传递给构造函数的 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />。</summary>
      <returns>枚举值的按位组合，用于描述 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 枚举值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.PropertyDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.StringComparer">
      <summary>获取用于比较存储在元数据中的字符串的比较器。</summary>
      <returns>用于比较存储在元数据中的字符串的比较器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeDefinitions" />
    <member name="P:System.Reflection.Metadata.MetadataReader.TypeReferences" />
    <member name="P:System.Reflection.Metadata.MetadataReader.UTF8Decoder">
      <summary>获取读取器用于从 UTF8 编码的字节序列生成字符串实例的解码器。</summary>
      <returns>读取器用于从 UTF8 编码的字节序列生成字符串实例的解码器。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderOptions" />
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
      <summary>启用 Windows 运行时预测（默认启用）。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
      <summary>当 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 是通过不带 <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" /> 参数的重载来获取时所使用的选项。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
      <summary>所有选项均处于禁用状态。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataReaderProvider">
      <summary>为存储在字节数组、内存块或流中的元数据提供 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose">
      <summary>释放由读取器分配的所有内存。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)">
      <summary>基于内存中存储的映像创建元数据提供程序。</summary>
      <param name="start">指向元数据 blob 开头的指针。</param>
      <param name="size">元数据 blob 的大小。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负数。</exception>
      <returns>新的元数据提供程序。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>基于字节数组创建提供程序。</summary>
      <param name="image">元数据映像。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> 为 <see langword="null" />。</exception>
      <returns>新的提供程序。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>为具有指定大小且从其当前位置开头的流创建提供程序。</summary>
      <param name="stream">一个 <see cref="T:System.IO.Stream" /> 实例。</param>
      <param name="options">用于指定如何从流中读取映像分区的选项。</param>
      <param name="size">流中的元数据 blob 大小。 如果未指定，则假定元数据 blob 横跨到流的结尾。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> 不支持读取和查找操作。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">大小为负，或者扩展超出了流的末尾。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错（仅在指定 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> 时读取）。</exception>
      <returns>新的提供程序。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)">
      <summary>基于内存中存储的 blob 创建可移植的 PDB 元数据提供程序。</summary>
      <param name="start">指向可移植的 PDB blob 开头的指针。</param>
      <param name="size">可移植的 PDB blob 的大小。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负数。</exception>
      <returns>新的可移植的 PDB 元数据提供程序。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>基于字节数组创建可移植的 PDB 元数据提供程序。</summary>
      <param name="image">可移植的 PDB 映像。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="image" /> 为 <see langword="null" />。</exception>
      <returns>新的可移植的 PDB 元数据提供程序。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbStream(System.IO.Stream,System.Reflection.Metadata.MetadataStreamOptions,System.Int32)">
      <summary>为具有指定大小且从其当前位置开头的流创建提供程序。</summary>
      <param name="stream">流。</param>
      <param name="options">用于指定如何从流中读取映像分区的选项。</param>
      <param name="size">流中的元数据 blob 大小。 如果未指定，则假定元数据 blob 横跨到流的结尾。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> 不支持读取和查找操作。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">大小为负，或者扩展超出了流的末尾。</exception>
      <returns>一个 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 实例。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataReaderProvider.GetMetadataReader(System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>从 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 中获取一个 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
      <param name="options">枚举值的按位组合，这些值表示读取元数据时的配置。</param>
      <param name="utf8Decoder">要使用的编码。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的编码不是 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台是大端。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放提供程序。</exception>
      <returns>一个 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 实例。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStreamOptions" />
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.Default">
      <summary>默认情况下，当释放 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 并且延迟读取 PE 图像的部分时，系统会将流释放。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen">
      <summary>在释放 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 时将流保持为开放状态。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata">
      <summary>
        <para>立即将 PDB 元数据读入内存。</para>
        <para>构造 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 之后，基础文件可能会关闭，甚至被删除。 除非指定了 <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" />，否则 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 会在构造函数返回时自动关闭流。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringComparer">
      <summary>提供字符串比较帮助程序以查询元数据中的字符串，同时尽可能避免分配。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.DocumentNameBlobHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.Equals(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String)">
      <param name="handle" />
      <param name="value" />
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringComparer.StartsWith(System.Reflection.Metadata.StringHandle,System.String,System.Boolean)">
      <param name="handle" />
      <param name="value" />
      <param name="ignoreCase" />
    </member>
    <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
      <summary>为 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 提供一种自定义机制，用于解码表示文本的元数据中的字节序列。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
      <summary>使用给定的编码初始化 <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> 类的新实例。</summary>
      <param name="encoding">要使用的编码。</param>
    </member>
    <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
      <summary>获取元数据中字节序列的字符串。 如果需要，请替代此项以缓存字符串。 否则，它会通过直接转到 <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" /> 来实现，并且每次调用都将分配一个新字符串。</summary>
      <param name="bytes">指向要解码的字节的指针。</param>
      <param name="byteCount">要解码的字节数。</param>
      <returns>已解码的字符串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
      <summary>在未向构造函数提供解码器时，获取 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 解码 UTF-8 所使用的默认解码器。</summary>
      <returns>用于解码 UTF-8 的默认解码器 <see cref="T:System.Reflection.Metadata.MetadataReader" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
      <summary>获取此实例使用的编码。</summary>
      <returns>此实例使用的编码。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodBodyBlock" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.Create(System.Reflection.Metadata.BlobReader)">
      <param name="reader" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILBytes" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILContent" />
    <member name="M:System.Reflection.Metadata.MethodBodyBlock.GetILReader" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.ExceptionRegions" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalSignature" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.LocalVariablesInitialized" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.MaxStack" />
    <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
      <summary>获取方法主体的大小，包括标头、IL 和异常区域。</summary>
      <returns>方法体的大小。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformation">
      <summary>提供与方法定义关联的调试信息。 这些信息存储在调试元数据中。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints">
      <summary>返回从 <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" /> 中解码的序列点的集合。</summary>
      <returns>序列点的集合。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformation.GetStateMachineKickoffMethod">
      <summary>返回状态机的开始方法。</summary>
      <returns>如果方法是状态机的 <c>MoveNext</c> 方法，则为状态机的开始方法。 否则，它将返回其 <see cref="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" /> 属性为 <see langword="true" /> 的句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.Document">
      <summary>获取单个文档的句柄，其中该文档包含方法的所有序列点。</summary>
      <returns>单个文档的句柄，其中包含方法的所有序列点; <see cref="P:System.Reflection.Metadata.DocumentHandle.IsNil" /><see langword="true" /> 如果该方法没有序列点或跨越多个文档，则为其属性为的句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.LocalSignature">
      <summary>返回本地签名句柄。</summary>
      <returns>本地签名句柄，或者， <see cref="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" /><see langword="true" /> 如果该方法未定义任何局部变量，则为其属性为的句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob">
      <summary>返回 blob 编码序列点。</summary>
      <returns>Blob 编码序列点，或者 <see cref="P:System.Reflection.Metadata.BlobHandle.IsNil" /><see langword="true" /> 如果该方法没有序列点，则为其属性为的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandle" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.Equals(System.Reflection.Metadata.MethodDebugInformationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Equality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDebugInformationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Implicit(System.Reflection.Metadata.MethodDebugInformationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.op_Inequality(System.Reflection.Metadata.MethodDebugInformationHandle,System.Reflection.Metadata.MethodDebugInformationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandle.ToDefinitionHandle">
      <summary>将句柄返回到与此句柄相对应的 <see cref="T:System.Reflection.Metadata.MethodDefinition" />。</summary>
      <returns>与此句柄相对应的方法定义句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDebugInformationHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDebugInformationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinition" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetDeclaringType" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetImport" />
    <member name="M:System.Reflection.Metadata.MethodDefinition.GetParameters" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.ImplAttributes" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Name" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.RelativeVirtualAddress" />
    <member name="P:System.Reflection.Metadata.MethodDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.Equals(System.Reflection.Metadata.MethodDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Equality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Implicit(System.Reflection.Metadata.MethodDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.op_Inequality(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandle.ToDebugInformationHandle">
      <summary>将句柄返回到与此句柄相对应的 <see cref="T:System.Reflection.Metadata.MethodDebugInformation" />。</summary>
      <returns>与此句柄相对应的方法调试信息句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodDefinitionHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementation" />
    <member name="M:System.Reflection.Metadata.MethodImplementation.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodBody" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.MethodDeclaration" />
    <member name="P:System.Reflection.Metadata.MethodImplementation.Type" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandle" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.Equals(System.Reflection.Metadata.MethodImplementationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Equality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodImplementationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Implicit(System.Reflection.Metadata.MethodImplementationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandle.op_Inequality(System.Reflection.Metadata.MethodImplementationHandle,System.Reflection.Metadata.MethodImplementationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#MethodImplementationHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodImplementationHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodImport" />
    <member name="P:System.Reflection.Metadata.MethodImport.Attributes" />
    <member name="P:System.Reflection.Metadata.MethodImport.Module" />
    <member name="P:System.Reflection.Metadata.MethodImport.Name" />
    <member name="T:System.Reflection.Metadata.MethodSignature`1">
      <summary>表示方法（定义、引用或独立）签名或属性签名。 如果是属性签名，则签名与具有不同 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 的 Getter 的签名相匹配。</summary>
      <typeparam name="TType">方法类型。</typeparam>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSignature`1.#ctor(System.Reflection.Metadata.SignatureHeader,`0,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{`0})">
      <summary>使用指定的标头、返回类型和参数信息初始化 <see cref="T:System.Reflection.Metadata.MethodSignature`1" /> 结构的新实例。</summary>
      <param name="header">签名的前导字节中的信息（种类、调用约定、标志）。</param>
      <param name="returnType">方法的返回类型。</param>
      <param name="requiredParameterCount">所需参数的数目。</param>
      <param name="genericParameterCount">泛型类型参数的数目。</param>
      <param name="parameterTypes">参数类型。</param>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.GenericParameterCount">
      <summary>获取方法的泛型类型参数的数目。</summary>
      <returns>泛型类型参数的数量; 对于非泛型方法，则为0。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.Header">
      <summary>获取签名的前导字节中的信息（种类、调用约定、标志）。</summary>
      <returns>标头签名。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes">
      <summary>获取方法的参数类型。</summary>
      <returns>参数类型的不可变集合。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.RequiredParameterCount">
      <summary>获取方法所需的参数数目。</summary>
      <returns>所需参数的数目。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSignature`1.ReturnType">
      <summary>获取方法的返回类型。</summary>
      <returns>返回类型。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecification" />
    <member name="M:System.Reflection.Metadata.MethodSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
      <summary>获取 <see langword="MethodDef" /> 或 <see langword="MemberRef" /> 句柄，它指定此实例引用的泛型方法（即，它是哪泛型方法的实例化）。</summary>
      <returns>
        <see langword="MethodDef" />
        <see langword="MemberRef" /> 指定此实例引用的泛型方法的或句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
      <summary>获取签名 blob 的句柄。</summary>
      <returns>签名 blob 的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.MethodSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.Equals(System.Reflection.Metadata.MethodSpecificationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Equality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.MethodSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Implicit(System.Reflection.Metadata.MethodSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.MethodSpecificationHandle.op_Inequality(System.Reflection.Metadata.MethodSpecificationHandle,System.Reflection.Metadata.MethodSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.MethodSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleDefinition" />
    <member name="M:System.Reflection.Metadata.ModuleDefinition.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.BaseGenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Generation" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.GenerationId" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Mvid" />
    <member name="P:System.Reflection.Metadata.ModuleDefinition.Name" />
    <member name="T:System.Reflection.Metadata.ModuleDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.Equals(System.Reflection.Metadata.ModuleDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Equality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Implicit(System.Reflection.Metadata.ModuleDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleDefinitionHandle.op_Inequality(System.Reflection.Metadata.ModuleDefinitionHandle,System.Reflection.Metadata.ModuleDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ModuleReference" />
    <member name="M:System.Reflection.Metadata.ModuleReference.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.ModuleReference.Name" />
    <member name="T:System.Reflection.Metadata.ModuleReferenceHandle" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.Equals(System.Reflection.Metadata.ModuleReferenceHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Equality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ModuleReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Implicit(System.Reflection.Metadata.ModuleReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ModuleReferenceHandle.op_Inequality(System.Reflection.Metadata.ModuleReferenceHandle,System.Reflection.Metadata.ModuleReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ModuleReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.NamespaceDefinition" />
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
      <summary>获取直接驻留在命名空间中的所有已导出的类型。</summary>
      <returns>导出的类型句柄的不可变数组。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
      <summary>获取命令空间定义的非限定的名称。</summary>
      <returns>命名空间定义的非限定名称。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
      <summary>获取属于当前命名空间定义的直接子级的命名空间定义。</summary>
      <returns>命名空间定义的不可变数组，它是当前命名空间定义的直接子级。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
      <summary>获取父级命名空间。</summary>
      <returns>父命名空间。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
      <summary>获取直接驻留在命名空间中的所有类型定义。</summary>
      <returns>类型定义处理的不可变数组。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
      <summary>提供命名空间定义的句柄。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.Equals(System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Equality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.NamespaceDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Implicit(System.Reflection.Metadata.NamespaceDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.NamespaceDefinitionHandle.op_Inequality(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.NamespaceDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.Parameter" />
    <member name="M:System.Reflection.Metadata.Parameter.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.Parameter.GetDefaultValue" />
    <member name="M:System.Reflection.Metadata.Parameter.GetMarshallingDescriptor" />
    <member name="P:System.Reflection.Metadata.Parameter.Attributes" />
    <member name="P:System.Reflection.Metadata.Parameter.Name" />
    <member name="P:System.Reflection.Metadata.Parameter.SequenceNumber" />
    <member name="T:System.Reflection.Metadata.ParameterHandle" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.Equals(System.Reflection.Metadata.ParameterHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Equality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.ParameterHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Implicit(System.Reflection.Metadata.ParameterHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandle.op_Inequality(System.Reflection.Metadata.ParameterHandle,System.Reflection.Metadata.ParameterHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
      <summary>包含指定方法的参数集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#ParameterHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ParameterHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ParameterHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PEReaderExtensions" />
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
      <summary>从 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 中获取一个 <see cref="T:System.Reflection.Metadata.MetadataReader" />。</summary>
      <param name="peReader">当前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 实例。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台是大端。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <returns>元数据读取器。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
      <summary>获取元数据读取器，其中包含 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 中指定的元数据读取配置。</summary>
      <param name="peReader">当前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 实例。</param>
      <param name="options">一个表示元数据读取配置的枚举值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台是大端。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <returns>一个元数据读取器，其中包含指定的元数据读取配置。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
      <summary>获取元数据读取器，其中包含 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 中指定的的元数据读取配置和编码配置。</summary>
      <param name="peReader">当前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 实例。</param>
      <param name="options">一个表示元数据读取配置的枚举值。</param>
      <param name="utf8Decoder">一个包含编码配置的元数据字符串解码器。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="utf8Decoder" /> 的编码不是 <see cref="T:System.Text.UTF8Encoding" />。</exception>
      <exception cref="T:System.PlatformNotSupportedException">当前平台是大端。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <returns>&gt; 一个元数据读取器，其中包含指定的元数据读取配置和编码配置。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
      <summary>返回方法的主体块，其中包含指定的相对虚拟地址 (RVA)；</summary>
      <param name="peReader">当前的 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 实例。</param>
      <param name="relativeVirtualAddress">相对虚拟地址 (RVA)。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peReader" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.BadImageFormatException">未在元数据中找到主体或主体无效。</exception>
      <exception cref="T:System.InvalidOperationException">存储此方法的部分不可用。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <returns>方法块主体实例。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveSerializationTypeCode">
      <summary>指定常数，用于定义类型代码，这些类型用于编码 <see cref="T:System.Reflection.Metadata.CustomAttribute" /> 值 Blob 中基元值的类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Byte">
      <summary>1 字节无符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Double">
      <summary>8 字节浮点类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int16">
      <summary>2 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int32">
      <summary>4 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Int64">
      <summary>8 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.SByte">
      <summary>1 字节有符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.Single">
      <summary>4 字节浮点类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt16">
      <summary>2 字节无符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt32">
      <summary>4 字节无符号整数类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveSerializationTypeCode.UInt64">
      <summary>8 字节无符号整数类型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PrimitiveTypeCode">
      <summary>指定常数，用于定义元数据签名中找到的基元类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Boolean">
      <summary>
        <see cref="T:System.Boolean" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Byte">
      <summary>
        <see cref="T:System.Byte" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Char">
      <summary>
        <see cref="T:System.Char" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Double">
      <summary>
        <see cref="T:System.Double" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int16">
      <summary>
        <see cref="T:System.Int16" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int32">
      <summary>
        <see cref="T:System.Int32" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Int64">
      <summary>
        <see cref="T:System.Int64" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.IntPtr">
      <summary>
        <see cref="T:System.IntPtr" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Object">
      <summary>
        <see cref="T:System.Object" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.SByte">
      <summary>
        <see cref="T:System.SByte" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Single">
      <summary>
        <see cref="T:System.Single" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.String">
      <summary>
        <see cref="T:System.String" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference">
      <summary>类型化的引用。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt16">
      <summary>
        <see cref="T:System.UInt16" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt32">
      <summary>
        <see cref="T:System.UInt32" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UInt64">
      <summary>
        <see cref="T:System.UInt64" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.UIntPtr">
      <summary>
        <see cref="T:System.UIntPtr" /> 类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.PrimitiveTypeCode.Void">
      <summary>
        <see cref="T:System.Void" /> 类型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyAccessors" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Getter" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Others" />
    <member name="P:System.Reflection.Metadata.PropertyAccessors.Setter" />
    <member name="T:System.Reflection.Metadata.PropertyDefinition" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetAccessors" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.PropertyDefinition.GetDefaultValue" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Name" />
    <member name="P:System.Reflection.Metadata.PropertyDefinition.Signature" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.Equals(System.Reflection.Metadata.PropertyDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Equality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.PropertyDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Implicit(System.Reflection.Metadata.PropertyDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandle.op_Inequality(System.Reflection.Metadata.PropertyDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#PropertyDefinitionHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.PropertyDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.ReservedBlob`1">
      <summary>表示为将来的内容更新保留的元数据堆上的句柄和相应的 blob。</summary>
      <typeparam name="THandle" />
    </member>
    <member name="M:System.Reflection.Metadata.ReservedBlob`1.CreateWriter">
      <summary>返回用于更新内容的 <see cref="T:System.Reflection.Metadata.BlobWriter" />。</summary>
      <returns>用于更新内容的 blob 编写器。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Content" />
    <member name="P:System.Reflection.Metadata.ReservedBlob`1.Handle">
      <summary>获取保留的 blob 句柄。</summary>
      <returns>保留的阻止句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePoint" />
    <member name="F:System.Reflection.Metadata.SequencePoint.HiddenLine" />
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.Equals(System.Reflection.Metadata.SequencePoint)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePoint.GetHashCode" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Document" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.EndLine" />
    <member name="P:System.Reflection.Metadata.SequencePoint.IsHidden" />
    <member name="P:System.Reflection.Metadata.SequencePoint.Offset" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartColumn" />
    <member name="P:System.Reflection.Metadata.SequencePoint.StartLine" />
    <member name="T:System.Reflection.Metadata.SequencePointCollection" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#SequencePoint}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SequencePointCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SequencePointCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SerializationTypeCode">
      <summary>指定类型代码，用于对 <see cref="T:System.Reflection.Metadata.CustomAttributeValue`1" /> Blob 中的值类型进行编码。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
      <summary>特性参数是一个 Enum 实例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
      <summary>特性参数进行了“装箱”（传递到参数、字段或类型对象的属性）并传送特性 Blob 中的类型信息。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
      <summary>特性参数是一个 <see cref="T:System.Type" /> 实例。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32" /> 的值。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
      <summary>等效于 <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64" /> 的值。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureAttributes">
      <summary>指定其他可应用于方法签名的标志。 此类型中字段的基础值对应于 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构表示的前导签名字节中的表示形式。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
      <summary>指示表示实例指针的第一个显式声明的参数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
      <summary>泛型方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
      <summary>实例方法。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
      <summary>无标志。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
      <summary>指定给定签名中的参数如何从调用方传递到被调用方。 此类型中字段的基础值对应于 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构表示的前导签名字节中的表示形式。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
      <summary>一个非托管 C/C++ 样式调用约定，其中调用堆栈由调用方清理。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
      <summary>托管调用约定，具有固定长度参数列表。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
      <summary>非托管调用约定，其中会在可能的情况下将参数传递到寄存器中。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
      <summary>一个非托管调用约定，其中调用堆栈由被调用方清理。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
      <summary>非托管 C++ 样式调用约定，具有固定参数列表，用于调用实例成员函数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Unmanaged">
      <summary>指示将非托管调用约定的详细信息编码为 modopt。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
      <summary>托管调用约定，用于传递额外参数。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureHeader">
      <summary>表示由签名 Blob 的前导字节指定的签名特征。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask">
      <summary>获取调用约定或签名种类的掩码值。 默认的 <see cref="F:System.Reflection.Metadata.SignatureHeader.CallingConventionOrKindMask" /> 值为 15 (0x0F)。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Byte)">
      <summary>使用指定的字节值初始化 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构的新实例。</summary>
      <param name="rawValue">字节。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.#ctor(System.Reflection.Metadata.SignatureKind,System.Reflection.Metadata.SignatureCallingConvention,System.Reflection.Metadata.SignatureAttributes)">
      <summary>使用指定的签名种类、调用约定和签名特性初始化 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构的新实例。</summary>
      <param name="kind">签名种类。</param>
      <param name="convention">调用约定。</param>
      <param name="attributes">签名特性。</param>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Object)">
      <summary>将指定的对象与此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 进行比较，判断二者之间的相等性。</summary>
      <param name="obj">要比较的对象。</param>
      <returns>如果对象相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.Equals(System.Reflection.Metadata.SignatureHeader)">
      <summary>比较两个 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值以判断是否相等。</summary>
      <param name="other">要比较的值。</param>
      <returns>如果值相等，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.GetHashCode">
      <summary>获取当前对象的哈希代码。</summary>
      <returns>当前对象的哈希代码。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Equality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>比较两个 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值以判断是否相等。</summary>
      <param name="left">要比较的第一个值。</param>
      <param name="right">要比较的第二个值。</param>
      <returns>如果值相等，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.op_Inequality(System.Reflection.Metadata.SignatureHeader,System.Reflection.Metadata.SignatureHeader)">
      <summary>确定两个 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 值是否不相等。</summary>
      <param name="left">要比较的第一个值。</param>
      <param name="right">要比较的第二个值。</param>
      <returns>如果两个值不相等，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.SignatureHeader.ToString">
      <summary>返回表示当前对象的字符串。</summary>
      <returns>表示当前对象的字符串。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Attributes">
      <summary>获取签名特性。</summary>
      <returns>属性。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.CallingConvention">
      <summary>获取调用约定。</summary>
      <returns>调用约定。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.HasExplicitThis">
      <summary>获取一个值，该值指示此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 签名特性。</summary>
      <returns>
        <see langword="true" /> 如果 <see cref="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis" /> 特性存在，则为; 否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsGeneric">
      <summary>获取一个值，该值指示此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 签名特性。</summary>
      <returns>
        <see langword="true" /> 如果 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Generic" /> 特性存在，则为; 否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.IsInstance">
      <summary>获取一个值，该值指示此 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构是否具有 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 签名特性。</summary>
      <returns>
        <see langword="true" /> 如果 <see cref="F:System.Reflection.Metadata.SignatureAttributes.Instance" /> 特性存在，则为; 否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.Kind">
      <summary>获取签名种类。</summary>
      <returns>签名种类。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.SignatureHeader.RawValue">
      <summary>获取标头字节的原始值。</summary>
      <returns>标头字节的原始值。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureKind">
      <summary>指定签名种类。 此类型中字段的基础值对应于 <see cref="T:System.Reflection.Metadata.SignatureHeader" /> 结构表示的前导签名字节中的表示形式。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Field">
      <summary>字段签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
      <summary>局部变量签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Method">
      <summary>方法引用、方法定义或独立方法签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
      <summary>方法规范签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureKind.Property">
      <summary>属性签名。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeCode">
      <summary>指定常数，用于定义签名编码中使用的类型代码。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
      <summary>表示签名中的通用 <see cref="T:System.Array" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
      <summary>表示签名中的 <see cref="T:System.Boolean" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
      <summary>表示签名中的托管指针（byref 返回值和参数）。 在 Blob 中，其后跟基础类型的签名编码。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
      <summary>表示签名中的 <see cref="T:System.Byte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
      <summary>表示签名中的 <see cref="T:System.Char" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
      <summary>表示签名中的 <see cref="T:System.Double" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
      <summary>表示签名中的函数指针类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
      <summary>表示签名中使用的泛型方法参数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
      <summary>表示签名中泛型类型的实例化。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
      <summary>表示签名中使用的泛型类型参数。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
      <summary>表示签名中的 <see cref="T:System.Int16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
      <summary>表示签名中的 <see cref="T:System.Int32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
      <summary>表示签名中的 <see cref="T:System.Int64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
      <summary>表示签名中的 <see cref="T:System.IntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
      <summary>表示一个无效的或未初始化的类型代码。 它不会在有效签名中显示。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
      <summary>表示签名中的 <see cref="T:System.Object" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
      <summary>表示自定义修饰符，应用于调用方可忽略的签名中的类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
      <summary>表示由垃圾回收器固定的局部变量。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
      <summary>表示签名中的非托管指针。 在 Blob 中，其后跟基础类型的签名编码。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
      <summary>表示自定义修饰符，应用于调用方必须理解的签名中的类型。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
      <summary>表示签名中的 <see cref="T:System.SByte" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
      <summary>表示一个标记，用于指示固定参数的结束和可变参数的开头。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
      <summary>表示签名中的 <see cref="T:System.Single" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
      <summary>表示签名中的 <see cref="T:System.String" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
      <summary>表示一维 <see cref="T:System.Array" />，其下限为 0。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
      <summary>表示签名中的类型化引用。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
      <summary>位于签名中的类型 <see cref="T:System.Reflection.Metadata.EntityHandle" /> 之前。 在原始元数据中，它编码为 ELEMENT_TYPE_CLASS (0x12)（针对引用类型）或 ELEMENT_TYPE_VALUETYPE (0x11)（针对值类型）。 这折叠成为单个代码，因为 Windows 运行时投射可从类投射到值类型（反之亦然），而原始代码在这些情况下具有误导性。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
      <summary>表示签名中的 <see cref="T:System.UInt16" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
      <summary>表示签名中的 <see cref="T:System.UInt32" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
      <summary>表示签名中的 <see cref="T:System.UInt64" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
      <summary>表示签名中的 <see cref="T:System.UIntPtr" />。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
      <summary>表示签名中的 <see cref="T:System.Void" />。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.SignatureTypeKind">
      <summary>指示签名的类型定义。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Class">
      <summary>类型定义或类型引用会引用类。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.Unknown">
      <summary>如果类型引用或定义为类或值类型，则在当前上下文中为未知状态。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.SignatureTypeKind.ValueType">
      <summary>类型定义或类型引用会引用值类型。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignature" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeLocalSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.DecodeMethodSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.StandaloneSignature.GetKind">
      <summary>确定签名类型，它可以是 <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> 或 <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />。</summary>
      <exception cref="T:System.BadImageFormatException">签名无效。</exception>
      <returns>表示签名类型的枚举值。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignature.Signature">
      <summary>获取签名 blob 的句柄。</summary>
      <returns>签名 blob 的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.StandaloneSignatureHandle" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.Equals(System.Reflection.Metadata.StandaloneSignatureHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Equality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StandaloneSignatureHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Implicit(System.Reflection.Metadata.StandaloneSignatureHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StandaloneSignatureHandle.op_Inequality(System.Reflection.Metadata.StandaloneSignatureHandle,System.Reflection.Metadata.StandaloneSignatureHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StandaloneSignatureHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.StandaloneSignatureKind">
      <summary>指示 <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 是表示独立方法还是局部变量签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.LocalVariables">
      <summary>
        <see cref="T:System.Reflection.Metadata.MemberReference" /> 应用局部变量签名。</summary>
    </member>
    <member name="F:System.Reflection.Metadata.StandaloneSignatureKind.Method">
      <summary>
        <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> 表示独立方法签名。</summary>
    </member>
    <member name="T:System.Reflection.Metadata.StringHandle" />
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.Equals(System.Reflection.Metadata.StringHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.StringHandle.op_Equality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.StringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Implicit(System.Reflection.Metadata.StringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.StringHandle.op_Inequality(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.StringHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinition" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetCustomAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclarativeSecurityAttributes" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
      <summary>返回指定的嵌套类型的封闭类型。</summary>
      <returns>指定嵌套类型的封闭类型；如果类型未嵌套，则为其 <see cref="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" /> 属性是 <see langword="true" /> 的句柄。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetEvents" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetFields" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetGenericParameters" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetInterfaceImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetLayout" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethodImplementations" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetMethods" />
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
      <summary>返回指定类型中嵌套的类型的数组。</summary>
      <returns>类型定义句柄的不可变数组，它表示在指定类型中嵌套的类型。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinition.GetProperties" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.Attributes" />
    <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
      <summary>获取类型定义的基类型：<see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />、<see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 或 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />。</summary>
      <returns>类型定义的基类型。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.IsNested">
      <summary>获取一个值，该值表示这是嵌套类型。</summary>
      <returns>
        <see langword="true" /> 如果是嵌套类型，则为 <see langword="false" /> ; 否则为。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
      <summary>获取类型的名称。</summary>
      <returns>类型的名称。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
      <summary>获取在其中定义类型的命名空间的全名。</summary>
      <returns>定义类型的命名空间的完整名称，或者， <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /><see langword="true" /> 如果该类型是嵌套的或在根命名空间中定义的，则为其属性为的句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
      <summary>获取在其中定义类型的命名空间的定义句柄。</summary>
      <returns>定义类型的命名空间的定义句柄，或者， <see cref="P:System.Reflection.Metadata.NamespaceDefinitionHandle.IsNil" /><see langword="true" />  如果该类型是嵌套的或在根命名空间中定义的，则为其属性为的句柄。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandle" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.Equals(System.Reflection.Metadata.TypeDefinitionHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Equality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeDefinitionHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Implicit(System.Reflection.Metadata.TypeDefinitionHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandle.op_Inequality(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
      <summary>包含一个 <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> 实例集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeDefinitionHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeDefinitionHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeLayout" />
    <member name="M:System.Reflection.Metadata.TypeLayout.#ctor(System.Int32,System.Int32)">
      <param name="size" />
      <param name="packingSize" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeLayout.IsDefault" />
    <member name="P:System.Reflection.Metadata.TypeLayout.PackingSize" />
    <member name="P:System.Reflection.Metadata.TypeLayout.Size" />
    <member name="T:System.Reflection.Metadata.TypeReference" />
    <member name="P:System.Reflection.Metadata.TypeReference.Name">
      <summary>获取目标类型的名称。</summary>
      <returns>目标类型的名称。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
      <summary>获取在其中定义目标类型的命名空间的全名。</summary>
      <returns>定义目标类型的命名空间的完整名称，或者， <see cref="P:System.Reflection.Metadata.StringHandle.IsNil" /><see langword="true" /> 如果在根命名空间中嵌套或定义了该类型，则为其属性为的句柄。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
      <summary>获取解析范围，目标类型在该范围内定义且由指定的 <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> 和 <see cref="P:System.Reflection.Metadata.TypeReference.Name" /> 唯一标识。</summary>
      <returns>用于唯一定义目标类型的解析范围。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandle" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.Equals(System.Reflection.Metadata.TypeReferenceHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Equality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeReferenceHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Implicit(System.Reflection.Metadata.TypeReferenceHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandle.op_Inequality(System.Reflection.Metadata.TypeReferenceHandle,System.Reflection.Metadata.TypeReferenceHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
      <summary>包含一个 <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> 实例集合。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.GetEnumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#Generic#IEnumerable{System#Reflection#Metadata#TypeReferenceHandle}#GetEnumerator">
      <summary>返回一个循环访问集合的枚举器。</summary>
      <returns>用于循环访问集合的枚举数。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Count">
      <summary>获取集合中的元素数。</summary>
      <returns>集合中的元素数。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator" />
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.MoveNext">
      <summary>将枚举数推进到集合的下一个元素。</summary>
      <returns>如果枚举数已成功地推进到下一个元素，则为 <see langword="true" />；如果枚举数传递到集合的末尾，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#IDisposable#Dispose">
      <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="P:System.Reflection.Metadata.TypeReferenceHandleCollection.Enumerator.System#Collections#IEnumerator#Current">
      <summary>获取集合中位于枚举数当前位置的元素。</summary>
      <returns>集合中位于枚举数当前位置的元素。</returns>
    </member>
    <member name="T:System.Reflection.Metadata.TypeSpecification" />
    <member name="M:System.Reflection.Metadata.TypeSpecification.DecodeSignature``2(System.Reflection.Metadata.ISignatureTypeProvider{``0,``1},``1)">
      <param name="provider" />
      <param name="genericContext" />
      <typeparam name="TType" />
      <typeparam name="TGenericContext" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecification.GetCustomAttributes" />
    <member name="P:System.Reflection.Metadata.TypeSpecification.Signature" />
    <member name="T:System.Reflection.Metadata.TypeSpecificationHandle" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.Equals(System.Reflection.Metadata.TypeSpecificationHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Equality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.EntityHandle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.TypeSpecificationHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.EntityHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Implicit(System.Reflection.Metadata.TypeSpecificationHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.TypeSpecificationHandle.op_Inequality(System.Reflection.Metadata.TypeSpecificationHandle,System.Reflection.Metadata.TypeSpecificationHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.TypeSpecificationHandle.IsNil" />
    <member name="T:System.Reflection.Metadata.UserStringHandle">
      <summary>表示用户字符串堆的句柄。</summary>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.Equals(System.Reflection.Metadata.UserStringHandle)">
      <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
      <param name="other">一个与此对象进行比较的对象。</param>
      <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.GetHashCode" />
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Equality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Explicit(System.Reflection.Metadata.Handle)~System.Reflection.Metadata.UserStringHandle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Implicit(System.Reflection.Metadata.UserStringHandle)~System.Reflection.Metadata.Handle">
      <param name="handle" />
    </member>
    <member name="M:System.Reflection.Metadata.UserStringHandle.op_Inequality(System.Reflection.Metadata.UserStringHandle,System.Reflection.Metadata.UserStringHandle)">
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:System.Reflection.Metadata.UserStringHandle.IsNil" />
    <member name="T:System.Reflection.MethodImportAttributes" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.BestFitMappingMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionCDecl" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionFastCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionStdCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionThisCall" />
    <member name="F:System.Reflection.MethodImportAttributes.CallingConventionWinApi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAnsi" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetAuto" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetMask" />
    <member name="F:System.Reflection.MethodImportAttributes.CharSetUnicode" />
    <member name="F:System.Reflection.MethodImportAttributes.ExactSpelling" />
    <member name="F:System.Reflection.MethodImportAttributes.None" />
    <member name="F:System.Reflection.MethodImportAttributes.SetLastError" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharDisable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharEnable" />
    <member name="F:System.Reflection.MethodImportAttributes.ThrowOnUnmappableCharMask" />
    <member name="T:System.Reflection.MethodSemanticsAttributes" />
    <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
      <summary>
        <para>用于为事件添加处理程序。 对应于 Ecma 335 CLI 规范中的 <see langword="AddOn" /> 标记。</para>
        <para>符合 CLS 的 adder 命名时采用前缀 <see langword="add_" />。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
      <summary>
        <para>读取属性的值。</para>
        <para>符合 CLS 的 getter 命名时采用前缀 get_。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
      <summary>属性的其他方法（非 getter 或 setter）或事件（非 adder、remover 或 raiser）。</summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
      <summary>
        <para>用于指示事件已发生。 对应于 Ecma 335 CLI 规范中的 <see langword="Fire" /> 标记。</para>
        <para> 符合 CLS 的 raiser 命名时采用前缀 <see langword="raise_" />。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
      <summary>
        <para>用于为事件移除处理程序。 对应于 Ecma 335 CLI 规范中的 <see langword="RemoveOn" /> 标记。</para>
        <para>符合 CLS 的 remover 命名时采用前缀 <see langword="remove_" />。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
      <summary>
        <para>用于修改属性的值。</para>
        <para>符合 CLS 的 setter 命名时采用前缀 <see langword="set_" />。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.AggressiveWSTrim" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Bit32Machine" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedHi" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.BytesReversedLo" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.DebugStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.Dll" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.ExecutableImage" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LargeAddressAware" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LineNumsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.LocalSymsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.NetRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RelocsStripped" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.RemovableRunFromSwap" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.System" />
    <member name="F:System.Reflection.PortableExecutable.Characteristics.UpSystemOnly" />
    <member name="T:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData">
      <summary>提供有关程序调试数据库 (PDB) 文件的信息。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Age">
      <summary>PDB 的迭代。 第一次迭代为 1。 每次扩充 PDB 内容时，迭代都会递增。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Guid">
      <summary>关联 PDB 的全局唯一标识符 (GUID)。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CodeViewDebugDirectoryData.Path">
      <summary>包含 PE/COFF 文件的调试信息的 .pdb 文件的路径。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CoffHeader">
      <summary>表示 COFF 文件的标头。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
      <summary>获取可指示文件属性的标志。</summary>
      <returns>指示文件特性的标志。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
      <summary>获取目标计算机的类型。</summary>
      <returns>目标计算机的类型。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
      <summary>获取部分数量。 这指示部分表的大小，该表紧跟在标头之后。</summary>
      <returns>部分的数目。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
      <summary>获取符号表中的项数。 此数据可用于查找紧跟在符号表后面的字符串表。 对于 PE 映像，此值应为零。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
      <summary>获取指向 COFF 符号表的文件指针。</summary>
      <returns>指向 COFF 符号表的文件指针，如果不存在 COFF 符号表，则为零。 对于 PE 映像，此值应为零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
      <summary>获取可选标头的大小，它是可执行文件所必需的，但对象文件不需要它。 对于对象文件，此值应为零。</summary>
      <returns>可选标头的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
      <summary>获取一个值，该值指示文件的创建时间。</summary>
      <returns>自00:00 年1月 1970 1 日算起的秒数的低32位，表示文件的创建时间。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.CorFlags">
      <summary>COR20Flags</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILLibrary" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.ILOnly" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.NativeEntryPoint" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Prefers32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.Requires32Bit" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.StrongNameSigned" />
    <member name="F:System.Reflection.PortableExecutable.CorFlags.TrackDebugData" />
    <member name="T:System.Reflection.PortableExecutable.CorHeader" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.CodeManagerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ExportAddressTableJumpsDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.Flags" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MajorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ManagedNativeHeaderDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MetadataDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.MinorRuntimeVersion" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.ResourcesDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.StrongNameSignatureDirectory" />
    <member name="P:System.Reflection.PortableExecutable.CorHeader.VtableFixupsDirectory" />
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" />
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryBuilder" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddCodeViewEntry(System.String,System.Reflection.Metadata.BlobContentId,System.UInt16)">
      <summary>添加 CodeView 项。</summary>
      <param name="pdbPath">PDB 路径。 不应为空。</param>
      <param name="pdbContentId">PDB 内容的唯一 ID。</param>
      <param name="portablePdbVersion">可移植 PDB 格式的版本（例如，适用于 1.0 的 0x0100）；如果 PDB 不可移植，则为 0。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pdbPath" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pdbPath" /> 包含 NUL 字符。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> 低于 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEmbeddedPortablePdbEntry(System.Reflection.Metadata.BlobBuilder,System.UInt16)">
      <summary>添加嵌入式可移植 PDB 项。</summary>
      <param name="debugMetadata">可移植 PDB 元数据生成器。</param>
      <param name="portablePdbVersion">可移植 PDB 格式的版本（例如，适用于 1.0 的 0x0100）。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="debugMetadata" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="portablePdbVersion" /> 低于 0x0100。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32)">
      <summary>添加指定类型的项。</summary>
      <param name="type">项类型。</param>
      <param name="version">项版本。</param>
      <param name="stamp">项标记。</param>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddEntry``1(System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.UInt32,System.UInt32,``0,System.Action{System.Reflection.Metadata.BlobBuilder,``0})">
      <summary>添加指定类型的项并对其数据进行序列化。</summary>
      <param name="type">项类型。</param>
      <param name="version">项版本。</param>
      <param name="stamp">项标记。</param>
      <param name="data">要传递给 <paramref name="dataSerializer" /> 的数据。</param>
      <param name="dataSerializer">用于将数据序列化到 <see cref="T:System.Reflection.Metadata.BlobBuilder" /> 的序列化程序。</param>
      <typeparam name="TData">传递给的数据的类型 <paramref name="dataSerializer" /> 。</typeparam>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddPdbChecksumEntry(System.String,System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>添加 PDB 校验和项。</summary>
      <param name="algorithmName">哈希算法名称（例如，“SHA256”）。</param>
      <param name="checksum">校验和。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="algorithmName" /> 或 <paramref name="checksum" /> 为空。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryBuilder.AddReproducibleEntry">
      <summary>添加可重现的项。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntry">
      <summary>标识调试信息块的位置、大小和格式。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.DebugDirectoryEntry.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.DebugDirectoryEntryType,System.Int32,System.Int32,System.Int32)">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 结构的新实例。</summary>
      <param name="stamp" />
      <param name="majorVersion" />
      <param name="minorVersion" />
      <param name="type" />
      <param name="dataSize" />
      <param name="dataRelativeVirtualAddress" />
      <param name="dataPointer" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataPointer">
      <summary>获取指向调试数据的文件指针。</summary>
      <returns>指向调试数据的文件指针。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataRelativeVirtualAddress">
      <summary>在加载时获取调试数据的地址（相对于映像基）。</summary>
      <returns>相对于图像基的调试数据的地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.DataSize">
      <summary>获取调试数据的大小（不包括调试目录本身）。</summary>
      <returns>调试数据的大小 (排除调试目录) 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.IsPortableCodeView">
      <summary>获取一个值，该值指示该项是否是指向可移植 PDB 的 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 项。</summary>
      <returns>
        <see langword="true" /> 如果项是 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> 指向可移植 PDB 的条目，则为; 否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MajorVersion">
      <summary>获取调试数据格式的主版本号。</summary>
      <returns>调试数据格式的主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.MinorVersion">
      <summary>获取调试数据格式的次要版本号。</summary>
      <returns>调试数据格式的次版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Stamp">
      <summary>如果 PE/COFF 文件为非确定性文件，则获取创建调试数据的时间和日期；否则，获取基于内容哈希的值。</summary>
      <returns>对于非确定性 PE/COFF 文件，为调试数据的创建时间和日期;否则，基于内容的哈希值。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.DebugDirectoryEntry.Type">
      <summary>获取调试信息的格式。</summary>
      <returns>调试信息的格式。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DebugDirectoryEntryType">
      <summary>一个枚举，它描述了 <see cref="T:System.Reflection.PortableExecutable.DebugDirectoryEntry" /> 的调用信息的格式。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView">
      <summary>关联的 PDB 文件说明。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Coff">
      <summary>COFF 调试信息（行号、符号表和字符串表）。 此类调试信息也由文件标头中的字段指向。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb">
      <summary>
        <para>该项指向包含嵌入式可移植 PDB 的 blob。 嵌入式可移植 PDB blob 具有以下格式：</para>
        <para>- blob ::= uncompressed-size data</para>
        <para>- 数据跨越 blob 的其余部分并包含 Deflate 压缩的可移植 PDB。</para>
      </summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.PdbChecksum">
      <summary>该项存储生成 PE/COFF 文件所使用的符号文件的内容的加密哈希。 哈希可用于验证给定的 PDB 文件是否是使用 PE/COFF 文件生成的，且不能以任何方式更改。 如果在生成 PE/COFF 文件的过程中生成了多个 PDB，则可能会出现多项（例如，专用和公共符号）。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible">
      <summary>如果出现此项，则表示存在确定的 PE/COFF 文件。 有关详细信息，请参阅备注部分。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Unknown">
      <summary>未知值，所有工具都应忽略。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.DirectoryEntry" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.RelativeVirtualAddress" />
    <member name="F:System.Reflection.PortableExecutable.DirectoryEntry.Size" />
    <member name="M:System.Reflection.PortableExecutable.DirectoryEntry.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="size" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.DllCharacteristics">
      <summary>描述动态链接库的特性。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.AppContainer">
      <summary>映像必须在 AppContainer 中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.DynamicBase">
      <summary>DLL 可重定位。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.HighEntropyVirtualAddressSpace">
      <summary>映像可处理高熵 64 位虚拟地址空间。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoBind">
      <summary>请勿绑定此映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoIsolation">
      <summary>该映像理解隔离，但不需要隔离。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NoSeh">
      <summary>该映像不使用 SEH。 该映像中不能有任何 SE 处理程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.NxCompatible">
      <summary>该映像与 NX 兼容。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessInit">
      <summary>保留。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ProcessTerm">
      <summary>保留。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.TerminalServerAware">
      <summary>该映像支持终端服务器感知。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadInit">
      <summary>保留。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.ThreadTerm">
      <summary>保留。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.DllCharacteristics.WdmDriver">
      <summary>驱动程序使用 WDM 模型。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.Machine">
      <summary>指定目标计算机的 CPU 体系结构。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
      <summary>Alpha。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
      <summary>ALPHA64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
      <summary>Matsushita AM33。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
      <summary>AMD64 (K8)。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
      <summary>ARM little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Arm64">
      <summary>ARM64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
      <summary>ARM Thumb-2 little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
      <summary>EFI 字节代码。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.I386">
      <summary>Intel 386。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
      <summary>Intel 64。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
      <summary>M32R little-endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
      <summary>MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
      <summary>具有 FPU 的 MIPS。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
      <summary>具有 FPU 的 MIPS16。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
      <summary>IBM PowerPC little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
      <summary>PowerPCFP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
      <summary>Hitachi SH3 little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
      <summary>Hitachi SH3 DSP。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
      <summary>Hitachi SH3 little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
      <summary>Hitachi SH4 little endian。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
      <summary>Hitachi SH5。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
      <summary>Thumb。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
      <summary>Infineon。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
      <summary>目标 CPU 未知或未指定。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
      <summary>MIPS little-endian WCE v2。</summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ManagedPEBuilder" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.ManagedResourcesDataAlignment" />
    <member name="F:System.Reflection.PortableExecutable.ManagedPEBuilder.MappedFieldDataAlignment" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Reflection.Metadata.Ecma335.MetadataRootBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.ResourceSectionBuilder,System.Reflection.PortableExecutable.DebugDirectoryBuilder,System.Int32,System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.PortableExecutable.CorFlags,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="metadataRootBuilder" />
      <param name="ilStream" />
      <param name="mappedFieldData" />
      <param name="managedResources" />
      <param name="nativeResources" />
      <param name="debugDirectoryBuilder" />
      <param name="strongNameSignatureSize" />
      <param name="entryPoint" />
      <param name="flags" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.ManagedPEBuilder.Sign(System.Reflection.Metadata.BlobBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Byte[]})">
      <param name="peImage" />
      <param name="signatureProvider" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData">
      <summary>表示 PDB 校验和调试目录项。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.AlgorithmName">
      <summary>用于计算校验和的加密哈希算法的名称。</summary>
      <returns>一个字符串，表示用于计算校验和的加密哈希算法的名称。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PdbChecksumDebugDirectoryData.Checksum">
      <summary>PDB 内容的校验和。</summary>
      <returns>表示 PDB 内容的校验和的不可变字节数组。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEBuilder" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.#ctor(System.Reflection.PortableExecutable.PEHeaderBuilder,System.Func{System.Collections.Generic.IEnumerable{System.Reflection.Metadata.Blob},System.Reflection.Metadata.BlobContentId})">
      <param name="header" />
      <param name="deterministicIdProvider" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.CreateSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetDirectories" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.GetSections" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Serialize(System.Reflection.Metadata.BlobBuilder)">
      <param name="builder" />
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.SerializeSection(System.String,System.Reflection.PortableExecutable.SectionLocation)">
      <param name="name" />
      <param name="location" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.Header" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IdProvider" />
    <member name="P:System.Reflection.PortableExecutable.PEBuilder.IsDeterministic" />
    <member name="T:System.Reflection.PortableExecutable.PEBuilder.Section" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Characteristics" />
    <member name="F:System.Reflection.PortableExecutable.PEBuilder.Section.Name" />
    <member name="M:System.Reflection.PortableExecutable.PEBuilder.Section.#ctor(System.String,System.Reflection.PortableExecutable.SectionCharacteristics)">
      <param name="name" />
      <param name="characteristics" />
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder">
      <summary>生成 PE 目录。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEDirectoriesBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.PEDirectoriesBuilder" /> 类的实例。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.AddressOfEntryPoint">
      <summary>PE 文件加载到内存中时相对于映像基的入口点地址。</summary>
      <returns>对于程序映像，这是起始地址。 对于设备驱动程序，这是初始化函数的地址。 对于 Dll，入口点是可选的。 如果不存在入口点，则此字段必须为零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BaseRelocationTable">
      <summary>基重定位表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.BoundImportTable">
      <summary>绑定的导入映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CopyrightTable">
      <summary>版权/体系结构映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.CorHeaderTable">
      <summary>COM 可描述的映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DebugTable">
      <summary>调试表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.DelayImportTable">
      <summary>延迟导入表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExceptionTable">
      <summary>异常表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ExportTable">
      <summary>导出表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.GlobalPointerTable">
      <summary>全局指针表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportAddressTable">
      <summary>导入地址表 (IAT) 映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ImportTable">
      <summary>导入表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.LoadConfigTable">
      <summary>加载配置表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ResourceTable">
      <summary>资源表表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEDirectoriesBuilder.ThreadLocalStorageTable">
      <summary>线程本地存储 (TLS) 表映像目录项。</summary>
      <returns>目录项实例。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeader" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
      <summary>获取 PE 文件加载到内存中时相对于映像基的入口点地址。</summary>
      <returns>相对于映像基的入口点地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
      <summary>获取图像加载到内存中时相对于图像基的代码开头部分的地址。</summary>
      <returns>相对于图像基的代码开头部分的地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
      <summary>获取图像加载到内存中时相对于图像基的数据开头部分的地址。</summary>
      <returns>相对于图像基的数据开始部分的地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseRelocationTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.BoundImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
      <summary>获取证书表项，该项指向特性证书表。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
      <summary>获取图像文件的校验和。</summary>
      <returns>图像文件的校验和。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CopyrightTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.CorHeaderTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DebugTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DelayImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.DllCharacteristics" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExceptionTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ExportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
      <summary>获取用于使图像文件中各节的原始数据保持一致的对齐系数（以字节为单位）。</summary>
      <returns>介于512和64K （含）之间的2的幂。 默认值为 512。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.GlobalPointerTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
      <summary>获取图像加载到内存中时其第一个字节的首选地址。</summary>
      <returns>首选地址，它是64K 的倍数。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportAddressTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ImportTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.LoadConfigTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
      <summary>获取标识图像文件格式的值。</summary>
      <returns>图像文件的格式。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
      <summary>获取映像的主版本号。</summary>
      <returns>映像的主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
      <summary>获取链接器主版本号。</summary>
      <returns>链接器主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
      <summary>获取所需操作系统的主版本号。</summary>
      <returns>所需操作系统的主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
      <summary>获取子系统的主版本号。</summary>
      <returns>子系统的主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
      <summary>获取映像的次要版本号。</summary>
      <returns>映像的次要版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
      <summary>获取链接器次要版本号。</summary>
      <returns>链接器次要版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
      <summary>获取所需操作系统的次要版本号。</summary>
      <returns>所需操作系统的次要版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
      <summary>获取子系统的次要版本号。</summary>
      <returns>子系统的次要版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
      <summary>获取 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 剩余部分中数据目录项的数目。 每项都描述位置和大小。</summary>
      <returns>的其余部分中的数据目录项的数目 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ResourceTableDirectory" />
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
      <summary>获取各部分加载到内存中时的对齐值（以字节为单位）。</summary>
      <returns>一个大于或等于的数字 <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> 。 默认值为体系结构的页面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
      <summary>获取代码（文本）段的大小，或者如果有多个部分，则获取所有代码段的和。</summary>
      <returns>代码的大小 (文本) 部分，或者如果有多个节，则为所有代码段的总和。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
      <summary>获取 MS DOS 存根、PE 标头和节标头的组合大小，其向上舍入到 FileAlignment 的倍数。</summary>
      <returns>MS DOS 存根、PE 标头和节标头的组合大小向上舍入到 FileAlignment 的倍数。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
      <summary>获取要提交的本地堆空间的大小。</summary>
      <returns>要提交的本地堆空间的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
      <summary>获取要保留的本地堆空间的大小。 仅提交 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" />；其余部分一次提供一页，直到达到保留大小。</summary>
      <returns>要保留的本地堆空间的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
      <summary>获取图像加载到内存中时图像的大小（以字节为单位），包括所有标头。</summary>
      <returns>映像的大小 (以字节为单位) ，它是的倍数 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
      <summary>获取初始化数据部分的大小，或者如果有多个数据部分，则获取所有此类部分的和。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
      <summary>获取要提交的堆栈的大小。</summary>
      <returns>要提交的堆栈的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
      <summary>获取要保留的堆栈的大小。 仅提交 <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" />；其余部分一次提供一页，直到达到保留大小。</summary>
      <returns>要保留的堆栈的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
      <summary>获取未初始化数据部分 (BSS) 的大小，或者如果有多个 BSS 部分，则获取所有此类部分的和。</summary>
      <returns>未初始化数据部分的大小 (BSS) 或所有此类部分的总和。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
      <summary>获取运行此映像所需的子系统的名称。</summary>
      <returns>运行此映像所需的子系统的名称。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeader.ThreadLocalStorageTableDirectory" />
    <member name="T:System.Reflection.PortableExecutable.PEHeaderBuilder">
      <summary>定义可移植可执行 (PE) 文件的标头。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.#ctor(System.Reflection.PortableExecutable.Machine,System.Int32,System.Int32,System.UInt64,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Reflection.PortableExecutable.Subsystem,System.Reflection.PortableExecutable.DllCharacteristics,System.Reflection.PortableExecutable.Characteristics,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.PEHeader" /> 类的新实例。</summary>
      <param name="machine">目标计算机的 CPU 体系结构。</param>
      <param name="sectionAlignment">各部分加载到内存中时的对齐值（以字节为单位）。 该值必须大于或等于 <paramref name="fileAlignment" />。 默认值为体系结构的页面大小。</param>
      <param name="fileAlignment">用于使映像文件中各部分的原始数据一致的对齐系数（以字节为单位）。 该值应为 2 的幂次方，界于 512 和 64K 之间（含）。 默认值为 512。 如果 <paramref name="sectionAlignment" /> 小于体系结构的页面大小，则 <paramref name="fileAlignment" /> 必须与 <paramref name="sectionAlignment" /> 匹配。</param>
      <param name="imageBase">映像加载到内存中时其第一个字节的首选地址。它必须是 64K 的倍数。</param>
      <param name="majorLinkerVersion">链接器主版本号。</param>
      <param name="minorLinkerVersion">链接器次要版本号。</param>
      <param name="majorOperatingSystemVersion">所需操作系统的主版本号。</param>
      <param name="minorOperatingSystemVersion">所需操作系统的次要版本号。</param>
      <param name="majorImageVersion">映像的主版本号。</param>
      <param name="minorImageVersion">映像的次要版本号。</param>
      <param name="majorSubsystemVersion">子系统的主版本号。</param>
      <param name="minorSubsystemVersion">子系统的次要版本号。</param>
      <param name="subsystem">运行映像所需的子系统。</param>
      <param name="dllCharacteristics">描述动态链接库特征的对象。</param>
      <param name="imageCharacteristics">描述映像特征的对象。</param>
      <param name="sizeOfStackReserve">要保留的堆栈的大小。 仅提交 <paramref name="sizeOfStackCommit" />；其余部分一次提供一页，直到达到保留大小。</param>
      <param name="sizeOfStackCommit">要提交的堆栈的大小。</param>
      <param name="sizeOfHeapReserve">要保留的本地堆空间的大小。 仅提交 <paramref name="sizeOfHeapCommit" />；其余部分一次提供一页，直到达到保留大小。</param>
      <param name="sizeOfHeapCommit">要提交的本地堆空间的大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="fileAlignment" /> 不是界于 512 和 64K 之间的 2 的幂次方。
- 或 -

<paramref name="sectionAlignment" /> 不是 2 的幂次方。

- 或 -

<paramref name="sectionAlignment" /> 小于 <paramref name="fileAlignment" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateExecutableHeader">
      <summary>创建可执行标头。</summary>
      <returns>表示可执行标头的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 实例。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaderBuilder.CreateLibraryHeader">
      <summary>创建库标头。</summary>
      <returns>表示库标头的 <see cref="T:System.Reflection.PortableExecutable.PEHeaderBuilder" /> 实例。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.DllCharacteristics">
      <summary>返回动态链接器库的特性。</summary>
      <returns>描述动态链接器库特性的对象。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.FileAlignment">
      <summary>用于使映像文件中各部分的原始数据一致的对齐系数（以字节为单位）。 该值应为 2 的幂次方，界于 512 和 64K 之间（含）。 默认值为 512。 如果该部分的对齐量小于体系结构的页面大小，则文件的对齐量必须与部分的对齐值匹配。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageBase">
      <summary>映像加载到内存中时其第一个字节的首选地址。它必须是 64K 的倍数。</summary>
      <returns>一个数字，表示加载到内存时图像的第一个字节的首选地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.ImageCharacteristics">
      <summary>返回映像的特征。</summary>
      <returns>表示图像特征的对象。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Machine">
      <summary>目标计算机的 CPU 体系结构。</summary>
      <returns>表示不同 CPU 体系结构的枚举值之一。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorImageVersion">
      <summary>映像的主版本号。</summary>
      <returns>
        <see cref="T:System.UInt16" />表示图像主版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorLinkerVersion">
      <summary>链接器主版本号。</summary>
      <returns>
        <see cref="T:System.Byte" />表示链接器主版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorOperatingSystemVersion">
      <summary>所需操作系统的主版本号。</summary>
      <returns>一个数字， <see cref="T:System.UInt16" /> 表示所需操作系统的主版本号。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MajorSubsystemVersion">
      <summary>子系统的主版本号。</summary>
      <returns>
        <see cref="T:System.UInt16" />表示子系统的主版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorImageVersion">
      <summary>映像的次要版本号。</summary>
      <returns>
        <see cref="T:System.UInt16" />表示图像的次版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorLinkerVersion">
      <summary>链接器次要版本号。</summary>
      <returns>
        <see cref="T:System.Byte" />表示链接器次版本号的的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorOperatingSystemVersion">
      <summary>所需操作系统的次要版本号。</summary>
      <returns>用于 <see cref="T:System.UInt16" /> 表示所需操作系统的次版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.MinorSubsystemVersion">
      <summary>子系统的次要版本号。</summary>
      <returns>
        <see cref="T:System.UInt16" />表示子系统次版本号的大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SectionAlignment">
      <summary>各部分加载到内存中时的对齐值（以字节为单位）。</summary>
      <returns>一个数字，表示在将节加载到内存中时， (以字节为单位) 的对齐方式。 它必须大于或等于文件的对齐方式。 默认值为体系结构的页面大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit">
      <summary>要提交的本地堆空间的大小。</summary>
      <returns>一个数字，表示要提交的本地堆空间的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapReserve">
      <summary>要保留的本地堆空间的大小。 仅提交 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfHeapCommit" />；其余部分一次提供一页，直到达到保留大小。</summary>
      <returns>一个数字，表示要保留的本地堆空间的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit">
      <summary>要提交的堆栈的大小。</summary>
      <returns>表示要提交的堆栈大小的数字。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackReserve">
      <summary>要保留的堆栈的大小。 仅提交 <see cref="P:System.Reflection.PortableExecutable.PEHeaderBuilder.SizeOfStackCommit" />；其余部分一次提供一页，直到达到保留大小。</summary>
      <returns>一个数字，表示要保留的堆栈的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaderBuilder.Subsystem">
      <summary>运行此映像所需的子系统。</summary>
      <returns>一个 <see cref="T:System.Reflection.PortableExecutable.Subsystem" /> 实例。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEHeaders">
      <summary>定义从流中读取 PE（可移植可执行文件）和 COFF（通用对象文件格式）标头。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
      <summary>实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从指定流中的当前位置读取 PE 头。</summary>
      <param name="peStream">包含从流的当前位置开始、到流末尾结束的 PE 映像的流。</param>
      <exception cref="T:System.BadImageFormatException">从流中读取的数据的格式无效。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错。</exception>
      <exception cref="T:System.ArgumentException">流不支持查找操作。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
      <summary>实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从代表指定大小的 PE 映像的流中读取 PE 头。</summary>
      <param name="peStream">包含给定大小（从其当前位置开始）的 PE 映像的流。</param>
      <param name="size">PE 映像的大小。</param>
      <exception cref="T:System.BadImageFormatException">从流中读取的数据的格式无效。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错。</exception>
      <exception cref="T:System.ArgumentException">流不支持查找操作。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负或超出了流的末尾。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
      <summary>实例化 <see cref="T:System.Reflection.PortableExecutable.PEHeaders" /> 类的新实例，该类从代表指定大小的 PE 映像的流中读取 PE 头，并指示该 PE 映像是否已加载到内存中。</summary>
      <param name="peStream">包含给定大小（从其当前位置开始）的 PE 映像的流。</param>
      <param name="size">PE 映像的大小。</param>
      <param name="isLoadedImage">如果 OS 加载程序已将 PE 映像加载到内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.BadImageFormatException">从流中读取的数据的格式无效。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错。</exception>
      <exception cref="T:System.ArgumentException">流不支持查找操作。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负或超出了流的末尾。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
      <summary>在 PE 映像的节中搜索包含指定相对虚拟地址的节。</summary>
      <param name="relativeVirtualAddress">要搜索的相对虚拟地址。</param>
      <returns>包含 <paramref name="relativeVirtualAddress" /> 的节的索引，或者为 -1（如果搜索不成功）。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
      <summary>获取从映像开头到给定目录数据的偏移量（以字节为单位）。</summary>
      <param name="directory">PE 目录项。</param>
      <param name="offset">方法返回时，包含从映像开头到给定目录数据的偏移量。</param>
      <returns>如果找到目录数据，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
      <summary>获取映像的 COFF 标头。</summary>
      <returns>图像的 COFF 标头。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
      <summary>获取从 PE 映像的开头到 COFF 标头的开头的字节偏移量。</summary>
      <returns>从 PE 映像开始到 COFF 标头开始的字节偏移量。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
      <summary>获取 COR 标头。</summary>
      <returns>COR 标头; 如果图像没有该标头，则为 <see langword="null" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
      <summary>获取从映像开头到 COR 标头的字节偏移量。</summary>
      <returns>从图像开头到 COR 标头的字节偏移量; 如果图像没有 COR 标头，则为-1。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
      <summary>获取一个值，该值指示映像是否仅为 Coff。</summary>
      <returns>
        <see langword="true" /> 如果图像仅为 Coff，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
      <summary>获取一个值，该值指示映像是否表示 Windows 控制台应用程序。</summary>
      <returns>
        <see langword="true" /> 如果图像是 Windows 控制台应用程序，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
      <summary>获取一个值，该值指示映像是否表示动态链接库。</summary>
      <returns>
        <see langword="true" /> 如果图像是一个 DLL，则为; 否则为。否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
      <summary>获取一个值，该值指示映像是否表示可执行文件。</summary>
      <returns>
        <see langword="true" /> 如果图像是可执行文件，则为; 否则为。否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
      <summary>获取 CLI 元数据的大小。</summary>
      <returns>CLI 元数据的大小; 如果该图像不包含元数据，则为0。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
      <summary>获取从 PE 映像的开头到 CLI 元数据的开头的偏移量（以字节为单位）。</summary>
      <returns>偏移量 (以字节为单位) 从 PE 映像的开始到 CLI 元数据的开始，或者-1 （如果该图像不包含元数据）。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
      <summary>获取映像的 PE 头。</summary>
      <returns>图像的 PE 标头; <see langword="null" /> 如果图像仅为 COFF，则为。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
      <summary>获取从映像开头的标头的字节偏移量。</summary>
      <returns>从图像开头开始的标头的字节偏移量。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
      <summary>获取 PE 节标头。</summary>
      <returns>包含 PE 节标头的数组。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEMagic" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32" />
    <member name="F:System.Reflection.PortableExecutable.PEMagic.PE32Plus" />
    <member name="T:System.Reflection.PortableExecutable.PEMemoryBlock" />
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent">
      <summary>将整个块的内容读入数组。</summary>
      <returns>不可变的字节数组。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetContent(System.Int32,System.Int32)">
      <summary>将块的一部分内容读入数组。</summary>
      <param name="start">块中的起始位置。</param>
      <param name="length">要读取的字节数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">指定的范围未包含在块中。</exception>
      <returns>不可变的字节数组。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader">
      <summary>为跨越整个块的 blob 创建 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <returns>跨越整个块的 blob 的读取器。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEMemoryBlock.GetReader(System.Int32,System.Int32)">
      <summary>为跨越部分块的 blob 创建 <see cref="T:System.Reflection.Metadata.BlobReader" />。</summary>
      <param name="start">块中的起始位置。</param>
      <param name="length">块的此部分中的字节数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">指定的范围未包含在块中。</exception>
      <returns>跨越部分块的 blob 的读取器。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Length">
      <summary>获取块的长度。</summary>
      <returns>块的长度。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEMemoryBlock.Pointer">
      <summary>获取指向块的第一个字节的指针。</summary>
      <returns>指向块的第一个字节的指针。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEReader">
      <summary>提供可移植可执行格式 (PE) 文件的读取器。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
      <summary>通过存储在内存中的 PE 映像创建可移植可执行文件读取器。</summary>
      <param name="peImage">指向 PE 映像开头的指针。</param>
      <param name="size">PE 映像的大小。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32,System.Boolean)">
      <summary>通过存储在内存中的 PE 映像创建可移植可执行文件读取器。 一个标志，用于指示该映像是否已加载到内存中。</summary>
      <param name="peImage">指向 PE 映像开头的指针。</param>
      <param name="size">PE 映像的大小。</param>
      <param name="isLoadedImage">如果 OS 加载程序已将 PE 映像加载到内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负数。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
      <summary>通过存储在字节数组中的 PE 映像创建可移植可执行文件读取器。</summary>
      <param name="peImage">表示 PE 映像的不可变字节数组。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImage" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
      <summary>通过存储在流中的 PE 映像创建可移植可执行文件读取器。</summary>
      <param name="peStream">PE 映像流。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
      <summary>通过存储在流中的 PE 映像创建可移植可执行文件读取器，从其当前位置开始，并在流的末尾结束。</summary>
      <param name="peStream">PE 映像流。</param>
      <param name="options">用于指定如何从流中读取 PE 映像各部分的选项。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peStream" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="options" /> 具有无效值。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错（仅在预提取数据时发生）。</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> 已指定，并且映像的 PE 标头无效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
      <summary>从流的当前位置开始，通过给定大小的 PE 映像创建可移植可执行文件读取器。</summary>
      <param name="peStream">PE 映像流。</param>
      <param name="options">用于指定如何从流中读取 PE 映像各部分的选项。</param>
      <param name="size">PE 映像大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="size" /> 为负或超出了流的末尾。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错（仅在预提取数据时发生）。</exception>
      <exception cref="T:System.BadImageFormatException">
        <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> 已指定，并且映像的 PE 标头无效。</exception>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
      <summary>释放由读取器分配的所有内存。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
      <summary>获取包含整个 PE 映像的 <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" /> 对象。</summary>
      <exception cref="T:System.InvalidOperationException">整个 PE 映像不可用。</exception>
      <returns>包含整个 PE 映像的内存块。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
      <summary>加载包含 CLI 元数据的 PE 部分。</summary>
      <exception cref="T:System.InvalidOperationException">PE 映像不包含元数据（<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> 返回 <see langword="false" />）。</exception>
      <exception cref="T:System.BadImageFormatException">PE 标头包含无效数据。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <returns>包含 CLI 元数据的内存块。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
      <summary>将包含指定的相对虚拟地址的 PE 部分加载到内存中，并返回从该地址开始、至包含部分结尾终止的内存块。</summary>
      <param name="relativeVirtualAddress">要读取的数据的相对虚拟地址。</param>
      <exception cref="T:System.BadImageFormatException">PE 标头包含无效数据。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时发生 IO 错误。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="relativeVirtualAddress" /> 为负数。</exception>
      <returns>一个内存块，从 <paramref name="relativeVirtualAddress" /> 开始并在包含部分结尾终止，如果 <paramref name="relativeVirtualAddress" /> 不表示此 PE 映像任何 PE 部分中的位置，则为空内存块。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.String)">
      <summary>将具有指定名称的 PE 部分加载到内存中，并返回跨越该部分的内存块。</summary>
      <param name="sectionName">部分的名称。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sectionName" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <returns>跨越部分的内存块；如果此 PE 映像中不存在给定 <paramref name="sectionName" /> 的部分，则为空内存块。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadCodeViewDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>读取指定的调试目录项指向的数据，并将其解释为 CodeView。</summary>
      <param name="entry">调试目录项实例。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 CodeView 项。</exception>
      <exception cref="T:System.BadImageFormatException">数据的格式错误。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <returns>代码视图调试目录数据实例。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory">
      <summary>读取所有调试目录表项。</summary>
      <exception cref="T:System.BadImageFormatException">项的格式错误。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <returns>调试目录表项的数组。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadEmbeddedPortablePdbDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>读取指定的调试目录项指向的数据，并将其解释为嵌入式可移植 PDB blob。</summary>
      <param name="entry">要读取其数据的调试目录项。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> 项。</exception>
      <exception cref="T:System.BadImageFormatException">数据的格式错误。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <returns>用于读取可移植 PDB 映像的元数据读取器提供程序。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.ReadPdbChecksumDebugDirectoryData(System.Reflection.PortableExecutable.DebugDirectoryEntry)">
      <summary>读取指定的调试目录项指向的数据，并将其解释为 PDB 校验和项。</summary>
      <param name="entry">要读取其数据的调试目录项。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="entry" /> 不是 PDB 校验和项。</exception>
      <exception cref="T:System.BadImageFormatException">数据的格式错误。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出现 IO 错误。</exception>
      <exception cref="T:System.InvalidOperationException">PE 映像不可用。</exception>
      <returns>PDB 校验和项。</returns>
    </member>
    <member name="M:System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(System.String,System.Func{System.String,System.IO.Stream},System.Reflection.Metadata.MetadataReaderProvider@,System.String@)">
      <summary>打开与此 PE 映像关联的可移植 PDB。</summary>
      <param name="peImagePath">PE 映像的路径。 该路径用于查找位于包含 PE 文件的目录中的 PDB 文件。</param>
      <param name="pdbFileStreamProvider">如果已指定，则调用以打开给定文件路径的 <see cref="T:System.IO.Stream" />。 如果目标文件不存在，或者出于某种原因应忽略该文件，则提供程序应返回可查找的可读 <see cref="T:System.IO.Stream" /> 或 <see langword="null" />。 如果由于意外的 IO 错误而无法打开文件，则提供程序应引发 <see cref="T:System.IO.IOException" />。</param>
      <param name="pdbReaderProvider">如果成功，则为 <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> 的新实例，用于读取可移植 PDB。</param>
      <param name="pdbPath">如果成功，并且在文件中找到 PDB，则为文件路径，如果 PDB 嵌入到 PE 映像本身中，则为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="peImagePath" /> 或 <paramref name="pdbFileStreamProvider" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.InvalidOperationException">从 <paramref name="pdbFileStreamProvider" /> 返回的流不支持读取和查找操作。</exception>
      <exception cref="T:System.BadImageFormatException">由于出现错误，找不到匹配的 PDB 文件： PE 映像或 PDB 无效。</exception>
      <exception cref="T:System.IO.IOException">由于出现错误，找不到匹配的 PDB 文件：读取 PE 映像或 PDB 时发生 IO 错误。</exception>
      <returns>如果 PE 映像具有与之关联的 PDB 并且已成功打开 PDB，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
      <summary>获取一个值，该值指示 PE 映像是否包含 CLI 元数据。</summary>
      <exception cref="T:System.BadImageFormatException">PE 标头包含无效数据。</exception>
      <exception cref="T:System.IO.IOException">从基础流中读取时出错。</exception>
      <returns>
        <see langword="true" /> 如果 PE 映像包含 CLI 元数据，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
      <summary>获取一个值，该值指示读取器是否可以访问整个 PE 映像。</summary>
      <returns>
        <see langword="true" /> 如果读取器可以访问整个 PE 映像，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.IsLoadedImage">
      <summary>获取一个值，该值指示 OS 加载程序是否已将 PE 映像加载到内存中。</summary>
      <returns>如果 OS 加载程序已将 PE 映像加载到内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
      <summary>获取 PE 标头。</summary>
      <exception cref="T:System.BadImageFormatException">标头包含无效数据。</exception>
      <exception cref="T:System.IO.IOException">从流中读取时出错。</exception>
      <returns>此 PE 映像的 PE 标头。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.PEStreamOptions">
      <summary>提供指定如何从流中读取 PE 映像各部分的选项。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
      <summary>默认情况下，释放 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 并且延迟读取 PE 映像的各部分时，系统才会释放该流。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.IsLoadedImage">
      <summary>指示基础 PE 映像已由 OS 加载程序加载到内存中。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
      <summary>在释放 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 时将流保持为开放状态。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
      <summary>立即将整个映像读入内存中。 除非指定了 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否则 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 会在构造函数返回时自动关闭流。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
      <summary>
        <para>立即将元数据部分读入内存中。</para>
        <para>不允许从文件的其他部分进行读取（<see cref="T:System.InvalidOperationException" /> 由 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 引发）。</para>
        <para>除非指定了 <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" />，否则 
            <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 会在构造函数返回时自动关闭流。 构造 <see cref="T:System.Reflection.PortableExecutable.PEReader" /> 之后，基础文件可能会关闭，甚至被删除。</para>
      </summary>
    </member>
    <member name="T:System.Reflection.PortableExecutable.ResourceSectionBuilder">
      <summary>定义 PE 资源部分生成器的基类。 派生自 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" />，提供本机资源的序列化逻辑。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.#ctor">
      <summary>初始化 <see cref="T:System.Reflection.PortableExecutable.ResourceSectionBuilder" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Reflection.PortableExecutable.ResourceSectionBuilder.Serialize(System.Reflection.Metadata.BlobBuilder,System.Reflection.PortableExecutable.SectionLocation)">
      <summary>序列化指定资源。</summary>
      <param name="builder">其中包含要序列化的数据的 blob。</param>
      <param name="location">要将 <paramref name="builder" /> 序列化到其中的位置。</param>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionCharacteristics" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1024Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align128Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align16Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align1Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2048Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align256Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align2Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align32Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4096Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align4Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align512Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align64Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8192Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Align8Bytes" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.AlignMask" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsCode" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsInitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.ContainsUninitializedData" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.GPRel" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerComdat" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerInfo" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerNRelocOvfl" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerOther" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.LinkerRemove" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.Mem16Bit" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemDiscardable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemExecute" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemFardata" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemLocked" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotCached" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemNotPaged" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPreload" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemProtected" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemPurgeable" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemRead" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemShared" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemSysheap" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.MemWrite" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.NoDeferSpecExc" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeCopy" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeDSect" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeGroup" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoLoad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeNoPad" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeOver" />
    <member name="F:System.Reflection.PortableExecutable.SectionCharacteristics.TypeReg" />
    <member name="T:System.Reflection.PortableExecutable.SectionHeader">
      <summary>提供有关 PE/COFF 文件的节标头的信息。</summary>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
      <summary>获取节的名称。</summary>
      <returns>部分的名称。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
      <summary>获取节的行号项数。</summary>
      <returns>部分的行号条目数。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
      <summary>获取节的重定位项数。</summary>
      <returns>部分的重定位条目数。 对于 PE 映像，其值为零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
      <summary>获取指向节的行号项开头的文件指针。</summary>
      <returns>指向节的行号条目开头的文件指针，如果没有 COFF 行号，则为零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
      <summary>获取指向 COFF 文件中节的第一页的文件指针。</summary>
      <returns>指向 COFF 文件中节的第一页的文件指针。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
      <summary>获取指向节的重定位项的开头的文件指针。</summary>
      <returns>指向部分的重定位条目开始位置的文件指针。 对于 PE 映像，或者如果没有重定位，则将其设置为零。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
      <summary>获取描述节特性的标志。</summary>
      <returns>描述节特征的标志。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
      <summary>获取节（对于对象文件）的大小或磁盘上已初始化的数据的大小（对于映像文件）。</summary>
      <returns>对象文件的 (部分的大小) 或图像文件) 磁盘 (上已初始化数据的大小。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
      <summary>获取节的虚拟地址。</summary>
      <returns>部分的虚拟地址。</returns>
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
      <summary>获取加载到内存中时节的总大小。</summary>
      <returns>加载到内存中的节的总大小。</returns>
    </member>
    <member name="T:System.Reflection.PortableExecutable.SectionLocation" />
    <member name="M:System.Reflection.PortableExecutable.SectionLocation.#ctor(System.Int32,System.Int32)">
      <param name="relativeVirtualAddress" />
      <param name="pointerToRawData" />
    </member>
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.PointerToRawData" />
    <member name="P:System.Reflection.PortableExecutable.SectionLocation.RelativeVirtualAddress" />
    <member name="T:System.Reflection.PortableExecutable.Subsystem">
      <summary>描述映像的子系统要求。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiApplication">
      <summary>可扩展固件接口 (EFI) 应用程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiBootServiceDriver">
      <summary>具有启动服务的 EFI 驱动程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRom">
      <summary>EFI ROM 映像。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.EfiRuntimeDriver">
      <summary>具有运行时服务的 EFI 驱动程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Native">
      <summary>此映像不需要子系统。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.NativeWindows">
      <summary>此映像是本机 Win9x 驱动程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.OS2Cui">
      <summary>此映像在 OS/2 字符子系统中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.PosixCui">
      <summary>此映像在 Posix 字符子系统中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Unknown">
      <summary>未知子系统。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsBootApplication">
      <summary>启动应用程序。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCEGui">
      <summary>此映像在 Windows CE 子系统中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsCui">
      <summary>此映像在 Windows 字符子系统中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.WindowsGui">
      <summary>此映像在 Windows GUI 子系统中运行。</summary>
    </member>
    <member name="F:System.Reflection.PortableExecutable.Subsystem.Xbox">
      <summary>Xbox 系统。</summary>
    </member>
  </members>
</doc>