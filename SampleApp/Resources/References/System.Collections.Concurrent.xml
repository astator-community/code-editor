<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Collections.Concurrent</name>
  </assembly>
  <members>
    <member name="T:System.Collections.Concurrent.BlockingCollection`1">
      <summary>为实现 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 的线程安全集合提供阻塞和限制功能。</summary>
      <typeparam name="T">集合中的元素类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 类的新实例，该实例没有上限。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 类的新实例，该实例没有上限，并使用提供的 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 作为其基础数据存储区。</summary>
      <param name="collection">要用作基础数据存储区的集合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 参数为 null。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 类的新实例，该实例具有指定的上限，并使用提供的 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 作为其基础数据存储区。</summary>
      <param name="collection">要用作基础数据存储区的集合。</param>
      <param name="boundedCapacity">集合的限制大小。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="boundedCapacity" /> 不是正值。</exception>
      <exception cref="T:System.ArgumentException">所提供 <paramref name="collection" /> 包含的值比 <paramref name="boundedCapacity" /> 允许的值多。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 类的新实例，该实例具有指定的上限。</summary>
      <param name="boundedCapacity">集合的限制大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="boundedCapacity" /> 不是正值。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
      <summary>将项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中。</summary>
      <param name="item">要添加到集合的项。 该值可以是 null 引用。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
      <summary>将项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中。</summary>
      <param name="item">要添加到集合的项。 该值可以是 null 引用。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已被释放，或拥有 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>向任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中添加指定的项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
      <summary>向任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中添加指定的项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放至少一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例，或已释放创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
      <summary>将 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例标记为不任何更多的添加。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
      <summary>将 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中的所有项复制到兼容的一维数组中，复制从目标数组的指定索引处开始。</summary>
      <param name="array">一维数组，它是从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例复制的元素的目标。 该数组的索引必须从零开始。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 参数小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 参数等于或大于 <paramref name="array" /> 的长度。  
  
目标数组太小，不能容纳所有 BlockingCollection 元素。  
  
数组秩不匹配。  
  
数组类型与 BlockingCollection 元素类型不兼容。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
      <summary>释放 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
      <summary>释放由 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例使用的资源。</summary>
      <param name="disposing">是显式释放 (true)，还是由于终结器释放 (false)。</param>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
      <summary>为集合中的项提供一个使用 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>从集合中移除并返回项的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
      <summary>为集合中的项提供一个使用 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</summary>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />，或已释放创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /></exception>
      <returns>从集合中移除并返回项的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>为集合中的项提供 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>集合中的项的 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>将 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中的所有项复制到兼容的一维数组中，复制从目标数组的指定索引处开始。</summary>
      <param name="array">一维数组，它是从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例复制的元素的目标。 该数组的索引必须从零开始。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 参数小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 参数等于或大于 <paramref name="array" /> 的长度，该数组是多维的，或集合的类型参数无法自动强制转换为目标数组的类型。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>为集合中的项提供 <see cref="T:System.Collections.IEnumerator" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>集合中的项的 <see cref="T:System.Collections.IEnumerator" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take">
      <summary>从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.InvalidOperationException">基础集合在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外修改，或 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 为空，并且集合已标记为完成添加。</exception>
      <exception cref="T:System.OperationCanceledException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 为空，并且已被标记为完成添加。</exception>
      <returns>从集合中移除的项。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
      <summary>从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <param name="cancellationToken">可用于取消获取操作的对象。</param>
      <exception cref="T:System.OperationCanceledException">
        <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />，或已取消创建该标记的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <exception cref="T:System.InvalidOperationException">基础集合在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外修改，或该 BlockingCollection 被标记为完成添加，或 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 为空。</exception>
      <returns>从集合中移除的项。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中获取一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素，或 <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> 在集合上已被调用。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
      <summary>在观察指定的取消标记时从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中获取一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素，或 <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> 在集合上已被调用。</exception>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
      <summary>将项从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例复制到新数组中。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>包含集合元素副本的数组。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
      <summary>尝试将指定的项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</summary>
      <param name="item">要添加到集合的项。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
      <returns>如果可以添加 <paramref name="item" />，则返回 <see langword="true" />；否则，返回 <see langword="false" />。 如果该项有重复，并且基础集合不接受重复项，则会引发 <see cref="T:System.InvalidOperationException" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
      <summary>尝试在指定的时间段内将指定的项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</summary>
      <param name="item">要添加到集合的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
      <returns>如果在指定的时间内可以将 <paramref name="item" /> 添加到集合中，则为 <see langword="true" />；否则为 false。 如果该项有重复，并且基础集合不接受重复项，则会引发 <see cref="T:System.InvalidOperationException" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
      <summary>在观察取消标记时，尝试在指定的时间段内将指定的项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</summary>
      <param name="item">要添加到集合的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />，或已释放基础 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
      <returns>如果在指定的时间内可以将 <paramref name="item" /> 添加到集合中，则为 <see langword="true" />；否则为 false。 如果该项有重复，并且基础集合不接受重复项，则会引发 <see cref="T:System.InvalidOperationException" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
      <summary>尝试将指定的项添加到 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</summary>
      <param name="item">要添加到集合的项。</param>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 已标记为完成添加。  
  
- 或 - 
基础集合未接受该项。</exception>
      <returns>如果在指定的时间跨度内可以将 <paramref name="item" /> 添加到集合中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
      <summary>尝试将指定的项添加到任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引；如果未能添加项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
      <summary>尝试将指定的项添加到任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。 
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引；如果未能添加项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
      <summary>尝试将指定的项添加到任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。 
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引；如果未能添加项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
      <summary>在观察指定的取消标记时，尝试将指定的项添加到任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">要添加到其中一个集合的项。</param>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ObjectDisposedException">已释放至少一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例，或已释放创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。  
  
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或者包含 NULL 元素，或者至少一个集合已标记为完成添加。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合未接受该项。</exception>
      <returns>向其添加项的集合在 <paramref name="collections" /> 数组中的索引；如果未能添加项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <param name="item">要从集合中移除的项。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.InvalidOperationException">该基础集合已在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外部进行了修改。</exception>
      <returns>如果可以移除项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
      <summary>尝试在指定的时间段内从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <param name="item">要从集合中移除的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">该基础集合已在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外部进行了修改。</exception>
      <returns>如果在指定的时间内可以从集合中移除一个项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>在观察取消标记时，尝试在指定的时间段内从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <param name="item">要从集合中移除的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />，或已释放基础 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">该基础集合已在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外部进行了修改。</exception>
      <returns>如果在指定的时间内可以从集合中移除一个项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
      <summary>尝试在指定的时间段内从 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中移除一个项。</summary>
      <param name="item">要从集合中移除的项。</param>
      <param name="timeout">一个对象，表示等待的毫秒数，或为 -1 毫秒，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。 
- 或 - 
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.InvalidOperationException">该基础集合已在此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例外部进行了修改。</exception>
      <returns>如果在指定的时间内可以从集合中移除一个项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
      <summary>尝试从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中移除一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引；如果未能移除项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
      <summary>尝试从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中移除一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。 
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引；如果未能移除项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
      <summary>尝试从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中移除一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的取消标记。</param>
      <exception cref="T:System.OperationCanceledException">如果已取消 <see cref="T:System.Threading.CancellationToken" />。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。 
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素。</exception>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引；如果未能移除项，则为 -1。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
      <summary>尝试从任一指定的 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例中移除一个项。</summary>
      <param name="collections">集合的数组。</param>
      <param name="item">从其中一个集合中移除的项。</param>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ObjectDisposedException">至少已释放其中一个 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collections" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。  
  
- 或 - 
<paramref name="collections" /> 的计数大于上限（STA 为 62，MTA 为 63）。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collections" /> 参数是一个长度为 0 的数组，或包含 NULL 元素。</exception>
      <exception cref="T:System.InvalidOperationException">至少一个基础集合已在其 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例之外进行了修改。</exception>
      <returns>从其中移除项的集合在 <paramref name="collections" /> 数组中的索引；如果未能移除项，则为 -1。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
      <summary>获取此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 实例的限定容量。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>此集合的限定容量；如果未提供限制，则为 int.MaxValue。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.Count">
      <summary>获取 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中包含的项的数量。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>
        <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 中包含的项的数量。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
      <summary>获取此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 是否已标记为完成添加。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>此集合是否已标记为完成添加。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
      <summary>获取此 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 是否已标记为完成添加并且为空。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>此集合是否已标记为完成添加并且为空。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
      <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ICollection" /> 的访问（线程安全）。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />。</exception>
      <returns>始终返回 <see langword="false" /> ，指示未同步访问。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
      <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。 不支持此属性。</summary>
      <exception cref="T:System.NotSupportedException">不支持 SyncRoot 属性。</exception>
      <returns>返回 <see langword="null" />。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
      <summary>表示对象的线程安全的无序集合。</summary>
      <typeparam name="T">要存储在集合中的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 类的新实例，该类包含从指定集合中复制的元素。</summary>
      <param name="collection">其元素被复制到新的 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中的集合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
      <summary>将对象添加到 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Clear">
      <summary>从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中删除所有值。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
      <summary>从指定数组索引开始将 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 元素复制到现有一维 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的枚举数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的内容的枚举器。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>尝试将一个对象添加到 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
      <returns>始终返回 true</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> 是多维的。 - 或 -<paramref name="array" /> 没有从零开始的索引。 - 或 - <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 的类型无法自动转换为目标 <paramref name="array" /> 的类型。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的枚举数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 的内容的枚举器。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
      <summary>将 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 元素复制到新数组。</summary>
      <returns>新数组包含从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 复制的元素的快照。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 返回一个对象但不移除该对象。</summary>
      <param name="result">此方法返回时，<paramref name="result" /> 包含 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中的对象；如果操作失败，则返回 <typeparamref name="T" /> 的默认值。</param>
      <returns>如果成功返回了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中移除和返回一个对象。</summary>
      <param name="result">此方法返回时，<paramref name="result" /> 包含从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中移除的对象；如果包为空，则返回 <typeparamref name="T" /> 的默认值。</param>
      <returns>如果已成功移除对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
      <summary>获取 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中包含的元素数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 中包含的元素数。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 是否为空。</summary>
      <returns>如果 <see langword="true" /> 为空，则为 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#IsSynchronized">
      <summary>获取一个指示对 <see cref="T:System.Collections.ICollection" /> 的访问是否与 SyncRoot 同步的值。</summary>
      <returns>始终返回 <see langword="false" /> ，指示未同步访问。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#SyncRoot">
      <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。 不支持此属性。</summary>
      <exception cref="T:System.NotSupportedException">不支持 SyncRoot 属性。</exception>
      <returns>返回 <see langword="null" />。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
      <summary>表示可由多个线程同时访问的键/值对的线程安全集合。</summary>
      <typeparam name="TKey">字典中的键的类型。</typeparam>
      <typeparam name="TValue">字典中的值的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例为空，具有默认的并发级别和默认的初始容量，并为键类型使用默认比较器。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例包含从指定的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 中复制的元素，具有默认的并发级别和默认的初始容量，并为键类型使用默认比较器。</summary>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的元素被复制到新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 或其中的任一键为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> 包含一个或多个重复键。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例包含从指定的 <see cref="T:System.Collections.IEnumerable" /> 中复制的元素，具有默认的并发级别和默认的初始容量，并使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</summary>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的元素被复制到新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />。</param>
      <param name="comparer">在对键进行比较时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 或 <paramref name="comparer" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例为空，具有默认的并发级别和容量，并使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</summary>
      <param name="comparer">在对键进行比较时使用的相等比较实现。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例包含从指定的 <see cref="T:System.Collections.IEnumerable" /> 中复制的元素并使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</summary>
      <param name="concurrencyLevel">将同时更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的线程的估计数量。</param>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" />，它的元素被复制到新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />。</param>
      <param name="comparer">在对键进行比较时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 或 <paramref name="comparer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> 小于 1。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> 包含一个或多个重复键。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例为空，具有指定的并发级别和容量，并为键类型使用默认比较器。</summary>
      <param name="concurrencyLevel">将同时更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的线程的估计数量。</param>
      <param name="capacity">
        <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 可包含的初始元素数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> 小于 1。  
  
- 或 - 
 <paramref name="capacity" /> 小于 0。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 类的新实例，该实例为空，具有指定的并发级别和指定的初始容量，并使用指定的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />。</summary>
      <param name="concurrencyLevel">将同时更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的线程的估计数量。</param>
      <param name="capacity">
        <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 可包含的初始元素数。</param>
      <param name="comparer">在对键进行比较时使用的 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 实现。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="concurrencyLevel" /> 或 <paramref name="capacity" /> 小于 1。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
      <summary>如果该键不存在，则将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中；如果该键已经存在，则通过使用指定的函数更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中的键/值对。</summary>
      <param name="key">要添加的键或应更新其值的键</param>
      <param name="addValue">要为空缺键添加的值</param>
      <param name="updateValueFactory">用于基于键的现有值为现有键生成新值的函数</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 或 <paramref name="updateValueFactory" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的新值。 这将为 <paramref name="addValue" /> （若没有键）或 <paramref name="updateValueFactory" /> 的结果（若有键）。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
      <summary>如果该键不存在，则使用指定函数将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />；如果该键已存在，则使用该函数更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中的键/值对。</summary>
      <param name="key">要添加的键或应更新其值的键</param>
      <param name="addValueFactory">用于为空缺键生成值的函数</param>
      <param name="updateValueFactory">用于基于键的现有值为现有键生成新值的函数</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />、<paramref name="addValueFactory" /> 或 <paramref name="updateValueFactory" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的新值。 这将为 <paramref name="addValueFactory" /> 的结果（若没有键）或 <paramref name="updateValueFactory" /> 的结果（若有键）。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
      <summary>使用指定函数和参数将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />中（若尚无键）；或使用指定函数和参数更新 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中的键/值对（若已有键）。</summary>
      <param name="key">要添加的键或应更新其值的键。</param>
      <param name="addValueFactory">用于为空缺键生成值的函数。</param>
      <param name="updateValueFactory">用以基于键的现有值为现有键生成新值的函数。</param>
      <param name="factoryArgument">要传入 <paramref name="addValueFactory" /> 和 <paramref name="updateValueFactory" /> 的参数。</param>
      <typeparam name="TArg">要传递到和的参数的类型 <paramref name="addValueFactory" /><paramref name="updateValueFactory" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />、<paramref name="addValueFactory" /> 或 <paramref name="updateValueFactory" /> 为空引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的新值。 这将为 <paramref name="addValueFactory" /> 的结果（若没有键）或 <paramref name="updateValueFactory" /> 的结果（若有键）。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
      <summary>将所有键和值从 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中移除。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
      <summary>确定是否 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 包含指定键。</summary>
      <param name="key">要在 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中定位的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果 <see langword="true" /> 包含具有指定键的元素，则为 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的枚举数。</summary>
      <returns>用于 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的枚举数。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
      <summary>如果指定的键尚不存在，则将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中。 如果该键存在，则返回新值或现有值。</summary>
      <param name="key">要添加的元素的键。</param>
      <param name="value">当键不存在时要添加的值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的值。 如果字典中已存在指定的键，则为该键的现有值；如果字典中不存在指定的键，则为新值。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
      <summary>如果该键不存在，则通过使用指定的函数将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中。 如果该键存在，则返回新值或现有值。</summary>
      <param name="key">要添加的元素的键。</param>
      <param name="valueFactory">用于为键生成值的函数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 或 <paramref name="valueFactory" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的值。 如果字典中已存在该键，则为该键的现有值；如果字典中不存在该键，则为新值。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
      <summary>使用指定函数和参数将键/值对添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />中（若尚无键）；或返回现有值（若已有键）。</summary>
      <param name="key">要添加的元素的键。</param>
      <param name="valueFactory">用于为键生成值的函数。</param>
      <param name="factoryArgument">要传入 <paramref name="valueFactory" /> 的参数值。</param>
      <typeparam name="TArg">要传入的参数的类型 <paramref name="valueFactory" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" /> 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>键的值。 如果字典中已存在该键，则为该键的现有值；如果字典中不存在该键，则为新值。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>向集合中添加一项。</summary>
      <param name="keyValuePair">要添加到字典中的 <see cref="T:System.Collections.Generic.KeyValuePair`2" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyValuePair" /> 的 <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">
        <see cref="T:System.Collections.Generic.Dictionary`2" />，它包含太多元素。</exception>
      <exception cref="T:System.ArgumentException">
        <see cref="T:System.Collections.Generic.Dictionary`2" /> 中已存在具有相同键的元素。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.ICollection`1" /> 是否包含具有指定键的元素。</summary>
      <param name="keyValuePair">要在 <see cref="T:System.Collections.Generic.ICollection`1" /> 中定位的键。</param>
      <returns>如果 <see langword="true" /> 包含具有指定键的元素，则为 <see cref="T:System.Collections.Generic.ICollection`1" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>从指定的数组索引开始，将 <see cref="T:System.Collections.ICollection" /> 中的元素复制到一个数组中。</summary>
      <param name="array">一维数组，它是从 <see cref="T:System.Collections.ICollection" /> 中复制的元素的目标。 该数组的索引必须从零开始。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于 0。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度。

- 或 -

源 <see cref="T:System.Collections.ICollection" /> 中的元素个数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>将指定的键/值对从集合中移除。</summary>
      <param name="keyValuePair">要移除的 <see cref="T:System.Collections.Generic.KeyValuePair`2" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="keyValuePair" /> 的 <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> 属性为 <see langword="null" />。</exception>
      <returns>如果该元素已成功移除，则为 <see langword="true" />；否则为 <see langword="false" />。 如果在原始 <see cref="T:System.Collections.Generic.ICollection`1" /> 中找不到 <paramref name="key" />，此方法也会返回 false。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
      <summary>向 <see cref="T:System.Collections.Generic.IDictionary`2" /> 中添加指定的键和值。</summary>
      <param name="key">用作要添加的元素的键的对象。</param>
      <param name="value">用作要添加的元素的值的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中已存在具有相同键的元素。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
      <summary>从 <see cref="T:System.Collections.Generic.IDictionary`2" /> 中移除包含指定键的元素。</summary>
      <param name="key">要移除的元素的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果该元素已成功移除，则为 <see langword="true" />；否则为 <see langword="false" />。 如果在原始 <see langword="false" /> 中没有找到 <paramref name="key" />，此方法也会返回 <see cref="T:System.Collections.Generic.IDictionary`2" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>从指定的数组索引开始，将 <see cref="T:System.Collections.ICollection" /> 中的元素复制到一个数组中。</summary>
      <param name="array">一维数组，它是从 <see cref="T:System.Collections.ICollection" /> 中复制的元素的目标。 该数组的索引必须从零开始。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于 0。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度。  
  
- 或 - 
源 <see cref="T:System.Collections.ICollection" /> 中的元素个数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
      <summary>将指定的键和值添加到字典中。</summary>
      <param name="key">要用作键的对象。</param>
      <param name="value">要用作值的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> 所属类型不可分配给 <see cref="T:System.Collections.Generic.Dictionary`2" /> 的键类型。  
  
- 或 - 
 <paramref name="value" /> 属于不能分配给 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的值类型的类型。  
  
- 或 - 
<see cref="T:System.Collections.Generic.Dictionary`2" /> 中已存在相同键的值。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
      <summary>获取一个值，它指示 <see cref="T:System.Collections.Generic.IDictionary`2" /> 包含具有指定键的元素。</summary>
      <param name="key">要在 <see cref="T:System.Collections.Generic.IDictionary`2" /> 中定位的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果 <see langword="true" /> 包含具有指定键的元素，则为 <see cref="T:System.Collections.Generic.IDictionary`2" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
      <summary>为 <see cref="T:System.Collections.IDictionaryEnumerator" /> 提供 <see cref="T:System.Collections.Generic.IDictionary`2" />。</summary>
      <returns>用于 <see cref="T:System.Collections.IDictionaryEnumerator" /> 的 <see cref="T:System.Collections.Generic.IDictionary`2" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
      <summary>从 <see cref="T:System.Collections.IDictionary" /> 中移除包含指定键的元素。</summary>
      <param name="key">要移除的元素的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的枚举数。</summary>
      <returns>用于 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的枚举数。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
      <summary>将 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中存储的键和值对复制到新数组中。</summary>
      <returns>一个新数组，其中包含从 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 复制的键和值对的快照。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
      <summary>尝试将指定的键和值添加到 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中。</summary>
      <param name="key">要添加的元素的键。</param>
      <param name="value">要添加的元素的值。 对于引用类型，该值可以为 <see langword="null" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>如果成功地将键/值对添加到 <see langword="true" />，则为 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />；如果该键已存在，则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 获取与指定的键关联的值。</summary>
      <param name="key">要获取的值的键。</param>
      <param name="value">当此方法返回时，将包含 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中具有指定键的对象；如果操作失败，则包含类型的默认值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果在 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中找到该键，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中移除并返回具有指定键的值。</summary>
      <param name="key">要移除并返回的元素的键。</param>
      <param name="value">当此方法返回时，将包含从 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中移除的对象；如果 <paramref name="key" /> 不存在，则包含 <see langword="TValue" /> 类型。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果成功地移除了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>从字典中移除键和值。</summary>
      <param name="item">
        <see cref="T:System.Collections.Generic.KeyValuePair`2" />，它表示要删除的键和值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="item" /> 的 <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> 属性为 <see langword="null" />。</exception>
      <returns>如果已成功找到并删除 <paramref name="item" /> 代表的键和值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
      <summary>如果具有 <paramref name="key" /> 的现有值等于 <paramref name="comparisonValue" />，则将与 <paramref name="key" /> 关联的值更新为 <paramref name="newValue" />。</summary>
      <param name="key">与 <paramref name="comparisonValue" /> 进行比较并且可能被替换的值键。</param>
      <param name="newValue">一个值，当比较结果相等时，将替换具有指定 <paramref name="key" /> 的元素的值。</param>
      <param name="comparisonValue">与具有指定 <paramref name="key" /> 的元素的值进行比较的值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <returns>如果具有 <see langword="true" /> 的值与 <paramref name="key" /> 相等且被替换为 <paramref name="comparisonValue" />，则为 <paramref name="newValue" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
      <summary>获取包含在 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中的键/值对的数目。</summary>
      <exception cref="T:System.OverflowException">字典包含过多元素。</exception>
      <returns>包含在 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 中的键/值对的数目。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 是否为空。</summary>
      <returns>如果 <see langword="true" /> 为空，则为 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
      <summary>获取或设置与指定的键关联的值。</summary>
      <param name="key">要获取或设置的值的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">已检索该属性且集合中不存在 <paramref name="key" />。</exception>
      <returns>位于指定索引处的键/值对的值。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
      <summary>获得一个包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的键的集合。</summary>
      <returns>
        <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的键的集合。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.ICollection" /> 是否为只读。</summary>
      <returns>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.ICollection" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Keys">
      <summary>获得一个包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的键的集合。</summary>
      <returns>包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的键的集合。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Values">
      <summary>获取包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的值的集合。</summary>
      <returns>包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的值的集合。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
      <summary>获取一个值，它指示对 <see cref="T:System.Collections.ICollection" /> 的访问是否与 SyncRoot 同步。</summary>
      <returns>如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ICollection" />；否则为 <see langword="false" />。 对于 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 此属性，始终返回 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
      <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。 不支持此属性。</summary>
      <exception cref="T:System.NotSupportedException">不支持此属性。</exception>
      <returns>始终返回 null。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.IDictionary`2" /> 是否具有固定大小。</summary>
      <returns>如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.Generic.IDictionary`2" />；否则为 <see langword="false" />。 对于 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />，该属性总是返回 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.IDictionary`2" /> 是否为只读。</summary>
      <returns>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.Generic.IDictionary`2" />；否则为 <see langword="false" />。 对于 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />，该属性总是返回 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
      <summary>获取或设置与指定的键关联的值。</summary>
      <param name="key">要获取或设置的值的键。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentException">将分配一个值，并且 <paramref name="key" /> 属于不能分配给 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的键类型或值类型的类型。</exception>
      <returns>与指定键关联的值；如果 <paramref name="key" /> 不在字典中或 <paramref name="key" /> 属于不能分配给 <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 的键类型的类型，则为 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
      <summary>获取包含 <see cref="T:System.Collections.ICollection" /> 的键的 <see cref="T:System.Collections.Generic.IDictionary`2" />。</summary>
      <returns>包含 <see cref="T:System.Collections.Generic.IDictionary`2" /> 的键的接口。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
      <summary>获取一个包含 <see cref="T:System.Collections.ICollection" /> 中的值的 <see cref="T:System.Collections.IDictionary" />。</summary>
      <returns>包含 <see cref="T:System.Collections.IDictionary" /> 中的值的接口。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
      <summary>获取包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的值的集合。</summary>
      <returns>包含 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的值的集合。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
      <summary>表示线程安全的先进先出 (FIFO) 集合。</summary>
      <typeparam name="T">队列中包含的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 类的新实例，该类包含从指定集合中复制的元素。</summary>
      <param name="collection">其元素被复制到新的 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中的集合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 参数为 null。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Clear">
      <summary>从 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中移除所有对象。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
      <summary>从指定数组索引开始将 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 元素复制到现有一维 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
      <summary>将对象添加到 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 的结尾处。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 末尾的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 的枚举数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 的内容的枚举器。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>尝试将一个对象添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
      <returns>如果成功添加了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中移除和返回一个对象。</summary>
      <param name="item">如果操作成功，则此方法返回时，<paramref name="item" /> 包含所移除的对象。 如果没有可供移除的对象，则不指定该值。</param>
      <returns>如果成功删除并返回了元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentBag`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> 是多维的。 - 或 -<paramref name="array" /> 没有从零开始的索引。 - 或 - <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 的类型无法自动转换为目标 <paramref name="array" /> 的类型。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
      <summary>将 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中存储的元素复制到新数组中。</summary>
      <returns>新数组包含从 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 复制的元素的快照。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
      <summary>尝试移除并返回并发队列开头处的对象。</summary>
      <param name="result">如果操作成功，则此方法返回时，<paramref name="result" /> 包含所移除的对象。 如果没有可供移除的对象，则不指定该值。</param>
      <returns>如果成功在 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 开头处移除并返回了元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
      <summary>尝试返回 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 开头处的对象但不将其移除。</summary>
      <param name="result">此方法返回时，<paramref name="result" /> 包含 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 开头处的对象；如果操作失败，则包含未指定的值。</param>
      <returns>如果成功返回了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
      <summary>获取 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中包含的元素数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 中包含的元素数。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> 是否为空。</summary>
      <returns>如果 <see langword="true" /> 为空，则为 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
      <summary>获取一个指示对 <see cref="T:System.Collections.ICollection" /> 的访问是否与 SyncRoot 同步的值。</summary>
      <returns>始终返回 <see langword="false" /> ，指示未同步访问。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
      <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。 不支持此属性。</summary>
      <exception cref="T:System.NotSupportedException">不支持 SyncRoot 属性。</exception>
      <returns>返回 <see langword="null" />。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
      <summary>表示线程安全的后进先出 (LIFO) 集合。</summary>
      <typeparam name="T">堆栈中包含的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>初始化 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 类的新实例，该类包含从指定集合中复制的元素。</summary>
      <param name="collection">其元素被复制到新的 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中的集合。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> 参数为 null。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
      <summary>从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中移除所有对象。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
      <summary>从指定数组索引开始将 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 元素复制到现有一维 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
      <summary>返回循环访问 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的枚举数。</summary>
      <returns>用于 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的枚举数。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
      <summary>在 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部插入一个对象。</summary>
      <param name="item">要推入到 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
      <summary>自动将多个对象插入 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部。</summary>
      <param name="items">要推入到 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
      <summary>自动将多个对象插入 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部。</summary>
      <param name="items">要推入到 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中的对象。</param>
      <param name="startIndex">
        <paramref name="items" /> 中从零开始的偏移量，在此开始将元素插入到 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部。</param>
      <param name="count">要插入到 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部的元素数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> 或 <paramref name="count" /> 为负数。 或 <paramref name="startIndex" /> 大于或等于 <paramref name="items" /> 的长度。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="items" /> 的长度。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
      <summary>尝试将一个对象添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 的对象。 该值对于引用类型可以是空引用（在 Visual Basic 中为 Nothing）。</param>
      <returns>如果成功添加了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中移除和返回一个对象。</summary>
      <param name="item">如果操作成功，则此方法返回时，<paramref name="item" /> 包含所移除的对象。 如果没有可供移除的对象，则不指定该值。</param>
      <returns>如果成功删除并返回了元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 所复制的元素的目标位置。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> 是多维的。 - 或 -<paramref name="array" /> 没有从零开始的索引。 - 或 - <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。 - 或 - 源 <see cref="T:System.Collections.ICollection" /> 的类型无法自动转换为目标 <paramref name="array" /> 的类型。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>返回循环访问集合的枚举数。</summary>
      <returns>可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
      <summary>将 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中存储的项复制到一个新的数组。</summary>
      <returns>新数组包含从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 复制的元素的快照。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部返回一个对象而无需移除它。</summary>
      <param name="result">当此方法返回时，<paramref name="result" /> 包含来自 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部的一个对象，或者如果操作失败，则包含一个未指定的值。</param>
      <returns>如果成功返回了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
      <summary>尝试弹出并返回 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部的对象。</summary>
      <param name="result">如果操作成功，则此方法返回时，<paramref name="result" /> 包含所移除的对象。 如果没有可供移除的对象，则不指定该值。</param>
      <returns>如果从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 的顶部成功删除并返回了元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
      <summary>尝试自动弹出并返回 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部的多个对象。</summary>
      <param name="items">要将从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部弹出的对象添加到的 <see cref="T:System.Array" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> 是 null 参数（在 Visual Basic 中为 Nothing）。</exception>
      <returns>成功从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部弹出并插入 <paramref name="items" /> 中的对象数。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
      <summary>尝试自动弹出并返回 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部的多个对象。</summary>
      <param name="items">要将从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部弹出的对象添加到的 <see cref="T:System.Array" />。</param>
      <param name="startIndex">
        <paramref name="items" /> 中从零开始的偏移量，在此开始从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部插入元素。</param>
      <param name="count">从 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 顶部弹出并插入 <paramref name="items" /> 中的元素数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="items" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startIndex" /> 或 <paramref name="count" /> 为负数。 或 <paramref name="startIndex" /> 大于或等于 <paramref name="items" /> 的长度。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="items" /> 的长度。</exception>
      <returns>成功从堆栈顶部弹出并插入 <paramref name="items" /> 中的对象数。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
      <summary>获取 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中包含的元素数。</summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 中包含的元素数。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
      <summary>获取一个值，该值指示 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> 是否为空。</summary>
      <returns>如果 <see langword="true" /> 为空，则为 <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
      <summary>获取一个指示对 <see cref="T:System.Collections.ICollection" /> 的访问是否与 SyncRoot 同步的值。</summary>
      <returns>始终返回 <see langword="false" /> ，指示未同步访问。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
      <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。 不支持此属性。</summary>
      <exception cref="T:System.NotSupportedException">不支持 SyncRoot 属性。</exception>
      <returns>返回 <see langword="null" />。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.EnumerablePartitionerOptions">
      <summary>指定控制分区程序的缓冲行为的选项。</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.NoBuffering">
      <summary>创建分区程序，该程序从源可枚举项中一次提取项而不使用中间存储，多个线程可以更有效地访问该存储。 此选项支持低延迟（一从源获得项目就对其进行处理）且部分支持项目间的依赖项（线程无法死锁等待线程自身负责处理的项目）。</summary>
    </member>
    <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.None">
      <summary>使用默认行为，就是使用缓冲实现最佳性能。</summary>
    </member>
    <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
      <summary>定义供制造者/使用者用来操作线程安全集合的方法。 此接口提供一个统一的表示（为生产者/消费者集合），从而更高级别抽象如 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> 可以使用集合作为基础的存储机制。</summary>
      <typeparam name="T">指定集合中的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
      <summary>从指定的索引位置开始，将 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 的元素复制到 <see cref="T:System.Array" /> 中。</summary>
      <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 所复制的元素的目标位置。  
  
该数组的索引必须从零开始。</param>
      <param name="index">
        <paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> 小于零。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" /> 等于或大于 <paramref name="array" /> 的长度 - 或 - 集合中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 结尾的可用空间。</exception>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
      <summary>将 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中包含的元素复制到新数组中。</summary>
      <returns>一个新数组，其中包含从 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 复制的元素。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
      <summary>尝试将一个对象添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中。</summary>
      <param name="item">要添加到 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 的对象。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="item" /> 对于此集合无效。</exception>
      <returns>如果成功添加了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
      <summary>尝试从 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> 中移除和返回一个对象。</summary>
      <param name="item">此方法返回时，如果成功移除并返回了对象，则 <paramref name="item" /> 包含所移除的对象。 如果没有可供移除的对象，则不指定该值。</param>
      <returns>如果成功移除并返回了对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
      <summary>表示将可排序数据源拆分为多个分区的特定方式。</summary>
      <typeparam name="TSource">集合中的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
      <summary>从派生类中的构造函数进行调用以便使用索引键上指定的约束初始化 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 类。</summary>
      <param name="keysOrderedInEachPartition">指示是否按键增加的顺序生成每个分区中的元素。</param>
      <param name="keysOrderedAcrossPartitions">指示前一分区中的元素是否始终排在后一分区中的元素之前。 如果为 true，则分区 0 中的每个元素的顺序键比分区 1 中的任何元素都要小，分区 1 中的每个元素的顺序键比分区 2 中的任何元素都要小，依次类推。</param>
      <param name="keysNormalized">指示是否规范化键。 如果为 true，所有顺序键均为范围 [0 . numberOfElements-1] 中的不同整数。 如果为 false，顺序键仍必须互不相同，但只考虑其相对顺序，而不考虑其绝对值。</param>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
      <summary>创建一个可将基础集合分区成可变数目的分区的对象。</summary>
      <exception cref="T:System.NotSupportedException">该基类不支持动态分区。 它必须在派生类中实现。</exception>
      <returns>一个可针对基础数据源创建分区的对象。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
      <summary>创建一个可将基础集合分区成可变数目的分区的对象。</summary>
      <exception cref="T:System.NotSupportedException">此分区程序不支持动态分区。</exception>
      <returns>一个可针对基础数据源创建分区的对象。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
      <summary>将基础集合分区成指定数目的可排序分区。</summary>
      <param name="partitionCount">要创建的分区数。</param>
      <returns>一个包含 <paramref name="partitionCount" /> 枚举器的列表。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
      <summary>将基础集合分区成给定数目的可排序分区。</summary>
      <param name="partitionCount">要创建的分区数。</param>
      <returns>一个包含 <paramref name="partitionCount" /> 枚举器的列表。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
      <summary>获取是否规范化顺序键。</summary>
      <returns>
        <see langword="true" /> 如果密钥已规范化，则为;否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
      <summary>获取前一分区中的元素是否始终排在后一分区中的元素之前。</summary>
      <returns>
        <see langword="true" /> 如果前面分区中的元素始终位于后面分区的元素之前，则为; 否则为。否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
      <summary>获取是否按键增加的顺序生成每个分区中的元素。</summary>
      <returns>
        <see langword="true" /> 如果按递增键的顺序生成每个分区中的元素，则为; 否则为。否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner">
      <summary>提供针对数组、列表和可枚举项的常见分区策略。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)">
      <summary>创建一个按用户指定的范围划分区块的分区程序。</summary>
      <param name="fromInclusive">范围下限（含）。</param>
      <param name="toExclusive">范围上限（不含）。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="toExclusive" /> 参数小于或等于 <paramref name="fromInclusive" /> 参数。</exception>
      <returns>一个分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)">
      <summary>创建一个按用户指定的范围划分区块的分区程序。</summary>
      <param name="fromInclusive">范围下限（含）。</param>
      <param name="toExclusive">范围上限（不含）。</param>
      <param name="rangeSize">每个子范围的大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="toExclusive" /> 参数小于或等于 <paramref name="fromInclusive" /> 参数。  
  
- 或 - 
<paramref name="rangeSize" /> 参数小于或等于 0。</exception>
      <returns>一个分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)">
      <summary>创建一个按用户指定的范围划分区块的分区程序。</summary>
      <param name="fromInclusive">范围下限（含）。</param>
      <param name="toExclusive">范围上限（不含）。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="toExclusive" /> 参数小于或等于 <paramref name="fromInclusive" /> 参数。</exception>
      <returns>一个分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)">
      <summary>创建一个按用户指定的范围划分区块的分区程序。</summary>
      <param name="fromInclusive">范围下限（含）。</param>
      <param name="toExclusive">范围上限（不含）。</param>
      <param name="rangeSize">每个子范围的大小。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="toExclusive" /> 参数小于或等于 <paramref name="fromInclusive" /> 参数。  
  
- 或 - 
<paramref name="rangeSize" /> 参数小于或等于 0。</exception>
      <returns>一个分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
      <summary>从 <see cref="T:System.Array" /> 实例创建一个可排序分区程序。</summary>
      <param name="array">要进行分区的数组。</param>
      <param name="loadBalance">一个布尔值，该值指示创建的分区程序是否应在各分区之间保持动态负载平衡，而不是静态负载平衡。</param>
      <typeparam name="TSource">源数组中的元素的类型。</typeparam>
      <returns>基于输入数组的可排序分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 实例创建一个可排序分区程序。</summary>
      <param name="source">要进行分区的可枚举项。</param>
      <typeparam name="TSource">源可枚举项中的元素的类型。</typeparam>
      <returns>基于输入数组的可排序分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)">
      <summary>从 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 实例创建一个可排序分区程序。</summary>
      <param name="source">要进行分区的可枚举项。</param>
      <param name="partitionerOptions">控制分区缓冲行为的选项。</param>
      <typeparam name="TSource">源可枚举项中的元素的类型。</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="partitionerOptions" /> 参数为 <see cref="T:System.Collections.Concurrent.EnumerablePartitionerOptions" /> 指定无效值。</exception>
      <returns>基于输入数组的可排序分区程序。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
      <summary>从 <see cref="T:System.Collections.Generic.IList`1" /> 实例创建一个可排序分区程序。</summary>
      <param name="list">要进行分区的列表。</param>
      <param name="loadBalance">一个布尔值，该值指示创建的分区程序是否应在各分区之间保持动态负载平衡，而不是静态负载平衡。</param>
      <typeparam name="TSource">源列表中的元素的类型。</typeparam>
      <returns>基于输入列表的可排序分区程序。</returns>
    </member>
    <member name="T:System.Collections.Concurrent.Partitioner`1">
      <summary>表示将数据源拆分为多个分区的特定方式。</summary>
      <typeparam name="TSource">集合中的元素的类型。</typeparam>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.#ctor">
      <summary>创建新的分区程序实例。</summary>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
      <summary>创建一个可将基础集合分区成可变数目的分区的对象。</summary>
      <exception cref="T:System.NotSupportedException">该基类不支持动态分区。 必须在派生类中实现它。</exception>
      <returns>一个可针对基础数据源创建分区的对象。</returns>
    </member>
    <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
      <summary>将基础集合分区成给定数目的分区。</summary>
      <param name="partitionCount">要创建的分区数。</param>
      <returns>一个包含 <paramref name="partitionCount" /> 枚举器的列表。</returns>
    </member>
    <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
      <summary>获取是否可以动态创建附加分区。</summary>
      <returns>
        <see langword="true" /> 如果 <see cref="T:System.Collections.Concurrent.Partitioner`1" /> 可以在请求时动态创建分区，则为; <see langword="false" /> 如果只能 <see cref="T:System.Collections.Concurrent.Partitioner`1" /> 静态分配分区，则为。</returns>
    </member>
  </members>
</doc>