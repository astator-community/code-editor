<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>当某个线程获取由另一个线程放弃（即在未释放的情况下退出）的 <see cref="T:System.Threading.Mutex" /> 对象时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>使用默认值初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>用被放弃的互斥体的指定索引（如果可用）和表示该互斥体的 <see cref="T:System.Threading.AbandonedMutexException" /> 对象初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      <param name="location">如果对 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法引发异常，则为等待句柄数组中被放弃的互斥体的索引，如果对 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法引发异常，则为 -1。</param>
      <param name="handle">一个 <see cref="T:System.Threading.Mutex" /> 对象，表示被放弃的互斥体。</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。</summary>
      <param name="info">存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，该对象包含有关源或目标的上下文信息。</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>用指定的错误消息初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>用指定的错误信息和内部异常初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="inner">导致当前异常的异常。 如果 <paramref name="inner" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>用指定的错误信息、内部异常、被放弃的互斥体的索引（如果可用）以及表示该互斥体的 <see cref="T:System.Threading.AbandonedMutexException" /> 对象初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="inner">导致当前异常的异常。 如果 <paramref name="inner" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
      <param name="location">如果对 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法引发异常，则为等待句柄数组中被放弃的互斥体的索引，如果对 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法引发异常，则为 -1。</param>
      <param name="handle">一个 <see cref="T:System.Threading.Mutex" /> 对象，表示被放弃的互斥体。</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>用指定的错误信息、被放弃的互斥体的索引（如果可用）以及被放弃的互斥体初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="location">如果对 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法引发异常，则为等待句柄数组中被放弃的互斥体的索引，如果对 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法引发异常，则为 -1。</param>
      <param name="handle">一个 <see cref="T:System.Threading.Mutex" /> 对象，表示被放弃的互斥体。</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>获取导致异常的被放弃的互斥体（如果已知的话）。</summary>
      <returns>如果未能识别被放弃的互斥体，则为表示该被放弃的互斥体的 <see cref="T:System.Threading.Mutex" /> 对象或 <see langword="null" />。</returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>获取导致异常的被放弃的互斥体的索引（如果已知的话）。</summary>
      <returns>传递给方法的等待句柄数组中的索引（ <see cref="Overload:System.Threading.WaitHandle.WaitAny" /><see cref="T:System.Threading.Mutex" /> 表示被放弃的互斥体的对象）; 如果无法确定被放弃的互斥体的索引，则为-1。</returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>提供功能以还原执行上下文在线程之间的迁移（或流动）。</summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>释放 <see cref="T:System.Threading.AsyncFlowControl" /> 类的当前实例所使用的所有资源。</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构未用于在其中创建该结构的线程上。  
  
- 或 - 
<see cref="T:System.Threading.AsyncFlowControl" /> 结构已用于调用 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 或 <see cref="M:System.Threading.AsyncFlowControl.Undo" />。</exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>确定指定对象是否等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</summary>
      <param name="obj">要与当前结构进行比较的对象。</param>
      <returns>如果 <paramref name="obj" /> 是一个 <see cref="T:System.Threading.AsyncFlowControl" /> 结构并且等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>确定指定 <see cref="T:System.Threading.AsyncFlowControl" /> 结构是否等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</summary>
      <param name="obj">要与当前结构进行比较的 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</param>
      <returns>如果 <paramref name="obj" /> 等于当前的 <see cref="T:System.Threading.AsyncFlowControl" /> 结构，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>获取当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构的哈希代码。</summary>
      <returns>当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构的哈希代码。</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>比较两个 <see cref="T:System.Threading.AsyncFlowControl" /> 结构以确定它们是否相等。</summary>
      <param name="a">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</param>
      <param name="b">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</param>
      <returns>如果两个结构相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>比较两个 <see cref="T:System.Threading.AsyncFlowControl" /> 结构以确定它们是否不相等。</summary>
      <param name="a">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</param>
      <param name="b">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</param>
      <returns>如果两个结构不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>还原执行上下文在线程之间的流动。</summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构未用于在其中创建该结构的线程上。  
  
- 或 - 
<see cref="T:System.Threading.AsyncFlowControl" /> 结构已用于调用 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 或 <see cref="M:System.Threading.AsyncFlowControl.Undo" />。</exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>表示对于给定异步控制流（如异步方法）是本地数据的环境数据。</summary>
      <typeparam name="T">环境数据的类型。</typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>实例化不接收更改通知的 <see cref="T:System.Threading.AsyncLocal`1" /> 实例。</summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>实例化接收更改通知的 <see cref="T:System.Threading.AsyncLocal`1" /> 本地实例。</summary>
      <param name="valueChangedHandler">只要当前值在任何线程上发生更改时便会调用的委托。</param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>获取或设置环境数据的值。</summary>
      <returns>环境数据的值。 如果未设置任何值，则返回的值为 <c>默认 (T) </c>。</returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>向针对更改通知进行了注册的 <see cref="T:System.Threading.AsyncLocal`1" /> 实例提供数据更改信息的类。</summary>
      <typeparam name="T">数据的类型。</typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>获取数据的当前值。</summary>
      <returns>数据的当前值。</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>获取数据的上一个值。</summary>
      <returns>数据的上一个值。</returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>返回一个值，该值指示是否由于执行上下文更改而更改了值。</summary>
      <returns>
        <see langword="true" /> 如果值由于执行上下文更改而更改，则为; 否则为。否则为 <see langword="false" /> 。</returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>表示线程同步事件在一个等待线程释放后收到信号时自动重置。 此类不能被继承。</summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>用一个指示是否将初始状态设置为终止的布尔值初始化 <see cref="T:System.Threading.AutoResetEvent" /> 类的新实例。</summary>
      <param name="initialState">若要将初始状态设置为终止，则为 <see langword="true" />；若要将初始状态设置为非终止，则为 <see langword="false" />。</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>使多个任务能够采用并行方式依据某种算法在多个阶段中协同工作。</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>初始化 <see cref="T:System.Threading.Barrier" /> 类的新实例。</summary>
      <param name="participantCount">参与线程的数量。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 小于 0 或大于 32,767。</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>初始化 <see cref="T:System.Threading.Barrier" /> 类的新实例。</summary>
      <param name="participantCount">参与线程的数量。</param>
      <param name="postPhaseAction">在每个阶段后执行 <see cref="T:System.Action`1" />。 可传递 NULL（在 Visual Basic 中为 Nothing）以执行未执行任何操作。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 小于 0 或大于 32,767。</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>通知 <see cref="T:System.Threading.Barrier" />，告知其将会有另一个参与者。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">添加参与者将导致屏障的参与者计数超过 32,767。  
  
 - 或 -  
  
 该方法从阶段后操作中调用。</exception>
      <returns>新参与者将首先参与的屏障的阶段编号。</returns>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>通知 <see cref="T:System.Threading.Barrier" />，告知其将会有多个其他参与者。</summary>
      <param name="participantCount">要添加到屏障的其他参与者的数量。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 小于 0。  
  
- 或 - 
添加 <paramref name="participantCount" /> 参与者将导致屏障的参与者计数超过 32,767。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用。</exception>
      <returns>新参与者将首先参与的屏障的阶段编号。</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>释放 <see cref="T:System.Threading.Barrier" /> 类的当前实例所使用的所有资源。</summary>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用。</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>释放由 <see cref="T:System.Threading.Barrier" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
      <param name="disposing">若要同时释放非托管资源和托管资源，则为 true；如果仅释放非托管资源，则为 false。</param>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>通知 <see cref="T:System.Threading.Barrier" />，告知其将会减少一个参与者。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">屏障已经有 0 个参与者。  
  
 - 或 -  
  
 该方法从阶段后操作中调用。</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>通知 <see cref="T:System.Threading.Barrier" />，告知其将会减少一些参与者。</summary>
      <param name="participantCount">要从屏障中移除的其他参与者的数量。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">参与者总数小于指定 <paramref name="participantCount" /></exception>
      <exception cref="T:System.InvalidOperationException">屏障已经有 0 个参与者。  
  
 - 或 -  
  
 该方法从阶段后操作中调用。  
  
 - 或 -  
  
 当前的参与者计数小于指定 participantCount</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>发出参与者已达到屏障并等待所有其他参与者也达到屏障。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">在所有参与线程调用了 SignalAndWait 之后，如果关卡的后期阶段操作中引发了异常，该异常将包装在 BarrierPostPhaseException 中并在所有参与线程上引发。</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>发出参与者已达到屏障的信号，并等待所有其他参与者也达到屏障，同时使用 32 位带符号整数测量超时。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">在所有参与线程调用了 SignalAndWait 之后，如果关卡的后期阶段操作中引发了异常，该异常将包装在 BarrierPostPhaseException 中并在所有参与线程上引发。</exception>
      <returns>如果所有参与者都已在指定时间内达到屏障，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>发出参与者已达到屏障的信号，并等待所有其他参与者也达到屏障，使用 32 位带符号整数测量超时，同时观察取消标记。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
      <returns>如果所有参与者都已在指定时间内达到屏障，则为 true；否则为 false。</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>发出参与者已达到屏障的信号，并等待所有其他参与者达到屏障，同时观察取消标记。</summary>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>发出参与者已达到屏障的信号，并等待所有其他参与者也达到屏障，同时使用 <see cref="T:System.TimeSpan" /> 对象测量时间间隔。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 32,767。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
      <returns>如果所有其他参与者已到达关卡，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>发出参与者已达到屏障的信号，并等待所有其他参与者也达到屏障，使用 <see cref="T:System.TimeSpan" /> 对象测量时间间隔，同时观察取消标记。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">该方法从阶段后操作中调用，当前屏障具有 0 个参与者，或该屏障被注册为参与者的更多线程终止。</exception>
      <returns>如果所有其他参与者已到达关卡，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>获取屏障的当前阶段的编号。</summary>
      <returns>返回屏障的当前阶段的编号。</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>获取屏障中参与者的总数。</summary>
      <returns>返回屏障中参与者的总数。</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>获取屏障中尚未在当前阶段发出信号的参与者的数量。</summary>
      <returns>返回屏障中尚未在当前阶段发出信号的参与者的数量。</returns>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>
        <see cref="T:System.Threading.Barrier" /> 阶段后操作失败时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>使用说明错误的系统提供的消息初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>使用指定的内部异常初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。</summary>
      <param name="innerException">导致当前异常的异常。</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。</summary>
      <param name="info">承载序列化对象数据的对象。</param>
      <param name="context">关于来源和目标的上下文信息</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>使用说明错误的指定消息初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。</summary>
      <param name="message">描述该异常的消息。 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。</summary>
      <param name="message">描述该异常的消息。 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</param>
      <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>表示要在新的上下文中调用的方法。</summary>
      <param name="state">一个对象，包含回调方法在每次执行时要使用的信息。</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>表示在计数变为零时处于有信号状态的同步基元。</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>使用指定计数初始化 <see cref="T:System.Threading.CountdownEvent" /> 类的新实例。</summary>
      <param name="initialCount">设置 <see cref="T:System.Threading.CountdownEvent" /> 时最初必需的信号数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>将 <see cref="T:System.Threading.CountdownEvent" /> 的当前计数加 1。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">当前实例已设置 。  
  
或 
 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>将 <see cref="T:System.Threading.CountdownEvent" /> 的当前计数增加指定值。</summary>
      <param name="signalCount">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的增量值。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于或等于 0。</exception>
      <exception cref="T:System.InvalidOperationException">当前实例已设置 。  
  
或 
 在计数值增加 <paramref name="signalCount" /> 后，<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>释放 <see cref="T:System.Threading.CountdownEvent" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>释放由 <see cref="T:System.Threading.CountdownEvent" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
      <param name="disposing">为 true 则释放托管资源和非托管资源；为 false 则仅释放非托管资源。</param>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>将 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 重置为 <see cref="P:System.Threading.CountdownEvent.InitialCount" /> 的值。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>将 <see cref="P:System.Threading.CountdownEvent.InitialCount" /> 属性重新设置为指定值。</summary>
      <param name="count">设置 <see cref="T:System.Threading.CountdownEvent" /> 时所必需的信号的数量。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> 小于 0。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>向 <see cref="T:System.Threading.CountdownEvent" /> 注册信号，同时减小 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的值。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">当前实例已设置 。</exception>
      <returns>如果信号导致计数变为零并且设置了事件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>向 <see cref="T:System.Threading.CountdownEvent" /> 注册多个信号，同时将 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的值减少指定数量。</summary>
      <param name="signalCount">要注册的信号的数量。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于 1。</exception>
      <exception cref="T:System.InvalidOperationException">当前实例已设置 。 - 或 - <paramref name="signalCount" /> 大于 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />。</exception>
      <returns>如果信号导致计数变为零并且设置了事件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>增加一个 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的尝试。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果成功增加，则为 <see langword="true" />；否则为 false。 如果 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 已为零，则此方法将返回 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>增加指定值的 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的尝试。</summary>
      <param name="signalCount">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的增量值。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于或等于 0。</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果成功增加，则为 <see langword="true" />；否则为 false。 如果 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 已为零，则此方法将返回 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止，同时使用 32 位带符号整数测量超时。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.CountdownEvent" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止，并使用 32 位带符号整数测量超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。 - 或 - 创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.CountdownEvent" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。 - 或 - 创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止，同时使用 <see cref="T:System.TimeSpan" /> 测量超时。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.CountdownEvent" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到设置了 <see cref="T:System.Threading.CountdownEvent" /> 为止，并使用 <see cref="T:System.TimeSpan" /> 测量超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。 - 或 - 创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.CountdownEvent" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>获取设置事件时所必需的剩余信号数。</summary>
      <returns>设置事件时所必需的剩余信号数。</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>获取设置事件时最初必需的信号数。</summary>
      <returns>设置事件时最初必需的信号数。</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>表示 <see cref="T:System.Threading.CountdownEvent" /> 对象的当前计数是否已归零。</summary>
      <returns>如果当前的计数为零，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>获取用于等待要设置的事件的 <see cref="T:System.Threading.WaitHandle" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <returns>用于等待要设置的事件的 <see cref="T:System.Threading.WaitHandle" />。</returns>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>指示在接收信号后是自动重置 <see cref="T:System.Threading.EventWaitHandle" /> 还是手动重置。</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>当终止时，<see cref="T:System.Threading.EventWaitHandle" /> 在释放一个线程后自动重置。 如果没有等待的线程，<see cref="T:System.Threading.EventWaitHandle" /> 将保持终止状态直到一个线程阻止，并在释放此线程后重置。</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>当终止时，<see cref="T:System.Threading.EventWaitHandle" /> 释放所有等待的线程，并在手动重置前保持终止状态。</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>表示一个线程同步事件。</summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，并指定等待句柄最初是否处于终止状态，以及它是自动重置还是手动重置。</summary>
      <param name="initialState">如果为 <see langword="true" />，则将初始状态设置为终止；如果为 <see langword="false" />，则将初始状态设置为非终止。</param>
      <param name="mode">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，并指定在此调用后创建的等待句柄最初是否处于终止状态，它是自动重置还是手动重置，以及系统同步事件的名称。</summary>
      <param name="initialState">如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。</param>
      <param name="mode">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</param>
      <param name="name">系统范围的同步事件名称。</param>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名事件，可能是因为其他类型的等待句柄具有相同名称。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，指定如果将等待句柄作为此调用的结果而创建，最初是否通过信号通知此句柄；指定是否自动或手动重置系统同步事件的名称，以及一个布尔变量，在调用后其值指示是否创建了命名的系统事件。</summary>
      <param name="initialState">如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。</param>
      <param name="mode">其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。</param>
      <param name="name">系统范围的同步事件名称。</param>
      <param name="createdNew">在此方法返回时，如果创建了本地事件（即，如果 <paramref name="name" /> 为 <see langword="true" /> 或空字符串）或指定的命名系统事件，则包含 <see langword="null" />；如果指定的命名系统事件已存在，则为 <see langword="false" />。 此参数未经初始化即被传递。</param>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名事件，可能是因为其他类型的等待句柄具有相同名称。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>打开指定名称为同步事件（如果已经存在）。</summary>
      <param name="name">要打开的系统同步事件的名称。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">命名的系统事件不存在。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">已命名的事件存在，但用户不具备使用它所需的安全访问权限。</exception>
      <returns>一个对象，表示已命名的系统事件。</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>将事件状态设置为非终止，从而导致线程受阻。</summary>
      <exception cref="T:System.ObjectDisposedException">之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。</exception>
      <returns>如果该操作成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>将事件状态设置为有信号，从而允许一个或多个等待线程继续执行。</summary>
      <exception cref="T:System.ObjectDisposedException">之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。</exception>
      <returns>如果该操作成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>打开指定的命名同步事件（如果已经存在），返回指示操作是否成功的值。</summary>
      <param name="name">要打开的系统同步事件的名称。</param>
      <param name="result">当此方法返回时，如果调用成功，则包含表示命名同步事件的 <see cref="T:System.Threading.EventWaitHandle" /> 对象；如果调用失败，则为 <see langword="null" />。 该参数未经初始化即被处理。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">命名事件存在，但用户不具有所需的安全访问权限。</exception>
      <returns>如果成功打开命名同步事件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>管理当前线程的执行上下文。 此类不能被继承。</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>从当前线程捕获执行上下文。</summary>
      <returns>一个 <see cref="T:System.Threading.ExecutionContext" /> 对象，表示当前线程的执行上下文。</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>创建当前执行上下文的副本。</summary>
      <exception cref="T:System.InvalidOperationException">此上下文正在使用，无法进行复制。 只能复制新捕获的上下文。</exception>
      <returns>一个 <see cref="T:System.Threading.ExecutionContext" /> 对象，表示当前执行上下文。</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>释放 <see cref="T:System.Threading.ExecutionContext" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用重新创建当前执行上下文的实例所需的逻辑上下文信息设置指定的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</summary>
      <param name="info">要用序列化信息填充的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
      <param name="context">表示序列化的目标上下文的 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 结构。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> 上声明的默认值为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>指示当前是否取消了执行上下文的流动。</summary>
      <returns>如果取消了流动，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.Restore(System.Threading.ExecutionContext)">
      <summary>将捕获的执行上下文还原到当前线程。</summary>
      <param name="executionContext">要设置的 ExecutionContext。</param>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>恢复执行上下文在异步线程之间的流动。</summary>
      <exception cref="T:System.InvalidOperationException">上下文流尚未取消，无法还原。</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>在当前线程上的指定执行上下文中运行某个方法。</summary>
      <param name="executionContext">要设置的 <see cref="T:System.Threading.ExecutionContext" />。</param>
      <param name="callback">一个 <see cref="T:System.Threading.ContextCallback" /> 委托，表示要在提供的执行上下文中运行的方法。</param>
      <param name="state">要传递给回调方法的对象。</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> 上声明的默认值为 <see langword="null" />。  
  
或 
 <paramref name="executionContext" /> 不是通过捕获操作获取的。  
  
或 
 <paramref name="executionContext" /> 已用作 <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" /> 调用的参数。</exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>取消执行上下文在异步线程之间的流动。</summary>
      <exception cref="T:System.InvalidOperationException">上下文流已取消。</exception>
      <returns>用于恢复流动的 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>在线程之间封装并传播宿主执行上下文。</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>初始化 <see cref="T:System.Threading.HostExecutionContext" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>使用指定的状态初始化 <see cref="T:System.Threading.HostExecutionContext" /> 类的新实例。</summary>
      <param name="state">一个表示宿主执行上下文状态的对象。</param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>创建当前宿主执行上下文的副本。</summary>
      <returns>一个 <see cref="T:System.Threading.HostExecutionContext" /> 对象，表示当前线程的宿主上下文。</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>释放 <see cref="T:System.Threading.HostExecutionContext" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。</summary>
      <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>获取或设置宿主执行上下文的状态。</summary>
      <returns>一个表示宿主执行上下文状态的对象。</returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>提供使公共语言运行时宿主可以参与执行上下文的流动（或移植）的功能。</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>初始化 <see cref="T:System.Threading.HostExecutionContextManager" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>从当前线程捕获宿主执行上下文。</summary>
      <returns>一个 <see cref="T:System.Threading.HostExecutionContext" /> 对象，表示当前线程的宿主执行上下文。</returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>将宿主执行上下文还原为其以前的状态。</summary>
      <param name="previousState">要恢复为的以前的上下文状态。</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> 为 <see langword="null" />。  
  
- 或 - 
 未对当前线程创建 <paramref name="previousState" />。  
  
- 或 - 
 <paramref name="previousState" /> 不是 <see cref="T:System.Threading.HostExecutionContext" /> 的最后的状态。</exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>将当前宿主执行上下文设置为指定的宿主执行上下文。</summary>
      <param name="hostExecutionContext">要设置的 <see cref="T:System.Threading.HostExecutionContext" />。</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> 不是通过捕获操作获取的。  
  
- 或 - 
 <paramref name="hostExecutionContext" /> 已作为上一次 <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" /> 方法调用的参数。</exception>
      <returns>一个对象，用于将 <see cref="T:System.Threading.HostExecutionContext" /> 还原为其以前的状态。</returns>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>为多个线程共享的变量提供原子操作。</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要添加的第一个值。 两个值的和存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要添加到整数中的 <paramref name="location1" /> 位置的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>存储在 <paramref name="location1" /> 处的新值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>对两个 64 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要添加的第一个值。 两个值的和存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要添加到整数中的 <paramref name="location1" /> 位置的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>存储在 <paramref name="location1" /> 处的新值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.UInt32@,System.UInt32)">
      <summary>对两个 32 位无符号整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要添加的第一个值。 两个值的和存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要添加到整数中的 <paramref name="location1" /> 位置的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>存储在 <paramref name="location1" /> 处的新值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.UInt64@,System.UInt64)">
      <summary>对两个 64 位无符号整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要添加的第一个值。 两个值的和存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要添加到整数中的 <paramref name="location1" /> 位置的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>存储在 <paramref name="location1" /> 处的新值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.Int32@,System.Int32)">
      <summary>对两个 32 位带符号整数进行按位“与”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.Int64@,System.Int64)">
      <summary>对两个 64 位带符号整数进行按位“与”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.UInt32@,System.UInt32)">
      <summary>对两个 32 位无符号整数进行按位“与”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.And(System.UInt64@,System.UInt64)">
      <summary>对两个 64 位无符号整数进行按位“与”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>比较两个双精度浮点数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>比较两个 32 位有符号整数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>比较两个 64 位有符号整数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>比较两个平台特定的句柄或指针是否相等，如果相等，则替换第一个。</summary>
      <param name="location1">其值与 <paramref name="comparand" /> 的值进行比较并且可能被 <paramref name="value" /> 替换的目标 <see cref="T:System.IntPtr" />。</param>
      <param name="value">比较结果相等时替换目标值的 <see cref="T:System.IntPtr" />。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的 <see cref="T:System.IntPtr" />。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>比较两个对象是否引用相等，如果相等，则替换第一个对象。</summary>
      <param name="location1">通过引用与 <paramref name="comparand" /> 进行比较并且可能被替换的目标对象。</param>
      <param name="value">在引用比较结果相等时替换目标对象的对象。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的对象通过引用进行比较的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>比较两个单精度浮点数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.UInt32@,System.UInt32,System.UInt32)">
      <summary>比较两个 32 位无符号整数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.UInt64@,System.UInt64,System.UInt64)">
      <summary>比较两个 64 位无符号整数是否相等，如果相等，则替换第一个值。</summary>
      <param name="location1">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</param>
      <param name="value">比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值进行比较的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>比较指定的引用类型 <paramref name="T" /> 的两个实例是否引用相等，如果相等，则替换第一个。</summary>
      <param name="location1">其值通过引用与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。 这是一个引用参数（在 C# 中是 <see langword="ref" />，在 Visual Basic 中是 <see langword="ByRef" />）。</param>
      <param name="value">引用比较结果相等时替换目标值的值。</param>
      <param name="comparand">与位于 <paramref name="location1" /> 处的值通过引用进行比较的值。</param>
      <typeparam name="T">用于 <paramref name="location1" />、<paramref name="value" /> 和 <paramref name="comparand" /> 的类型。 此类型必须是引用类型。</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>以原子操作的形式递减指定变量的值并存储结果。</summary>
      <param name="location">其值要递减的变量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递减的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>以原子操作的形式递减指定变量的值并存储结果。</summary>
      <param name="location">其值要递减的变量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递减的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.UInt32@)">
      <summary>以原子操作的形式递减指定变量的值并存储结果。</summary>
      <param name="location">其值要递减的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递减的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.UInt64@)">
      <summary>以原子操作的形式递减指定变量的值并存储结果。</summary>
      <param name="location">其值要递减的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递减的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>以原子操作的形式，将双精度浮点数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>以原子操作的形式，将 32 位有符号整数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>以原子操作的形式，将 64 位有符号整数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>以原子操作的形式，将平台特定的句柄或指针设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>以原子操作的形式，将对象设置为指定的值并返回对原始对象的引用。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>以原子操作的形式，将单精度浮点数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.UInt32@,System.UInt32)">
      <summary>以原子操作的形式，将 32 位无符号整数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.UInt64@,System.UInt64)">
      <summary>以原子操作的形式，将 64 位无符号整数设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>以原子操作的形式，将指定类型 <paramref name="T" /> 的变量设置为指定的值并返回原始值。</summary>
      <param name="location1">要设置为指定值的变量。 这是一个引用参数（C# 中为 <see langword="ref" />，Visual Basic 中为 <see langword="ByRef" />）。</param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。</param>
      <typeparam name="T">要用于 <paramref name="location1" /> 和 <paramref name="value" /> 的类型。 此类型必须是引用类型。</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>以原子操作的形式递增指定变量的值并存储结果。</summary>
      <param name="location">其值要递增的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递增的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>以原子操作的形式递增指定变量的值并存储结果。</summary>
      <param name="location">其值要递增的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递增的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.UInt32@)">
      <summary>以原子操作的形式递增指定变量的值并存储结果。</summary>
      <param name="location">其值要递增的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递增的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.UInt64@)">
      <summary>以原子操作的形式递增指定变量的值并存储结果。</summary>
      <param name="location">其值要递增的变量。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>递增的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 调用之后的内存存取，再执行 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 调用之前的内存存取的方式。</summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
      <summary>提供覆盖整个过程的内存屏障，确保来自任何 CPU 的读写都不能越过该屏障。</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.Int32@,System.Int32)">
      <summary>对两个 32 位带符号整数进行按位“或”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.Int64@,System.Int64)">
      <summary>对两个 64 位带符号整数进行按位“或”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.UInt32@,System.UInt32)">
      <summary>对两个 32 位无符号整数进行按位“或”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Or(System.UInt64@,System.UInt64)">
      <summary>对两个 64 位无符号整数进行按位“或”运算，并用结果替换第一个整数，上述操作作为一个原子操作完成。</summary>
      <param name="location1">一个变量，包含要组合的第一个值。 结果存储在 <paramref name="location1" /> 中。</param>
      <param name="value">要与 <paramref name="location1" /> 中的整数进行组合的值。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址是一个 <see langword="null" /> 指针。</exception>
      <returns>
        <paramref name="location1" /> 中的原始值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>返回一个以原子操作形式加载的 64 位值。</summary>
      <param name="location">要加载的 64 位值。</param>
      <returns>加载的值。</returns>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.UInt64@)">
      <summary>返回一个以原子操作形式加载的 64 位无符号值。</summary>
      <param name="location">要加载的 64 位值。</param>
      <returns>加载的值。</returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>提供延迟初始化例程。</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>在目标引用或值类型尚未初始化的情况下，使用其类型的无参数构造函数初始化目标引用类型。</summary>
      <param name="target">要初始化的引用（如果尚未初始化）。 如果是 <see langword="null" />，则将其视为未初始化；否则，将其视为已初始化。</param>
      <typeparam name="T">要初始化的引用的类型。</typeparam>
      <exception cref="T:System.MemberAccessException">缺少访问类型 <paramref name="T" /> 的构造函数的权限。</exception>
      <exception cref="T:System.MissingMemberException">
        <paramref name="T" /> 类型没有无参数构造函数。</exception>
      <returns>已初始化的对象。</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>在目标引用或值类型尚未初始化的情况下，使用其无参数构造函数对其进行初始化。</summary>
      <param name="target">在尚未初始化的情况下，要初始化的类型 <c>T</c> 的引用或值。</param>
      <param name="initialized">对布尔值的引用，该值确定目标是否已初始化。</param>
      <param name="syncLock">对用作相互排斥锁的对象的引用，用于初始化 <paramref name="target" />。 如果 <paramref name="syncLock" /> 为 <see langword="null" />，则新的对象将被实例化。</param>
      <typeparam name="T">要初始化的引用的类型。</typeparam>
      <exception cref="T:System.MemberAccessException">缺少访问类型 <paramref name="T" /> 的构造函数的权限。</exception>
      <exception cref="T:System.MissingMemberException">
        <paramref name="T" /> 类型没有无参数构造函数。</exception>
      <returns>已初始化的对象。</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>在目标引用或值类型尚未初始化的情况下，使用指定函数初始化目标引用或值类型。</summary>
      <param name="target">在尚未初始化的情况下，要初始化的类型 <c>T</c> 的引用或值。</param>
      <param name="initialized">对布尔值的引用，该值确定目标是否已初始化。</param>
      <param name="syncLock">对用作相互排斥锁的对象的引用，用于初始化 <paramref name="target" />。 如果 <paramref name="syncLock" /> 为 <see langword="null" />，则新的对象将被实例化。</param>
      <param name="valueFactory">调用函数以初始化该引用或值。</param>
      <typeparam name="T">要初始化的引用的类型。</typeparam>
      <exception cref="T:System.MemberAccessException">缺少访问类型 <paramref name="T" /> 的构造函数的权限。</exception>
      <exception cref="T:System.MissingMemberException">
        <paramref name="T" /> 类型没有无参数构造函数。</exception>
      <returns>已初始化的对象。</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>在目标引用类型尚未初始化的情况下，使用指定函数初始化目标引用类型。</summary>
      <param name="target">要初始化的引用（如果尚未初始化）。</param>
      <param name="valueFactory">调用函数以初始化该引用。</param>
      <typeparam name="T">要初始化的引用的类型。</typeparam>
      <exception cref="T:System.MissingMemberException">
        <paramref name="T" /> 类型没有无参数构造函数。</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> 返回 null（在 Visual Basic 中为 Nothing）。</exception>
      <returns>已初始化的对象。</returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <summary>在目标引用类型尚未初始化的情况下，使用指定函数初始化目标引用类型。</summary>
      <param name="target">要初始化的引用（如果尚未初始化）。 如果是 <see langword="null" />，则将其视为未初始化；否则，将其视为已初始化。</param>
      <param name="syncLock">对用作相互排斥锁的对象的引用，用于初始化 <paramref name="target" />。 如果 <paramref name="syncLock" /> 为 <see langword="null" />，则新的对象将被实例化。</param>
      <param name="valueFactory">为初始化 <paramref name="target" /> 而调用的方法。</param>
      <typeparam name="T">要初始化的引用的类型。</typeparam>
      <returns>已初始化的对象。</returns>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>定义实现单个编写器/多个阅读器语义的锁。 这是值类型。</summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>指示指定的对象是否为 <see cref="T:System.Threading.LockCookie" /> 并且等于当前实例。</summary>
      <param name="obj">要与当前类型进行比较的对象。</param>
      <returns>如果 <paramref name="obj" /> 的值等于当前实例的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>指示当前实例是否等于指定的 <see cref="T:System.Threading.LockCookie" />。</summary>
      <param name="obj">要与当前实例进行比较的 <see cref="T:System.Threading.LockCookie" />。</param>
      <returns>如果 <paramref name="obj" /> 等于当前实例的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>返回此实例的哈希代码。</summary>
      <returns>32 位有符号整数哈希代码。</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>指示两个 <see cref="T:System.Threading.LockCookie" /> 结构是否相等。</summary>
      <param name="a">要与 <paramref name="b" /> 进行比较的 <see cref="T:System.Threading.LockCookie" />。</param>
      <param name="b">要与 <paramref name="a" /> 进行比较的 <see cref="T:System.Threading.LockCookie" />。</param>
      <returns>如果 <see langword="true" /> 等于 <paramref name="a" />，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>指示两个 <see cref="T:System.Threading.LockCookie" /> 结构是否不相等。</summary>
      <param name="a">要与 <paramref name="b" /> 进行比较的 <see cref="T:System.Threading.LockCookie" />。</param>
      <param name="b">要与 <paramref name="a" /> 进行比较的 <see cref="T:System.Threading.LockCookie" />。</param>
      <returns>如果 <see langword="true" /> 不等于 <paramref name="a" />，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>当进入锁定状态的递归与此锁定的递归策略不兼容时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>使用说明错误的系统提供的消息初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。</summary>
      <param name="info">承载序列化对象数据的对象。</param>
      <param name="context">关于来源和目标的上下文信息</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>使用说明错误的指定消息初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。</summary>
      <param name="message">描述该异常的消息。 此构造函数的调用方必须确保此字符串已针对当前系统区域性进行了本地化。</param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。</summary>
      <param name="message">描述该异常的消息。 此构造函数的调用方必须确保此字符串已针对当前系统区域性进行了本地化。</param>
      <param name="innerException">引发当前异常的异常。 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>指定同一个线程是否可以多次进入一个锁定状态。</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>如果线程尝试以递归方式进入锁定状态，将引发异常。 某些类可能会在此设置生效时允许使用特定的递归方式。</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>线程可以采用递归方式进入锁定状态。 某些类可能会限制此功能。</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>表示线程同步事件，收到信号时，必须手动重置该事件。 此类不能被继承。</summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>用一个指示是否将初始状态设置为终止的布尔值初始化 <see cref="T:System.Threading.ManualResetEvent" /> 类的新实例。</summary>
      <param name="initialState">如果为 <see langword="true" />，则将初始状态设置为终止；如果为 <see langword="false" />，则将初始状态设置为非终止。</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>表示线程同步事件，收到信号时，必须手动重置该事件。 此类是 <see cref="T:System.Threading.ManualResetEvent" /> 的轻量替代项。</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>使用无信号初始状态初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>用一个指示是否将初始状态设置为终止的布尔值初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 类的新实例。</summary>
      <param name="initialState">若要将初始状态设置为终止，则为 true；若要将初始状态设置为非终止，则为 false。</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>使用一个指示是否将初始状态设置为有信号和指定自旋计数的布尔值初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 类的新实例。</summary>
      <param name="initialState">若要将初始状态设置为终止，则为 true；若要将初始状态设置为非终止，则为 false。</param>
      <param name="spinCount">在回退到基于内核的等待操作之前发生的自旋等待数量。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> 小于 0 或大于允许的最大值。</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>释放 <see cref="T:System.Threading.ManualResetEventSlim" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>释放由 <see cref="T:System.Threading.ManualResetEventSlim" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
      <param name="disposing">若要同时释放非托管资源和托管资源，则为 true；如果仅释放非托管资源，则为 false。</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>将事件状态设置为非终止，从而导致线程受阻。</summary>
      <exception cref="T:System.ObjectDisposedException">对象已被释放。</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>将事件状态设置为有信号，从而允许一个或多个等待该事件的线程继续。</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>阻止当前线程，直到设置了当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 为止。</summary>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.ObjectDisposedException">对象已被释放。</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>阻止当前线程，直到设置了当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 为止，同时使用 32 位带符号整数测量时间间隔。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.ObjectDisposedException">对象已被释放。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.ManualResetEventSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到设置了当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 为止，并使用 32 位带符号整数测量时间间隔，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.ObjectDisposedException">该对象已被释放，或者创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.ManualResetEventSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 收到信号为止，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">该对象已被释放，或者创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>阻止当前线程，直到设置了当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 为止，同时使用 <see cref="T:System.TimeSpan" /> 测量时间间隔。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。 
- 或 - 
<paramref name="timeout" /> 中的毫秒数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.ObjectDisposedException">对象已被释放。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.ManualResetEventSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直到设置了当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 为止，并使用 <see cref="T:System.TimeSpan" /> 测量时间间隔，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。 
- 或 - 
<paramref name="timeout" /> 中的毫秒数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.InvalidOperationException">已超出最大等待者数</exception>
      <exception cref="T:System.ObjectDisposedException">该对象已被释放，或者创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <returns>如果已设置 <see cref="T:System.Threading.ManualResetEventSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>获取是否已设置事件。</summary>
      <returns>如果设置了事件，则为 true；否则为 false。</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>获取在回退到基于内核的等待操作之前将发生的自旋等待数量。</summary>
      <returns>返回在回退到基于内核的等待操作之前将发生的自旋等待数量。</returns>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>获取此 <see cref="T:System.Threading.WaitHandle" /> 的基础 <see cref="T:System.Threading.ManualResetEventSlim" /> 对象。</summary>
      <returns>此的基础 <see cref="T:System.Threading.WaitHandle" /> 事件对象 <see cref="T:System.Threading.ManualResetEventSlim" /> 。</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>提供同步访问对象的机制。</summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>在指定对象上获取排他锁。</summary>
      <param name="obj">在其上获取监视器锁的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。  
  
注意   如果没有发生异常，则此方法的输出始终为 <see langword="true" />。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>释放指定对象上的排他锁。</summary>
      <param name="obj">在其上释放锁的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">当前线程不拥有指定对象的锁。</exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>确定当前线程是否保留指定对象上的锁。</summary>
      <param name="obj">要测试的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 为 <see langword="null" />。</exception>
      <returns>如果当前线程持有 <paramref name="obj" /> 锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>通知等待队列中的线程锁定对象状态的更改。</summary>
      <param name="obj">线程正在等待的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>通知所有的等待线程对象状态的更改。</summary>
      <param name="obj">发送脉冲的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>尝试获取指定对象的排他锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>在指定的毫秒数内尝试获取指定对象上的排他锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>在指定的毫秒数内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <param name="millisecondsTimeout">等待锁所需的毫秒数。</param>
      <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>在指定的时间内尝试获取指定对象上的排他锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示等待锁所需的时间量。 值为 -1 毫秒表示指定无限期等待。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>在指定的一段时间内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获得了该锁。</summary>
      <param name="obj">在其上获取锁的对象。</param>
      <param name="timeout">用于等待锁的时间。 值为 -1 毫秒表示指定无限期等待。</param>
      <param name="lockTaken">尝试获取锁的结果，通过引用传递。 输入必须为 <see langword="false" />。 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。 即使在尝试获取锁的过程中发生异常，也会设置输出。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
      <returns>如果调用由于调用方重新获取了指定对象的锁而返回，则为 <see langword="true" />。 如果未重新获取该锁，则此方法不会返回。</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 此方法还指定是否在等待之前退出上下文的同步域（如果在同步上下文中）然后重新获取该同步域。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <param name="millisecondsTimeout">线程进入就绪队列之前等待的毫秒数。</param>
      <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 参数值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">调用线程不拥有指定对象的锁。</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">调用 <see langword="Wait" /> 的线程稍后从等待状态中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 参数的值（以毫秒计）为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>释放对象上的锁并阻止当前线程，直到它重新获取该锁。 如果已用指定的超时时间间隔，则线程进入就绪队列。 可以在等待之前退出同步上下文的同步域，随后重新获取该域。</summary>
      <param name="obj">要在其上等待的对象。</param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。</param>
      <param name="exitContext">如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> 不是从同步的代码块中调用的。</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">调用 Wait 的线程稍后会从等待状态中中断。 另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 参数为负数且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。 此方法只有在重新获取该锁后才会返回。</returns>
    </member>
    <member name="P:System.Threading.Monitor.LockContentionCount">
      <summary>获取尝试锁定监视器时出现争用的次数。</summary>
      <returns>尝试获取监视器锁时存在争用的次数。</returns>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>还可用于进程间同步的同步基元。</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>使用默认属性初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      <param name="initiallyOwned">如果给调用线程赋予互斥体的初始所属权，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      <param name="initiallyOwned">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</param>
      <param name="name">
        <see cref="T:System.Threading.Mutex" /> 的名称。 如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。</param>
      <exception cref="T:System.UnauthorizedAccessException">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</summary>
      <param name="initiallyOwned">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</param>
      <param name="name">
        <see cref="T:System.Threading.Mutex" /> 的名称。 如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。</param>
      <param name="createdNew">在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。 此参数未经初始化即被传递。</param>
      <exception cref="T:System.UnauthorizedAccessException">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>打开指定的已命名的互斥体（如果已经存在）。</summary>
      <param name="name">要打开的系统互斥体的名称。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">命名的 mutex 不存在。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</exception>
      <returns>表示已命名的系统互斥体的对象。</returns>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>释放 <see cref="T:System.Threading.Mutex" /> 一次。</summary>
      <exception cref="T:System.ApplicationException">调用线程不拥有互斥体。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</summary>
      <param name="name">要打开的系统互斥体的名称。</param>
      <param name="result">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。 该参数未经初始化即被处理。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</exception>
      <returns>如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>定义支持单个写线程和多个读线程的锁。</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>初始化 <see cref="T:System.Threading.ReaderWriterLock" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>使用一个 <see cref="T:System.Int32" /> 超时值获取读线程锁。</summary>
      <param name="millisecondsTimeout">以毫秒为单位的超时。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> 在授予锁定请求前过期。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>使用一个 <see cref="T:System.TimeSpan" /> 超时值获取读线程锁。</summary>
      <param name="timeout">一个 <see langword="TimeSpan" />，用于指定超时时间。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 在授予锁定请求前过期。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>使用一个 <see cref="T:System.Int32" /> 超时值获取写线程锁。</summary>
      <param name="millisecondsTimeout">以毫秒为单位的超时。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 在授予锁定请求前过期。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>使用一个 <see cref="T:System.TimeSpan" /> 超时值获取写线程锁。</summary>
      <param name="timeout">
        <see langword="TimeSpan" />，用于指定超时时间。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 在授予锁定请求前过期。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>指示获取序列号之后是否已将写线程锁授予某个线程。</summary>
      <param name="seqNum">序列号。</param>
      <returns>如果获取序列号之后已将写线程锁授予某一线程，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 前的状态。</summary>
      <param name="lockCookie">一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 返回。</param>
      <exception cref="T:System.ApplicationException">线程没有写线程锁。</exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="lockCookie" /> 的地址为空指针。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>释放锁，不管线程获取锁的次数如何。</summary>
      <returns>一个 <see cref="T:System.Threading.LockCookie" /> 值，表示释放的锁。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>减少锁计数。</summary>
      <exception cref="T:System.ApplicationException">线程没有读线程锁或写线程锁。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>减少写线程锁上的锁计数。</summary>
      <exception cref="T:System.ApplicationException">线程没有写线程锁。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 前的状态。</summary>
      <param name="lockCookie">一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 返回。</param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="lockCookie" /> 的地址为空指针。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>使用一个 <see cref="T:System.Int32" /> 超时值将读线程锁升级为写线程锁。</summary>
      <param name="millisecondsTimeout">以毫秒为单位的超时。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> 在授予锁定请求前过期。</exception>
      <returns>一个 <see cref="T:System.Threading.LockCookie" /> 值。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>使用一个 <see langword="TimeSpan" /> 超时值将读线程锁升级为写线程锁。</summary>
      <param name="timeout">
        <see langword="TimeSpan" />，用于指定超时时间。</param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 在授予锁定请求前过期。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 可指定 -1 毫秒以外的任何负值。</exception>
      <returns>一个 <see cref="T:System.Threading.LockCookie" /> 值。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>获取一个值，该值指示当前线程是否持有读线程锁。</summary>
      <returns>如果当前线程持有读线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>获取一个值，该值指示当前线程是否持有写线程锁。</summary>
      <returns>如果当前线程持有写线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>获取当前序列号。</summary>
      <returns>当前序列号。</returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>使用默认属性值初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>在指定锁定递归策略的情况下初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
      <param name="recursionPolicy">枚举值之一，用于指定锁定递归策略。</param>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>释放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的当前实例所使用的所有资源。</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大于零。  
  
- 或 - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大于零。  
  
- 或 - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大于零。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>尝试进入读取模式锁定状态。</summary>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有读取锁定时已尝试获取读取锁定。  
  
- 或 - 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有写入锁定时已尝试获取读取锁定。  
  
- 或 - 
递归数将超出该计数器的容量。 此限值很大，因此应用程序应该不会遇到此异常。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>尝试进入可升级模式锁定状态。</summary>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
- 或 - 
当前线程已进入读取模式，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>尝试进入写入模式锁定状态。</summary>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
- 或 - 
当前线程已进入读取模式且尚无写锁定，因此尝试进入写入模式锁定状态将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入读取模式锁定状态。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入可升级模式锁定状态。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入写入模式锁定状态。</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>尝试进入读取模式锁定状态，可以选择整数超时时间。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>尝试进入读取模式锁定状态，可以选择超时时间。</summary>
      <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
      <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
      <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
- 或 - 
初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
- 或 - 
递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
- 或 - 
<paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      <returns>如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>获取已进入读取模式锁定状态的独有线程的总数。</summary>
      <returns>已进入读取模式锁定状态的独有线程的数量。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。</summary>
      <returns>如果当前线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>获取一个值，该值指示当前线程是否已进入可升级模式的锁定状态。</summary>
      <returns>如果当前线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。</summary>
      <returns>如果当前线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>获取一个值，该值指示当前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象的递归策略。</summary>
      <returns>枚举值之一，用于指定锁定递归策略。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>获取当前线程进入读取模式锁定状态的次数，用于指示递归。</summary>
      <returns>0 (零) 如果当前线程未进入读取模式，则为 1; 如果线程已进入读取模式但尚未以递归方式进入，则为 1; 如果线程已以递归方式进入锁定状态，则为n 。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>获取当前线程进入可升级模式锁定状态的次数，用于指示递归。</summary>
      <returns>如果当前线程未进入可升级模式，则为 0; 如果线程已进入可升级模式但尚未以递归方式进入，则为 1; 如果线程已进入可升级模式，则为 n -1 次。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>获取当前线程进入写入模式锁定状态的次数，用于指示递归。</summary>
      <returns>如果当前线程未进入写入模式，则为 0; 如果线程已进入写入模式但尚未以递归方式进入写入模式，则为 1; 如果线程已进入写入模式，则为n 。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>获取等待进入读取模式锁定状态的线程总数。</summary>
      <returns>等待进入读取模式的线程总数。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>获取等待进入可升级模式锁定状态的线程总数。</summary>
      <returns>等待进入可升级模式的线程总数。</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>获取等待进入写入模式锁定状态的线程总数。</summary>
      <returns>等待进入写入模式的线程总数。</returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>限制可同时访问某一资源或资源池的线程数。</summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数。</summary>
      <param name="initialCount">可以同时授予的信号量的初始请求数。</param>
      <param name="maximumCount">可以同时授予的信号量的最大请求数。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 小于 1。  
  
- 或 - 
 <paramref name="initialCount" /> 小于 0。</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称。</summary>
      <param name="initialCount">可以同时授予的信号量的初始请求数。</param>
      <param name="maximumCount">可以同时授予的信号量的最大请求数。</param>
      <param name="name">信号灯的名称。 如果是 <see langword="null" /> 或为空，则创建一个进程本地的信号灯。 如果名称以“Global"为前缀，则会创建一个计算机范围的信号灯（或返回的现有信号灯）。 如果以“Local"为前缀，则会创建一个会话范围的信号灯（或返回的现有信号灯）。 如果名称不带任何前缀，则会创建一个会话范围的信号灯（与带前缀“Local"时相同）。 前缀和名称都区分大小写。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 小于 1。  
  
- 或 - 
 <paramref name="initialCount" /> 小于 0。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。</summary>
      <param name="initialCount">可以同时满足的信号量的初始请求数。</param>
      <param name="maximumCount">可以同时满足的信号量的最大请求数。</param>
      <param name="name">信号灯的名称。 如果是 <see langword="null" /> 或为空，则创建一个进程本地的信号灯。 如果名称以“Global"为前缀，则会创建一个计算机范围的信号灯（或返回的现有信号灯）。 如果以“Local"为前缀，则会创建一个会话范围的信号灯（或返回的现有信号灯）。 如果名称不带任何前缀，则会创建一个会话范围的信号灯（与带前缀“Local"时相同）。 前缀和名称都区分大小写。</param>
      <param name="createdNew">在此方法返回时，如果创建了本地信号量（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统信号量，则包含 <see langword="true" />；如果指定的命名系统信号量已存在，则为 <see langword="false" />。 此参数未经初始化即被传递。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 小于 1。  
  
- 或 - 
 <paramref name="initialCount" /> 小于 0。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>打开指定名称为信号量（如果已经存在）。</summary>
      <param name="name">信号灯的名称。 如果名称以“Global"为前缀，则表示计算机范围的信号灯。 如果名称以“Local"为前缀，或者不包含前缀，则表示会话范围的信号灯。 前缀和名称都区分大小写。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">命名的信号量不存在。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</exception>
      <returns>一个对象，表示已命名的系统信号量。</returns>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>退出信号量并返回前一个计数。</summary>
      <exception cref="T:System.Threading.SemaphoreFullException">信号量计数已是最大值。</exception>
      <exception cref="T:System.IO.IOException">发生已命名信号量的 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">当前信号量表示一个已命名的系统信号量，但用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />。  
  
- 或 - 
当前信号量表示一个已命名的系统信号量，但它未用 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 打开。</exception>
      <returns>调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。</returns>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>以指定的次数退出信号量并返回前一个计数。</summary>
      <param name="releaseCount">退出信号量的次数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> 小于 1。</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">信号量计数已是最大值。</exception>
      <exception cref="T:System.IO.IOException">发生已命名信号量的 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">当前信号量表示一个已命名的系统信号量，但用户不具备 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限。  
  
- 或 - 
当前信号量表示一个已命名的系统信号量，但它不是以 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限打开的。</exception>
      <returns>调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。</returns>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。</summary>
      <param name="name">信号灯的名称。 如果名称以“Global"为前缀，则表示计算机范围的信号灯。 如果名称以“Local"为前缀，或者不包含前缀，则表示会话范围的信号灯。 前缀和名称都区分大小写。</param>
      <param name="result">当此方法返回时，如果调用成功，则包含表示命名信号的 <see cref="T:System.Threading.Semaphore" /> 对象；否则为 <see langword="null" />。 该参数未经初始化即被处理。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。  
  
- 或 - 
 <paramref name="name" /> 超过 260 个字符。</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。</exception>
      <exception cref="T:System.IO.IOException">出现 Win32 错误。</exception>
      <exception cref="T:System.UnauthorizedAccessException">存在该命名信号量，但用户没有使用它时所需的安全访问权限。</exception>
      <returns>如果命名信号量成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>对已经达到最大计数值的信号量调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>使用默认值初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。</summary>
      <param name="info">存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，该对象包含有关源或目标的上下文信息。</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>用指定的错误消息初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>对可同时访问资源或资源池的线程数加以限制的 <see cref="T:System.Threading.Semaphore" /> 的轻量替代。</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 类的新实例，以指定可同时授予的请求的初始数量。</summary>
      <param name="initialCount">可以同时授予的信号量的初始请求数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0。</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 类的新实例，同时指定可同时授予的请求的初始数量和最大数量。</summary>
      <param name="initialCount">可以同时授予的信号量的初始请求数。</param>
      <param name="maxCount">可以同时授予的信号量的最大请求数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0，或 <paramref name="initialCount" /> 大于 <paramref name="maxCount" />，或 <paramref name="maxCount" /> 小于等于 0。</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>释放 <see cref="T:System.Threading.SemaphoreSlim" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>释放由 <see cref="T:System.Threading.SemaphoreSlim" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
      <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>释放 <see cref="T:System.Threading.SemaphoreSlim" /> 对象一次。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> 已达到其最大大小。</exception>
      <returns>
        <see cref="T:System.Threading.SemaphoreSlim" /> 的前一个计数。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>释放 <see cref="T:System.Threading.SemaphoreSlim" /> 对象指定的次数。</summary>
      <param name="releaseCount">退出信号量的次数。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> 小于 1。</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> 已达到其最大大小。</exception>
      <returns>
        <see cref="T:System.Threading.SemaphoreSlim" /> 的前一个计数。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时使用 32 位带符号整数来指定超时。</summary>
      <param name="millisecondsTimeout">要等待的毫秒数，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示无限等待，零表示测试等待句柄的状态并立即返回。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是 -1 之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.SemaphoreSlim" />。</exception>
      <returns>如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，并使用 32 位带符号整数来指定超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="millisecondsTimeout">要等待的毫秒数，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示无限等待，零表示测试等待句柄的状态并立即返回。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是除 -1 以外的负数，表示无限超时。

- 或 -

<paramref name="millisecondsTimeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Threading.SemaphoreSlim" /> 实例，或已释放创建 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      <returns>如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。  
  
- 或 - 
创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时使用 <see cref="T:System.TimeSpan" /> 来指定超时。</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> 表示要等待的毫秒数，<see cref="T:System.TimeSpan" /> 表示要无无限等待的 -1 毫秒，<see cref="T:System.TimeSpan" /> 表示要测试句柄并立即返回的 0 毫秒。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是除 -1 以外的负数，表示无限超时。

- 或 -

<paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 semaphoreSlim 实例。</exception>
      <returns>如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，并使用 <see cref="T:System.TimeSpan" /> 来指定超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> 表示要等待的毫秒数，<see cref="T:System.TimeSpan" /> 表示要无无限等待的 -1 毫秒，<see cref="T:System.TimeSpan" /> 表示要测试句柄并立即返回的 0 毫秒。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是除 -1 以外的负数，表示无限超时。

-或-。

<paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放 semaphoreSlim 实例。
          
- 或 -

创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</exception>
      <returns>如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.SemaphoreSlim" />。</exception>
      <returns>输入信号量时完成任务。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 32 位带符号整数度量时间间隔。</summary>
      <param name="millisecondsTimeout">要等待的毫秒数，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示无限等待，零表示测试等待句柄状态并立即返回。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是除 -1 以外的负数，表示无限超时。
          
- 或 - 
<paramref name="millisecondsTimeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>在观察 <see cref="T:System.Threading.CancellationToken" /> 时，输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 32 位带符号整数度量时间间隔。</summary>
      <param name="millisecondsTimeout">要等待的毫秒数，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示无限等待，零表示测试等待句柄状态并立即返回。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是除 -1 以外的数字，表示无限超时。
          
- 或 -

<paramref name="millisecondsTimeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <returns>如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>在观察 <see cref="T:System.Threading.CancellationToken" /> 时，输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待。</summary>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <returns>输入信号量时完成任务。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 <see cref="T:System.TimeSpan" /> 度量时间间隔。</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> 表示要等待的毫秒数，<see cref="T:System.TimeSpan" /> 表示要无无限等待的 -1 毫秒，<see cref="T:System.TimeSpan" /> 表示要测试句柄并立即返回的 0 毫秒。</param>
      <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是除 -1 以外的负数，表示无限超时。

- 或 - 
<paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>在观察 <see cref="T:System.Threading.SemaphoreSlim" /> 时，输入 <see cref="T:System.TimeSpan" /> 的异步等待，使用 <see cref="T:System.Threading.CancellationToken" /> 度量时间间隔。</summary>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> 表示要等待的毫秒数，<see cref="T:System.TimeSpan" /> 表示要无无限等待的 -1 毫秒，<see cref="T:System.TimeSpan" /> 表示要测试句柄并立即返回的 0 毫秒。</param>
      <param name="cancellationToken">要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是除 -1 以外的负数，表示无限超时。
          
- 或 -

<paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.SemaphoreSlim" />。</exception>
      <returns>如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。</returns>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>返回一个可用于在信号量上等待的 <see cref="T:System.Threading.WaitHandle" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.SemaphoreSlim" />。</exception>
      <returns>可用于在信号量上等待的 <see cref="T:System.Threading.WaitHandle" />。</returns>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>获取可以输入 <see cref="T:System.Threading.SemaphoreSlim" /> 对象的剩余线程数。</summary>
      <returns>可以输入信号量的剩余线程数。</returns>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>表示在消息即将被调度到同步上下文时要调用的方法。</summary>
      <param name="state">传递给委托的对象。</param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>使用用于跟踪线程 ID 以改善调试的选项初始化 <see cref="T:System.Threading.SpinLock" /> 结构的新实例。</summary>
      <param name="enableThreadOwnerTracking">是否捕获线程 ID 并将其用于调试目的。</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查 <paramref name="lockTaken" /> 以确定是否已获取锁。</summary>
      <param name="lockTaken">如果已获取锁，则为 true，否则为 false。 调用此方法前，必须将 <paramref name="lockTaken" /> 始化为 false。</param>
      <exception cref="T:System.ArgumentException">在调用 Enter 之前，<paramref name="lockTaken" /> 参数必须初始化为 false。</exception>
      <exception cref="T:System.Threading.LockRecursionException">线程所有权跟踪已启用，当前线程已获取此锁定。</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>释放锁。</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">启用线程所有权跟踪，当前线程不是此锁的所有者。</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>释放锁。</summary>
      <param name="useMemoryBarrier">一个布尔值，该值指示是否应发出内存界定，以便将退出操作立即发布到其他线程。</param>
      <exception cref="T:System.Threading.SynchronizationLockException">启用线程所有权跟踪，当前线程不是此锁的所有者。</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <paramref name="lockTaken" /> 以确定是否已获取锁。</summary>
      <param name="lockTaken">如果已获取锁，则为 true，否则为 false。 调用此方法前，必须将 <paramref name="lockTaken" /> 始化为 false。</param>
      <exception cref="T:System.ArgumentException">在调用 TryEnter 之前，<paramref name="lockTaken" /> 参数必须在初始化为 false。</exception>
      <exception cref="T:System.Threading.LockRecursionException">线程所有权跟踪已启用，当前线程已获取此锁定。</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <paramref name="lockTaken" /> 以确定是否已获取锁。</summary>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <param name="lockTaken">如果已获取锁，则为 true，否则为 false。 调用此方法前，必须将 <paramref name="lockTaken" /> 始化为 false。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <exception cref="T:System.ArgumentException">在调用 TryEnter 之前，<paramref name="lockTaken" /> 参数必须在初始化为 false。</exception>
      <exception cref="T:System.Threading.LockRecursionException">线程所有权跟踪已启用，当前线程已获取此锁定。</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <paramref name="lockTaken" /> 以确定是否已获取锁。</summary>
      <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
      <param name="lockTaken">如果已获取锁，则为 true，否则为 false。 调用此方法前，必须将 <paramref name="lockTaken" /> 始化为 false。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      <exception cref="T:System.ArgumentException">在调用 TryEnter 之前，<paramref name="lockTaken" /> 参数必须在初始化为 false。</exception>
      <exception cref="T:System.Threading.LockRecursionException">线程所有权跟踪已启用，当前线程已获取此锁定。</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>获取锁当前是否已由任何线程占用。</summary>
      <returns>如果锁当前已由任何线程占用，则为 true；否则为 false。</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>获取锁是否已由当前线程占用。</summary>
      <exception cref="T:System.InvalidOperationException">禁用线程所有权跟踪。</exception>
      <returns>如果锁已由当前线程占用，则为 true；否则为 false。</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>获取是否已为此实例启用了线程所有权跟踪。</summary>
      <returns>如果已为此实例启用了线程所有权跟踪，则为 true；否则为 false。</returns>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>为基于自旋的等待提供支持。</summary>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>重置自旋计数器。</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>执行单一自旋。</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
      <summary>执行单一自旋，并在达到最小旋转计数后调用 <see cref="M:System.Threading.Thread.Sleep(System.Int32)" />。</summary>
      <param name="sleep1Threshold">将在其后使用 <see langword="Thread.Sleep(1)" /> 的最小旋转计数。 值为 -1 将禁用 <see langword="Thread.Sleep(1)" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sleep1Threshold" /> 小于 -1。</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>在指定条件得到满足之前自旋。</summary>
      <param name="condition">在返回 true 之前重复执行的委托。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>在指定条件得到满足或指定超时过期之前自旋。</summary>
      <param name="condition">在返回 true 之前重复执行的委托。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
      <returns>如果条件在超时时间内得到满足，则为 <see langword="true" />；否则为 false</returns>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>在指定条件得到满足或指定超时过期之前自旋。</summary>
      <param name="condition">在返回 true 之前重复执行的委托。</param>
      <param name="timeout">一个 <see cref="T:System.TimeSpan" />，表示等待的毫秒数；或者一个 TimeSpan，表示 -1 毫秒（无限期等待）。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      <returns>如果条件在超时时间内得到满足，则为 <see langword="true" />；否则为 false</returns>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>获取已对此实例调用 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 的次数。</summary>
      <returns>返回一个整数，该整数表示已对此实例调用 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 的次数。</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>获取对 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 的下一次调用是否将产生处理器，同时触发强制上下文切换。</summary>
      <returns>对 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 的下一次调用是否将产生处理器，同时触发强制上下文切换。</returns>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>提供在各种同步模型中传播同步上下文的基本功能。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>创建 <see cref="T:System.Threading.SynchronizationContext" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>在派生类中重写时，创建同步上下文的副本。</summary>
      <returns>一个新 <see cref="T:System.Threading.SynchronizationContext" /> 对象。</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>确定是否需要等待通知。</summary>
      <returns>如果需要等待通知，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>在派生类中重写时，响应操作已完成的通知。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>在派生类中重写时，响应操作已开始的通知。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>在派生类中重写时，将异步消息分派到同步上下文。</summary>
      <param name="d">要调用的 <see cref="T:System.Threading.SendOrPostCallback" /> 委托。</param>
      <param name="state">传递给委托的对象。</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>在派生类中重写时，将同步消息分派到同步上下文。</summary>
      <param name="d">要调用的 <see cref="T:System.Threading.SendOrPostCallback" /> 委托。</param>
      <param name="state">传递给委托的对象。</param>
      <exception cref="T:System.NotSupportedException">在 Windows Store 应用程序中调用的方法。 用于 Windows Store 应用程序的 <see cref="T:System.Threading.SynchronizationContext" /> 的实现应用不支持 <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" /> 方法。</exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>设置当前同步上下文。</summary>
      <param name="syncContext">要设置的 <see cref="T:System.Threading.SynchronizationContext" /> 对象。</param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>设置指示需要等待通知的通知，并准备回调方法以使其在发生等待时可以更可靠地被调用。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>等待指定数组中的任一元素或所有元素接收信号。</summary>
      <param name="waitHandles">一个类型为 <see cref="T:System.IntPtr" /> 的数组，其中包含本机操作系统句柄。</param>
      <param name="waitAll">若等待所有句柄，则为 <see langword="true" />；若等待任一句柄，则为 <see langword="false" />。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="waitHandles" /> 为 null。</exception>
      <returns>满足等待的对象的数组索引。</returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>用于等待指定数组中的任一元素或所有元素接收信号的 Helper 函数。</summary>
      <param name="waitHandles">一个类型为 <see cref="T:System.IntPtr" /> 的数组，其中包含本机操作系统句柄。</param>
      <param name="waitAll">如果等待所有句柄，则为 <see langword="true" />；如果等待任一句柄，则为 <see langword="false" />。</param>
      <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
      <returns>满足等待的对象的数组索引。</returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>获取当前线程的同步上下文。</summary>
      <returns>一个 <see cref="T:System.Threading.SynchronizationContext" /> 对象，它表示当前同步上下文。</returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>当某个方法要求调用方拥有给定 Monitor 上的锁并且该方法由不拥有该锁的调用方调用时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>使用默认属性初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。</summary>
      <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>用指定的错误消息初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>提供数据的线程本地存储。</summary>
      <typeparam name="T">指定按线程存储的数据类型。</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例并指定是否可从任意线程访问所有值。</summary>
      <param name="trackAllValues">如果跟踪实例上的所有值集并通过 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 属性将其公开，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>使用指定的 <paramref name="valueFactory" /> 函数初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</summary>
      <param name="valueFactory">如果在 <see cref="T:System.Func`1" /> 之前尚未初始化的情况下尝试对其进行检索，则会调用 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 生成延迟初始化的值。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> 为 null 引用（在 Visual Basic 中为 Nothing）。</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>使用指定的 <paramref name="valueFactory" /> 函数和指示是否可从任意线程访问所有值的标志初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</summary>
      <param name="valueFactory">如果在 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 之前尚未初始化的情况下尝试对其进行检索，则会调用 <see cref="T:System.Func`1" /> 生成延迟初始化的值。</param>
      <param name="trackAllValues">如果跟踪实例上的所有值集并通过 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 属性将其公开，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> 为 <see langword="null" /> 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>释放 <see cref="T:System.Threading.ThreadLocal`1" /> 类的当前实例所使用的所有资源。</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>释放该 <see cref="T:System.Threading.ThreadLocal`1" /> 实例使用的资源。</summary>
      <param name="disposing">一个布尔值，该值指示是否由于调用 <see cref="M:System.Threading.ThreadLocal`1.Dispose" /> 的原因而调用此方法。</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>释放该 <see cref="T:System.Threading.ThreadLocal`1" /> 实例使用的资源。</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>创建并返回当前线程的此实例的字符串表示形式。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</exception>
      <exception cref="T:System.NullReferenceException">当前线程的 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 为 null 引用（Visual Basic 中为 Nothing）。</exception>
      <exception cref="T:System.InvalidOperationException">初始化函数尝试以递归方式引用 <see cref="P:System.Threading.ThreadLocal`1.Value" />。</exception>
      <exception cref="T:System.MissingMemberException">没有提供无参数构造函数，且没有提供值工厂。</exception>
      <returns>对 <see cref="M:System.Object.ToString" /> 调用 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 的结果。</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>获取是否在当前线程上初始化 <see cref="P:System.Threading.ThreadLocal`1.Value" />。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</exception>
      <returns>如果在当前线程上初始化 <see cref="P:System.Threading.ThreadLocal`1.Value" />，则为 true；否则为 false。</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>获取或设置当前线程的此实例的值。</summary>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</exception>
      <exception cref="T:System.InvalidOperationException">初始化函数尝试以递归方式引用 <see cref="P:System.Threading.ThreadLocal`1.Value" />。</exception>
      <exception cref="T:System.MissingMemberException">没有提供无参数构造函数，且没有提供值工厂。</exception>
      <returns>返回此 ThreadLocal 负责初始化的对象的实例。</returns>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>获取当前由已经访问此实例的所有线程存储的所有值的列表。</summary>
      <exception cref="T:System.InvalidOperationException">所有线程存储的值均不可用，因为此实例通过将 <paramref name="trackAllValues" /> 参数在对类构造函数的调用中设为 <see langword="false" /> 进行初始化。</exception>
      <exception cref="T:System.ObjectDisposedException">已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。</exception>
      <returns>访问此实例由所有线程存储的当前的所有值的列表。</returns>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>包含用于执行可变内存操作的方法。</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>读取指定字段的值。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <returns>读取的值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>从指定的字段读取对象引用。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之后，则处理器无法将其移至此方法之前。</summary>
      <param name="location">要读取的字段。</param>
      <typeparam name="T">要读取的字段的类型。 此类型必须是引用类型，而不是值类型。</typeparam>
      <returns>对读取的 <paramref name="T" /> 的引用。 无论处理器的数目或处理器缓存的状态如何，该引用都是由计算机的任何处理器写入的最新引用。</returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>将指定的值写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将值写入的字段。</param>
      <param name="value">要写入的值。 立即写入一个值，以使该值对计算机中的所有处理器都可见。</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>将指定的对象引用写入指定字段。 在需要进行此操作的系统上，插入防止处理器重新对内存操作进行排序的内存屏障，如下所示：如果读取或写入操作在代码中出现在此方法之前，则处理器无法将其移至此方法之后。</summary>
      <param name="location">将对象引用写入的字段。</param>
      <param name="value">要写入的对象引用。 立即写入一个引用，以使该引用对计算机中的所有处理器都可见。</param>
      <typeparam name="T">要写入的字段的类型。 此类型必须是引用类型，而不是值类型。</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>当尝试打开不存在的系统互斥体、信号量或事件等待句柄时引发的异常。</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>使用默认值初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>用序列化数据初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。</summary>
      <param name="info">存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，该对象包含有关源或目标的上下文信息。</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>用指定的错误消息初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。</summary>
      <param name="message">解释异常原因的错误消息。</param>
      <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。</param>
    </member>
  </members>
</doc>